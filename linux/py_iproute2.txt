Help on package pyroute2:

NAME
    pyroute2

DESCRIPTION
    ##
    #
    # This module contains all the public symbols from the library.
    #

PACKAGE CONTENTS
    arp
    bsd (package)
    cli (package)
    common
    config (package)
    conntrack
    devlink
    dhcp (package)
    ethtool (package)
    ext (package)
    inotify (package)
    ipdb (package)
    iproute (package)
    ipset
    iwutil
    lab
    ndb (package)
    netlink (package)
    netns (package)
    nftables (package)
    nslink (package)
    protocols (package)
    remote (package)
    requests (package)
    wiset

SUBMODULES
    loaded
    log

CLASSES
    builtins.Exception(builtins.BaseException)
        pyroute2.ipdb.exceptions.CommitException
        pyroute2.ipdb.exceptions.CreateException
        pyroute2.ipdb.exceptions.DeprecationException
        pyroute2.ipdb.exceptions.PartialCommitException
        pyroute2.netlink.exceptions.ChaoticException
        pyroute2.netlink.exceptions.NetlinkDecodeError
        pyroute2.netlink.exceptions.NetlinkError
            pyroute2.netlink.exceptions.NetlinkDumpInterrupted
    builtins.object
        pyroute2.common.FailedClass
        pyroute2.conntrack.ConntrackEntry
        pyroute2.ethtool.ethtool.Ethtool
        pyroute2.ipdb.main.IPDB
        pyroute2.ndb.main.NDB
        pyroute2.ndb.noipdb.NoIPDB
        pyroute2.wiset.WiSet
    code.InteractiveConsole(code.InteractiveInterpreter)
        pyroute2.cli.console.Console
    http.server.HTTPServer(socketserver.TCPServer)
        pyroute2.cli.server.Server
    pyroute2.iproute.linux.RTNL_API(builtins.object)
        pyroute2.iproute.linux.ChaoticIPRoute(pyroute2.iproute.linux.RTNL_API, pyroute2.netlink.rtnl.iprsocket.ChaoticIPRSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.iproute.linux.IPBatch(pyroute2.iproute.linux.RTNL_API, pyroute2.netlink.rtnl.iprsocket.IPBatchSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.iproute.linux.IPRoute(pyroute2.lab.LAB_API, pyroute2.iproute.linux.RTNL_API, pyroute2.netlink.rtnl.iprsocket.IPRSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.iproute.linux.RawIPRoute(pyroute2.iproute.linux.RTNL_API, pyroute2.netlink.rtnl.riprsocket.RawIPRSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.nslink.nslink.NetNS(pyroute2.iproute.linux.RTNL_API, pyroute2.remote.transport.RemoteSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
    pyroute2.lab.LAB_API(builtins.object)
        pyroute2.iproute.ipmock.IPRoute(pyroute2.lab.LAB_API, pyroute2.netlink.nlsocket.NetlinkSocketBase, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.iproute.linux.IPRoute(pyroute2.lab.LAB_API, pyroute2.iproute.linux.RTNL_API, pyroute2.netlink.rtnl.iprsocket.IPRSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
    pyroute2.netlink.event.EventSocket(pyroute2.netlink.generic.GenericNetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.netlink.event.acpi_event.AcpiEventSocket(pyroute2.netlink.event.EventSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.netlink.event.dquot.DQuotSocket(pyroute2.netlink.event.EventSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
    pyroute2.netlink.nlsocket.NetlinkSocket(pyroute2.netlink.nlsocket.NetlinkSocketBase, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.ipset.IPSet(pyroute2.netlink.nlsocket.NetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.netlink.diag.DiagSocket(pyroute2.netlink.nlsocket.NetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.netlink.generic.GenericNetlinkSocket(pyroute2.netlink.nlsocket.NetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
            pyroute2.netlink.devlink.DevlinkSocket(pyroute2.netlink.generic.GenericNetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
                pyroute2.devlink.DL(pyroute2.netlink.devlink.DevlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
            pyroute2.netlink.generic.l2tp.L2tp(pyroute2.netlink.generic.GenericNetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
            pyroute2.netlink.generic.mptcp.MPTCP(pyroute2.netlink.generic.GenericNetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
            pyroute2.netlink.generic.wireguard.WireGuard(pyroute2.netlink.generic.GenericNetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
            pyroute2.netlink.nl80211.NL80211(pyroute2.netlink.generic.GenericNetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
                pyroute2.iwutil.IW(pyroute2.netlink.nl80211.NL80211, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
            pyroute2.netlink.taskstats.TaskStats(pyroute2.netlink.generic.GenericNetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.netlink.ipq.IPQSocket(pyroute2.netlink.nlsocket.NetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.netlink.nfnetlink.nfctsocket.NFCTSocket(pyroute2.netlink.nlsocket.NetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
            pyroute2.conntrack.Conntrack(pyroute2.netlink.nfnetlink.nfctsocket.NFCTSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.netlink.nfnetlink.nftsocket.NFTSocket(pyroute2.netlink.nlsocket.NetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
            pyroute2.nftables.main.NFTables(pyroute2.netlink.nfnetlink.nftsocket.NFTSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.netlink.rtnl.iprsocket.IPRSocket(pyroute2.netlink.rtnl.iprsocket.IPRSocketBase, pyroute2.netlink.nlsocket.NetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
            pyroute2.iproute.linux.IPRoute(pyroute2.lab.LAB_API, pyroute2.iproute.linux.RTNL_API, pyroute2.netlink.rtnl.iprsocket.IPRSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.netlink.uevent.UeventSocket(pyroute2.netlink.nlsocket.NetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
    pyroute2.netlink.nlsocket.NetlinkSocketBase(pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.iproute.ipmock.IPRoute(pyroute2.lab.LAB_API, pyroute2.netlink.nlsocket.NetlinkSocketBase, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.remote.transport.RemoteSocket(pyroute2.netlink.nlsocket.NetlinkSocketBase, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
            pyroute2.nslink.nslink.NetNS(pyroute2.iproute.linux.RTNL_API, pyroute2.remote.transport.RemoteSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
    pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe(builtins.object)
        pyroute2.iproute.ipmock.IPRoute(pyroute2.lab.LAB_API, pyroute2.netlink.nlsocket.NetlinkSocketBase, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.iproute.linux.ChaoticIPRoute(pyroute2.iproute.linux.RTNL_API, pyroute2.netlink.rtnl.iprsocket.ChaoticIPRSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.iproute.linux.IPBatch(pyroute2.iproute.linux.RTNL_API, pyroute2.netlink.rtnl.iprsocket.IPBatchSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.iproute.linux.RawIPRoute(pyroute2.iproute.linux.RTNL_API, pyroute2.netlink.rtnl.riprsocket.RawIPRSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.ipset.IPSet(pyroute2.netlink.nlsocket.NetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.netlink.diag.DiagSocket(pyroute2.netlink.nlsocket.NetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.netlink.event.acpi_event.AcpiEventSocket(pyroute2.netlink.event.EventSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.netlink.event.dquot.DQuotSocket(pyroute2.netlink.event.EventSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.netlink.generic.GenericNetlinkSocket(pyroute2.netlink.nlsocket.NetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
            pyroute2.netlink.devlink.DevlinkSocket(pyroute2.netlink.generic.GenericNetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
                pyroute2.devlink.DL(pyroute2.netlink.devlink.DevlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
            pyroute2.netlink.generic.l2tp.L2tp(pyroute2.netlink.generic.GenericNetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
            pyroute2.netlink.generic.mptcp.MPTCP(pyroute2.netlink.generic.GenericNetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
            pyroute2.netlink.generic.wireguard.WireGuard(pyroute2.netlink.generic.GenericNetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
            pyroute2.netlink.nl80211.NL80211(pyroute2.netlink.generic.GenericNetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
                pyroute2.iwutil.IW(pyroute2.netlink.nl80211.NL80211, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
            pyroute2.netlink.taskstats.TaskStats(pyroute2.netlink.generic.GenericNetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.netlink.ipq.IPQSocket(pyroute2.netlink.nlsocket.NetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.netlink.nfnetlink.nfctsocket.NFCTSocket(pyroute2.netlink.nlsocket.NetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
            pyroute2.conntrack.Conntrack(pyroute2.netlink.nfnetlink.nfctsocket.NFCTSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.netlink.nfnetlink.nftsocket.NFTSocket(pyroute2.netlink.nlsocket.NetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
            pyroute2.nftables.main.NFTables(pyroute2.netlink.nfnetlink.nftsocket.NFTSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.netlink.rtnl.iprsocket.IPRSocket(pyroute2.netlink.rtnl.iprsocket.IPRSocketBase, pyroute2.netlink.nlsocket.NetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
            pyroute2.iproute.linux.IPRoute(pyroute2.lab.LAB_API, pyroute2.iproute.linux.RTNL_API, pyroute2.netlink.rtnl.iprsocket.IPRSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.netlink.uevent.UeventSocket(pyroute2.netlink.nlsocket.NetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.remote.transport.RemoteSocket(pyroute2.netlink.nlsocket.NetlinkSocketBase, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
            pyroute2.nslink.nslink.NetNS(pyroute2.iproute.linux.RTNL_API, pyroute2.remote.transport.RemoteSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
    pyroute2.netlink.rtnl.iprsocket.ChaoticIPRSocket(pyroute2.netlink.rtnl.iprsocket.IPRSocketBase, pyroute2.netlink.nlsocket.ChaoticNetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.iproute.linux.ChaoticIPRoute(pyroute2.iproute.linux.RTNL_API, pyroute2.netlink.rtnl.iprsocket.ChaoticIPRSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
    pyroute2.netlink.rtnl.iprsocket.IPBatchSocket(pyroute2.netlink.rtnl.iprsocket.IPRSocketBase, pyroute2.netlink.nlsocket.BatchSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.iproute.linux.IPBatch(pyroute2.iproute.linux.RTNL_API, pyroute2.netlink.rtnl.iprsocket.IPBatchSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
    pyroute2.netlink.rtnl.iprsocket.IPRSocketBase(builtins.object)
        pyroute2.netlink.rtnl.iprsocket.IPRSocket(pyroute2.netlink.rtnl.iprsocket.IPRSocketBase, pyroute2.netlink.nlsocket.NetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
            pyroute2.iproute.linux.IPRoute(pyroute2.lab.LAB_API, pyroute2.iproute.linux.RTNL_API, pyroute2.netlink.rtnl.iprsocket.IPRSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
    pyroute2.netlink.rtnl.riprsocket.RawIPRSocket(pyroute2.netlink.rtnl.riprsocket.RawIPRSocketBase, pyroute2.netlink.nlsocket.NetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
        pyroute2.iproute.linux.RawIPRoute(pyroute2.iproute.linux.RTNL_API, pyroute2.netlink.rtnl.riprsocket.RawIPRSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
    pyroute2.nslink.nspopen.ObjNS(builtins.object)
        pyroute2.nslink.nspopen.NSPopen
    
    class AcpiEventSocket(pyroute2.netlink.event.EventSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  Low-level socket interface. Provides all the
     |  usual socket does, can be used in poll/select,
     |  doesn't create any implicit threads.
     |  
     |  Method resolution order:
     |      AcpiEventSocket
     |      pyroute2.netlink.event.EventSocket
     |      pyroute2.netlink.generic.GenericNetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  genl_family = 'acpi_event'
     |  
     |  marshal_class = <class 'pyroute2.netlink.event.acpi_event.MarshalAcpiE...
     |      Generic marshalling class
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.event.EventSocket:
     |  
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  bind(self, groups=0, **kwarg)
     |      Bind the socket and performs generic netlink
     |      proto lookup. The `proto` parameter is a string,
     |      like "TASKSTATS", `msg_class` is a class to
     |      parse messages with.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  add_membership(self, group)
     |  
     |  discovery(self, proto)
     |      Resolve generic netlink protocol -- takes a string
     |      as the only parameter, return protocol description
     |  
     |  drop_membership(self, group)
     |  
     |  get(self, *argv, **kwarg)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  nlm_request(self, *argv, **kwarg)
     |  
     |  policy(self, proto)
     |      Extract policy information for a generic netlink protocol -- takes
     |      a string as the only parameter, return protocol policy
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  prid
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  mcast_groups = {}
     |  
     |  module_err_level = 'error'
     |  
     |  module_err_message = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocket:
     |  
     |  __getattr__(self, attr)
     |  
     |  close(self, code=104)
     |      Correctly close the socket and free all resources.
     |  
     |  post_init(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  buffer_thread_routine(self)
     |  
     |  clone(self)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  recv(self, *argv, **kwarg)
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class ChaoticException(builtins.Exception)
     |  Common base class for all non-exit exceptions.
     |  
     |  Method resolution order:
     |      ChaoticException
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class ChaoticIPRoute(RTNL_API, pyroute2.netlink.rtnl.iprsocket.ChaoticIPRSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  ChaoticIPRoute(*argv, **kwarg)
     |  
     |  IPRoute interface for chaotic tests - raising exceptions randomly.
     |  
     |  Method resolution order:
     |      ChaoticIPRoute
     |      RTNL_API
     |      pyroute2.netlink.rtnl.iprsocket.ChaoticIPRSocket
     |      pyroute2.netlink.rtnl.iprsocket.IPRSocketBase
     |      pyroute2.netlink.nlsocket.ChaoticNetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Methods inherited from RTNL_API:
     |  
     |  __init__(self, *argv, **kwarg)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  addr(self, command, *argv, **kwarg)
     |      Address operations
     |      
     |      * command -- add, delete, replace, dump
     |      * index -- device index
     |      * address -- IPv4 or IPv6 address
     |      * mask -- address mask
     |      * family -- socket.AF_INET for IPv4 or socket.AF_INET6 for IPv6
     |      * scope -- the address scope, see /etc/iproute2/rt_scopes
     |      * kwarg -- dictionary, any ifaddrmsg field or NLA
     |      
     |      Later the method signature will be changed to::
     |      
     |          def addr(self, command, match=None, **kwarg):
     |              # the method body
     |      
     |      So only keyword arguments (except of the command) will be accepted.
     |      The reason for this change is an unification of API.
     |      
     |      Example::
     |      
     |          idx = 62
     |          ip.addr('add', index=idx, address='10.0.0.1', mask=24)
     |          ip.addr('add', index=idx, address='10.0.0.2', mask=24)
     |      
     |      With more NLAs::
     |      
     |          # explicitly set broadcast address
     |          ip.addr('add', index=idx,
     |                  address='10.0.0.3',
     |                  broadcast='10.0.0.255',
     |                  prefixlen=24)
     |      
     |          # make the secondary address visible to ifconfig: add label
     |          ip.addr('add', index=idx,
     |                  address='10.0.0.4',
     |                  broadcast='10.0.0.255',
     |                  prefixlen=24,
     |                  label='eth0:1')
     |      
     |      Configure p2p address on an interface::
     |      
     |          ip.addr('add', index=idx,
     |                  address='10.1.1.2',
     |                  mask=24,
     |                  local='10.1.1.1')
     |  
     |  brport(self, command, **kwarg)
     |      Set bridge port parameters. Example::
     |      
     |          idx = ip.link_lookup(ifname='eth0')
     |          ip.brport("set", index=idx, unicast_flood=0, cost=200)
     |          ip.brport("show", index=idx)
     |      
     |      Possible keywords are NLA names for the `protinfo_bridge` class,
     |      without the prefix and in lower letters.
     |  
     |  dump(self, groups=None)
     |      Dump network objects.
     |      
     |      On OpenBSD:
     |      
     |      * get_links()
     |      * get_addr()
     |      * get_neighbours()
     |      * get_routes()
     |      
     |      On Linux:
     |      
     |      * get_links()
     |      * get_addr()
     |      * get_neighbours()
     |      * get_vlans()
     |      * dump FDB
     |      * IPv4 and IPv6 rules
     |  
     |  fdb(self, command, **kwarg)
     |      Bridge forwarding database management.
     |      
     |      More details:
     |          * kernel:Documentation/networking/switchdev.txt
     |          * pyroute2.netlink.rtnl.ndmsg
     |      
     |      **add**
     |      
     |      Add a new FDB record. Works in the same way as ARP cache
     |      management, but some additional NLAs can be used::
     |      
     |          # simple FDB record
     |          #
     |          ip.fdb('add',
     |                 ifindex=ip.link_lookup(ifname='br0')[0],
     |                 lladdr='00:11:22:33:44:55',
     |                 dst='10.0.0.1')
     |      
     |          # specify vlan
     |          # NB: vlan should exist on the device, use
     |          # `vlan_filter()`
     |          #
     |          ip.fdb('add',
     |                 ifindex=ip.link_lookup(ifname='br0')[0],
     |                 lladdr='00:11:22:33:44:55',
     |                 dst='10.0.0.1',
     |                 vlan=200)
     |      
     |          # specify vxlan id and port
     |          # NB: works only for vxlan devices, use
     |          # `link("add", kind="vxlan", ...)`
     |          #
     |          # if port is not specified, the default one is used
     |          # by the kernel.
     |          #
     |          # if vni (vxlan id) is equal to the device vni,
     |          # the kernel doesn't report it back
     |          #
     |          ip.fdb('add',
     |                 ifindex=ip.link_lookup(ifname='vx500')[0]
     |                 lladdr='00:11:22:33:44:55',
     |                 dst='10.0.0.1',
     |                 port=5678,
     |                 vni=600)
     |      
     |      **append**
     |      
     |      Append a new FDB record. The same syntax as for **add**.
     |      
     |      **del**
     |      
     |      Remove an existing FDB record. The same syntax as for **add**.
     |      
     |      **dump**
     |      
     |      Dump all the FDB records. If any `**kwarg` is provided,
     |      results will be filtered::
     |      
     |          # dump all the records
     |          ip.fdb('dump')
     |      
     |          # show only specific lladdr, dst, vlan etc.
     |          ip.fdb('dump', lladdr='00:11:22:33:44:55')
     |          ip.fdb('dump', dst='10.0.0.1')
     |          ip.fdb('dump', vlan=200)
     |  
     |  filter_messages(self, dump_filter, msgs)
     |      Filter messages using `dump_filter`. The filter might be a
     |      callable, then it will be called for every message in the list.
     |      Or it might be a dict, where keys are used to get values
     |      from messages, and dict values are used to match the message.
     |      
     |      The method might be called directly. It is also used by calls
     |      like `ipr.link('dump', ....)`, where keyword arguments work as
     |      `dump_filter` for `ipr.filter_messages()`.
     |      
     |      A callable `dump_filter` must return True or False:
     |      
     |      .. code-block:: python
     |      
     |          # get all links with names starting with eth:
     |          #
     |          ipr.filter_messages(
     |              lambda x: x.get_attr('IFLA_IFNAME').startswith('eth'),
     |              ipr.link('dump')
     |          )
     |      
     |      A dict `dump_filter` can have callables as values:
     |      
     |      .. code-block:: python
     |      
     |          # get all links with names starting with eth, and
     |          # MAC address in a database:
     |          #
     |          ipr.filter_messages(
     |              {
     |                  'ifname': lambda x: x.startswith('eth'),
     |                  'address': lambda x: x in database,
     |              },
     |              ipr.link('dump')
     |          )
     |      
     |      ... or constants to compare with:
     |      
     |      .. code-block:: python
     |      
     |          # get all links in state up:
     |          #
     |          ipr.filter_message({'state': 'up'}, ipr.link('dump'))
     |  
     |  flush_addr(self, *argv, **kwarg)
     |      Flush IP addresses.
     |      
     |      Examples::
     |      
     |          # flush all addresses on the interface with index 2:
     |          ipr.flush_addr(index=2)
     |      
     |          # flush all addresses with IFA_LABEL='eth0':
     |          ipr.flush_addr(label='eth0')
     |  
     |  flush_routes(self, *argv, **kwarg)
     |      Flush routes -- purge route records from a table.
     |      Arguments are the same as for `get_routes()`
     |      routine. Actually, this routine implements a pipe from
     |      `get_routes()` to `nlm_request()`.
     |  
     |  flush_rules(self, *argv, **kwarg)
     |      Flush rules. Please keep in mind, that by default the function
     |      operates on **all** rules of **all** families. To work only on
     |      IPv4 rules, one should explicitly specify `family=AF_INET`.
     |      
     |      Examples::
     |      
     |          # flush all IPv4 rule with priorities above 5 and below 32000
     |          ipr.flush_rules(family=AF_INET, priority=lambda x: 5 < x < 32000)
     |      
     |          # flush all IPv6 rules that point to table 250:
     |          ipr.flush_rules(family=socket.AF_INET6, table=250)
     |  
     |  get_addr(self, family=<AddressFamily.AF_UNSPEC: 0>, match=None, **kwarg)
     |      Dump addresses.
     |      
     |      If family is not specified, both AF_INET and AF_INET6 addresses
     |      will be dumped::
     |      
     |          # get all addresses
     |          ip.get_addr()
     |      
     |      It is possible to apply filters on the results::
     |      
     |          # get addresses for the 2nd interface
     |          ip.get_addr(index=2)
     |      
     |          # get addresses with IFA_LABEL == 'eth0'
     |          ip.get_addr(label='eth0')
     |      
     |          # get all the subnet addresses on the interface, identified
     |          # by broadcast address (should be explicitly specified upon
     |          # creation)
     |          ip.get_addr(index=2, broadcast='192.168.1.255')
     |      
     |      A custom predicate can be used as a filter::
     |      
     |          ip.get_addr(match=lambda x: x['index'] == 1)
     |  
     |  get_classes(self, index=0)
     |      Get classes for specified interface.
     |  
     |  get_default_routes(self, family=<AddressFamily.AF_UNSPEC: 0>, table=254)
     |      Get default routes
     |  
     |  get_filters(self, index=0, handle=0, parent=0)
     |      Get filters for specified interface, handle and parent.
     |  
     |  get_links(self, *argv, **kwarg)
     |      Get network interfaces.
     |      
     |      By default returns all interfaces. Arguments vector
     |      can contain interface indices or a special keyword
     |      'all'::
     |      
     |          ip.get_links()
     |          ip.get_links('all')
     |          ip.get_links(1, 2, 3)
     |      
     |          interfaces = [1, 2, 3]
     |          ip.get_links(*interfaces)
     |  
     |  get_neighbours(self, family=<AddressFamily.AF_UNSPEC: 0>, match=None, **kwarg)
     |      Dump ARP cache records.
     |      
     |      The `family` keyword sets the family for the request:
     |      e.g. `AF_INET` or `AF_INET6` for arp cache, `AF_BRIDGE`
     |      for fdb.
     |      
     |      If other keyword arguments not empty, they are used as
     |      filter. Also, one can explicitly set filter as a function
     |      with the `match` parameter.
     |      
     |      Examples::
     |      
     |          # get neighbours on the 3rd link:
     |          ip.get_neighbours(ifindex=3)
     |      
     |          # get a particular record by dst:
     |          ip.get_neighbours(dst='172.16.0.1')
     |      
     |          # get fdb records:
     |          ip.get_neighbours(AF_BRIDGE)
     |      
     |          # and filter them by a function:
     |          ip.get_neighbours(AF_BRIDGE, match=lambda x: x['state'] == 2)
     |  
     |  get_netns_info(self, list_proc=False)
     |      A prototype method to list available netns and associated
     |      interfaces. A bit weird to have it here and not under
     |      `pyroute2.netns`, but it uses RTNL to get all the info.
     |  
     |  get_netnsid(self, nsid=None, pid=None, fd=None, target_nsid=None)
     |      Return a dict containing the result of a RTM_GETNSID query.
     |      This loosely corresponds to the "ip netns list-id" command.
     |  
     |  get_ntables(self, family=<AddressFamily.AF_UNSPEC: 0>)
     |      Get neighbour tables
     |  
     |  get_qdiscs(self, index=None)
     |      Get all queue disciplines for all interfaces or for specified
     |      one.
     |  
     |  get_routes(self, family=255, match=None, **kwarg)
     |      Get all routes. You can specify the table. There
     |      are up to 4294967295 routing classes (tables), and the kernel
     |      returns all the routes on each request. So the
     |      routine filters routes from full output. Note the number of
     |      tables is increased from 255 in Linux 2.6+.
     |      
     |      Example::
     |      
     |          ip.get_routes()  # get all the routes for all families
     |          ip.get_routes(family=AF_INET6)  # get only IPv6 routes
     |          ip.get_routes(table=254)  # get routes from 254 table
     |      
     |      The default family=255 is a hack. Despite the specs,
     |      the kernel returns only IPv4 routes for AF_UNSPEC family.
     |      But it returns all the routes for all the families if one
     |      uses an invalid value here. Hack but true. And let's hope
     |      the kernel team will not fix this bug.
     |  
     |  get_rules(self, family=<AddressFamily.AF_UNSPEC: 0>, match=None, **kwarg)
     |      Get all rules. By default return all rules. To explicitly
     |      request the IPv4 rules use `family=AF_INET`.
     |      
     |      Example::
     |          ip.get_rules() # get all the rules for all families
     |          ip.get_rules(family=AF_INET6)  # get only IPv6 rules
     |  
     |  get_vlans(self, **kwarg)
     |      Dump available vlan info on bridge ports
     |  
     |  link(self, command, **kwarg)
     |      Link operations.
     |      
     |      Keywords to set up ifinfmsg fields:
     |          * index -- interface index
     |          * family -- AF_BRIDGE for bridge operations, otherwise 0
     |          * flags -- device flags
     |          * change -- change mask
     |      
     |      All other keywords will be translated to NLA names, e.g.
     |      `mtu -> IFLA_MTU`, `af_spec -> IFLA_AF_SPEC` etc. You can
     |      provide a complete NLA structure or let filters do it for
     |      you. E.g., these pairs show equal statements::
     |      
     |          # set device MTU
     |          ip.link("set", index=x, mtu=1000)
     |          ip.link("set", index=x, IFLA_MTU=1000)
     |      
     |          # add vlan device
     |          ip.link("add", ifname="test", kind="dummy")
     |          ip.link("add", ifname="test",
     |                  IFLA_LINKINFO={'attrs': [['IFLA_INFO_KIND', 'dummy']]})
     |      
     |      Filters are implemented in the `pyroute2.iproute.req` module.
     |      You can contribute your own if you miss shortcuts.
     |      
     |      Commands:
     |      
     |      **add**
     |      
     |      To create an interface, one should specify the interface kind::
     |      
     |          ip.link("add",
     |                  ifname="test",
     |                  kind="dummy")
     |      
     |      The kind can be any of those supported by kernel. It can be
     |      `dummy`, `bridge`, `bond` etc. On modern kernels one can specify
     |      even interface index::
     |      
     |          ip.link("add",
     |                  ifname="br-test",
     |                  kind="bridge",
     |                  index=2345)
     |      
     |      Specific type notes:
     |      
     |      ► geneve
     |      
     |      Create GENEVE tunnel::
     |      
     |          ip.link("add",
     |                  ifname="genx",
     |                  kind="geneve",
     |                  geneve_id=42,
     |                  geneve_remote="172.16.0.101")
     |      
     |      Support for GENEVE over IPv6 is also included; use `geneve_remote6`
     |      to configure a remote IPv6 address.
     |      
     |      ► gre
     |      
     |      Create GRE tunnel::
     |      
     |          ip.link("add",
     |                  ifname="grex",
     |                  kind="gre",
     |                  gre_local="172.16.0.1",
     |                  gre_remote="172.16.0.101",
     |                  gre_ttl=16)
     |      
     |      The keyed GRE requires explicit iflags/oflags specification::
     |      
     |          ip.link("add",
     |                  ifname="grex",
     |                  kind="gre",
     |                  gre_local="172.16.0.1",
     |                  gre_remote="172.16.0.101",
     |                  gre_ttl=16,
     |                  gre_ikey=10,
     |                  gre_okey=10,
     |                  gre_iflags=32,
     |                  gre_oflags=32)
     |      
     |      Support for GRE over IPv6 is also included; use `kind=ip6gre` and
     |      `ip6gre_` as the prefix for its values.
     |      
     |      ► ipip
     |      
     |      Create ipip tunnel::
     |      
     |          ip.link("add",
     |                  ifname="tun1",
     |                  kind="ipip",
     |                  ipip_local="172.16.0.1",
     |                  ipip_remote="172.16.0.101",
     |                  ipip_ttl=16)
     |      
     |      Support for sit and ip6tnl is also included; use `kind=sit` and `sit_`
     |      as prefix for sit tunnels, and `kind=ip6tnl` and `ip6tnl_` prefix for
     |      ip6tnl tunnels.
     |      
     |      ► macvlan
     |      
     |      Macvlan interfaces act like VLANs within OS. The macvlan driver
     |      provides an ability to add several MAC addresses on one interface,
     |      where every MAC address is reflected with a virtual interface in
     |      the system.
     |      
     |      In some setups macvlan interfaces can replace bridge interfaces,
     |      providing more simple and at the same time high-performance
     |      solution::
     |      
     |          ip.link("add",
     |                  ifname="mvlan0",
     |                  kind="macvlan",
     |                  link=ip.link_lookup(ifname="em1")[0],
     |                  macvlan_mode="private").commit()
     |      
     |      Several macvlan modes are available: "private", "vepa", "bridge",
     |      "passthru". Ususally the default is "vepa".
     |      
     |      ► macvtap
     |      
     |      Almost the same as macvlan, but creates also a character tap device::
     |      
     |          ip.link("add",
     |                  ifname="mvtap0",
     |                  kind="macvtap",
     |                  link=ip.link_lookup(ifname="em1")[0],
     |                  macvtap_mode="vepa").commit()
     |      
     |      Will create a device file `"/dev/tap%s" % index`
     |      
     |      ► tuntap
     |      
     |      Possible `tuntap` keywords:
     |      
     |      * `mode` — "tun" or "tap"
     |      * `uid` — integer
     |      * `gid` — integer
     |      * `ifr` — dict of tuntap flags (see ifinfmsg:... tuntap_data)
     |      
     |      Create a tap interface::
     |      
     |          ip.link("add",
     |                  ifname="tap0",
     |                  kind="tuntap",
     |                  mode="tap")
     |      
     |      Tun/tap interfaces are created using `ioctl()`, but the library
     |      provides a transparent way to manage them using netlink API.
     |      
     |      ► veth
     |      
     |      To properly create `veth` interface, one should specify
     |      `peer` also, since `veth` interfaces are created in pairs::
     |      
     |          # simple call
     |          ip.link("add", ifname="v1p0", kind="veth", peer="v1p1")
     |      
     |          # set up specific veth peer attributes
     |          ip.link("add",
     |                  ifname="v1p0",
     |                  kind="veth",
     |                  peer={"ifname": "v1p1",
     |                        "net_ns_fd": "test_netns"})
     |      
     |      ► vlan
     |      
     |      VLAN interfaces require additional parameters, `vlan_id` and
     |      `link`, where `link` is a master interface to create VLAN on::
     |      
     |          ip.link("add",
     |                  ifname="v100",
     |                  kind="vlan",
     |                  link=ip.link_lookup(ifname="eth0")[0],
     |                  vlan_id=100)
     |      
     |      There is a possibility to create also 802.1ad interfaces::
     |      
     |          # create external vlan 802.1ad, s-tag
     |          ip.link("add",
     |                  ifname="v100s",
     |                  kind="vlan",
     |                  link=ip.link_lookup(ifname="eth0")[0],
     |                  vlan_id=100,
     |                  vlan_protocol=0x88a8)
     |      
     |          # create internal vlan 802.1q, c-tag
     |          ip.link("add",
     |                  ifname="v200c",
     |                  kind="vlan",
     |                  link=ip.link_lookup(ifname="v100s")[0],
     |                  vlan_id=200,
     |                  vlan_protocol=0x8100)
     |      
     |      
     |      ► vrf
     |      
     |      VRF interfaces (see linux/Documentation/networking/vrf.txt)::
     |      
     |          ip.link("add",
     |                  ifname="vrf-foo",
     |                  kind="vrf",
     |                  vrf_table=42)
     |      
     |      ► vxlan
     |      
     |      VXLAN interfaces are like VLAN ones, but require a bit more
     |      parameters::
     |      
     |          ip.link("add",
     |                  ifname="vx101",
     |                  kind="vxlan",
     |                  vxlan_link=ip.link_lookup(ifname="eth0")[0],
     |                  vxlan_id=101,
     |                  vxlan_group='239.1.1.1',
     |                  vxlan_ttl=16)
     |      
     |      All possible vxlan parameters are listed in the module
     |      `pyroute2.netlink.rtnl.ifinfmsg:... vxlan_data`.
     |      
     |      ► ipoib
     |      
     |      IPoIB driver provides an ability to create several ip interfaces
     |      on one interface.
     |      IPoIB interfaces requires the following parameter:
     |      
     |      `link` : The master interface to create IPoIB on.
     |      
     |      The following parameters can also be provided:
     |      
     |      * `pkey`- Inifiniband partition key the ip interface is associated with
     |      * `mode`- Underlying infiniband transport mode. One
     |        of:  ['datagram' ,'connected']
     |      * `umcast`- If set(1), multicast group membership for this interface is
     |        handled by user space.
     |      
     |      Example::
     |      
     |          ip.link("add",
     |                  ifname="ipoib1",
     |                  kind="ipoib",
     |                  link=ip.link_lookup(ifname="ib0")[0],
     |                  pkey=10)
     |      
     |      **set**
     |      
     |      Set interface attributes::
     |      
     |          # get interface index
     |          x = ip.link_lookup(ifname="eth0")[0]
     |          # put link down
     |          ip.link("set", index=x, state="down")
     |          # rename and set MAC addr
     |          ip.link("set", index=x, address="00:11:22:33:44:55", name="bala")
     |          # set MTU and TX queue length
     |          ip.link("set", index=x, mtu=1000, txqlen=2000)
     |          # bring link up
     |          ip.link("set", index=x, state="up")
     |      
     |      Seting bridge or tunnel attributes require `kind` to be
     |      specified in order to properly encode `IFLA_LINKINFO`::
     |      
     |          ip.link("set",
     |                  index=x,
     |                  kind="bridge",
     |                  br_forward_delay=2000)
     |      
     |          ip.link("set",
     |                  index=x,
     |                  kind="gre",
     |                  gre_local="10.0.0.1",
     |                  gre_remote="10.1.0.103")
     |      
     |      Keyword "state" is reserved. State can be "up" or "down",
     |      it is a shortcut::
     |      
     |          state="up":   flags=1, mask=1
     |          state="down": flags=0, mask=0
     |      
     |      SR-IOV virtual function setup::
     |      
     |          # get PF index
     |          x = ip.link_lookup(ifname="eth0")[0]
     |          # setup macaddr
     |          ip.link("set",
     |                  index=x,                          # PF index
     |                  vf={"vf": 0,                      # VF index
     |                      "mac": "00:11:22:33:44:55"})  # address
     |          # setup vlan
     |          ip.link("set",
     |                  index=x,           # PF index
     |                  vf={"vf": 0,       # VF index
     |                      "vlan": 100})  # the simplest case
     |          # setup QinQ
     |          ip.link("set",
     |                  index=x,                           # PF index
     |                  vf={"vf": 0,                       # VF index
     |                      "vlan": [{"vlan": 100,         # vlan id
     |                                "proto": 0x88a8},    # 802.1ad
     |                               {"vlan": 200,         # vlan id
     |                                "proto": 0x8100}]})  # 802.1q
     |      
     |      **update**
     |      
     |      Almost the same as `set`, except it uses different flags
     |      and message type. Mostly does the same, but in some cases
     |      differs. If you're not sure what to use, use `set`.
     |      
     |      **del**
     |      
     |      Destroy the interface::
     |      
     |          ip.link("del", index=ip.link_lookup(ifname="dummy0")[0])
     |      
     |      **dump**
     |      
     |      Dump info for all interfaces
     |      
     |      **get**
     |      
     |      Get specific interface info::
     |      
     |          ip.link("get", index=ip.link_lookup(ifname="br0")[0])
     |      
     |      Get extended attributes like SR-IOV setup::
     |      
     |          ip.link("get", index=3, ext_mask=1)
     |  
     |  link_lookup(self, match=None, **kwarg)
     |      Lookup interface index (indeces) by first level NLA
     |      value.
     |      
     |      Example::
     |      
     |          ip.link_lookup(address="52:54:00:9d:4e:3d")
     |          ip.link_lookup(ifname="lo")
     |          ip.link_lookup(operstate="UP")
     |      
     |      Please note, that link_lookup() returns list, not one
     |      value.
     |  
     |  list_link_kind(self)
     |  
     |  neigh(self, command, **kwarg)
     |      Neighbours operations, same as `ip neigh` or `bridge fdb`
     |      
     |      **add**
     |      
     |      Add a neighbour record, e.g.::
     |      
     |          from pyroute2 import IPRoute
     |          from pyroute2.netlink.rtnl import ndmsg
     |      
     |          # add a permanent record on veth0
     |          idx = ip.link_lookup(ifname='veth0')[0]
     |          ip.neigh('add',
     |                   dst='172.16.45.1',
     |                   lladdr='00:11:22:33:44:55',
     |                   ifindex=idx,
     |                   state=ndmsg.states['permanent'])
     |      
     |      **set**
     |      
     |      Set an existing record or create a new one, if it doesn't exist.
     |      The same as above, but the command is "set"::
     |      
     |          ip.neigh('set',
     |                   dst='172.16.45.1',
     |                   lladdr='00:11:22:33:44:55',
     |                   ifindex=idx,
     |                   state=ndmsg.states['permanent'])
     |      
     |      
     |      **change**
     |      
     |      Change an existing record. If the record doesn't exist, fail.
     |      
     |      **del**
     |      
     |      Delete an existing record.
     |      
     |      **dump**
     |      
     |      Dump all the records in the NDB::
     |      
     |          ip.neigh('dump')
     |      
     |      **get**
     |      
     |      Get specific record (dst and ifindex are mandatory). Available
     |      only on recent kernel::
     |      
     |          ip.neigh('get',
     |                   dst='172.16.45.1',
     |                   ifindex=idx)
     |  
     |  poll(self, method, command, timeout=10, interval=0.2, **spec)
     |      Run `method` with a positional argument `command` and keyword
     |      arguments `**spec` every `interval` seconds, but not more than
     |      `timeout`, until it returns a result which doesn't evaluate to
     |      `False`.
     |      
     |      Example:
     |      
     |      .. code-block:: python
     |      
     |          # create a bridge interface and wait for it:
     |          #
     |          spec = {
     |              'ifname': 'br0',
     |              'kind': 'bridge',
     |              'state': 'up',
     |              'br_stp_state': 1,
     |          }
     |          ipr.link('add', **spec)
     |          ret = ipr.poll(ipr.link, 'dump', **spec)
     |      
     |          assert ret[0].get('ifname') == 'br0'
     |          assert ret[0].get('state') == 'up'
     |          assert ret[0].get(('linkinfo', 'data', 'br_stp_state')) == 1
     |  
     |  register_link_kind(self, path=None, pkg=None, module=None)
     |  
     |  route(self, command, **kwarg)
     |      Route operations.
     |      
     |      Keywords to set up rtmsg fields:
     |      
     |      * dst_len, src_len -- destination and source mask(see `dst` below)
     |      * tos -- type of service
     |      * table -- routing table
     |      * proto -- `redirect`, `boot`, `static` (see `rt_proto`)
     |      * scope -- routing realm
     |      * type -- `unicast`, `local`, etc. (see `rt_type`)
     |      
     |      `pyroute2/netlink/rtnl/rtmsg.py` rtmsg.nla_map:
     |      
     |      * table -- routing table to use (default: 254)
     |      * gateway -- via address
     |      * prefsrc -- preferred source IP address
     |      * dst -- the same as `prefix`
     |      * iif -- incoming traffic interface
     |      * oif -- outgoing traffic interface
     |      
     |      etc.
     |      
     |      One can specify mask not as `dst_len`, but as a part of `dst`,
     |      e.g.: `dst="10.0.0.0/24"`.
     |      
     |      Commands:
     |      
     |      **add**
     |      
     |      Example::
     |      
     |          ipr.route("add", dst="10.0.0.0/24", gateway="192.168.0.1")
     |      
     |      ...
     |      
     |      More `route()` examples. Blackhole route::
     |      
     |          ipr.route(
     |              "add",
     |              dst="10.0.0.0/24",
     |              type="blackhole",
     |          )
     |      
     |      Create a route with metrics::
     |      
     |          ipr.route(
     |              "add",
     |              dst="172.16.0.0/24",
     |              gateway="10.0.0.10",
     |              metrics={
     |                  "mtu": 1400,
     |                  "hoplimit": 16,
     |              },
     |          )
     |      
     |      Multipath route::
     |      
     |          ipr.route(
     |              "add",
     |              dst="10.0.0.0/24",
     |              multipath=[
     |                  {"gateway": "192.168.0.1", "hops": 2},
     |                  {"gateway": "192.168.0.2", "hops": 1},
     |                  {"gateway": "192.168.0.3"},
     |              ],
     |          )
     |      
     |      MPLS lwtunnel on eth0::
     |      
     |          ipr.route(
     |              "add",
     |              dst="10.0.0.0/24",
     |              oif=ip.link_lookup(ifname="eth0"),
     |              encap={
     |                  "type": "mpls",
     |                  "labels": "200/300",
     |              },
     |          )
     |      
     |      IPv6 next hop for IPv4 dst::
     |      
     |          ipr.route(
     |              "add",
     |              prefsrc="10.127.30.4",
     |              dst="172.16.0.0/24",
     |              via={"family": AF_INET6, "addr": "fe80::1337"},
     |              oif=ipr.link_lookup(ifname="eth0"),
     |              table=100,
     |          )
     |      
     |      Create MPLS route: push label::
     |      
     |          # $ sudo modprobe mpls_router
     |          # $ sudo sysctl net.mpls.platform_labels=1024
     |          ipr.route(
     |              "add",
     |              family=AF_MPLS,
     |              oif=ipr.link_lookup(ifname="eth0"),
     |              dst=0x200,
     |              newdst=[0x200, 0x300],
     |          )
     |      
     |      MPLS multipath::
     |      
     |          ipr.route(
     |              "add",
     |              dst="10.0.0.0/24",
     |              table=20,
     |              multipath=[
     |                  {
     |                      "gateway": "192.168.0.1",
     |                      "encap": {"type": "mpls", "labels": 200},
     |                  },
     |                  {
     |                      "ifindex": ipr.link_lookup(ifname="eth0"),
     |                      "encap": {"type": "mpls", "labels": 300},
     |                  },
     |              ],
     |          )
     |      
     |      MPLS target can be int, string, dict or list::
     |      
     |          "labels": 300    # simple label
     |          "labels": "300"  # the same
     |          "labels": (200, 300)  # stacked
     |          "labels": "200/300"   # the same
     |      
     |          # explicit label definition
     |          "labels": {
     |              "bos": 1,
     |              "label": 300,
     |              "tc": 0,
     |              "ttl": 16,
     |          }
     |      
     |      Create SEG6 tunnel encap mode (kernel >= 4.10)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6",
     |                  "mode": "encap",
     |                  "segs": "2000::5,2000::6",
     |              },
     |          )
     |      
     |      Create SEG6 tunnel inline mode (kernel >= 4.10)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6",
     |                  "mode": "inline",
     |                  "segs": ["2000::5", "2000::6"],
     |              },
     |          )
     |      
     |      Create SEG6 tunnel inline mode with hmac (kernel >= 4.10)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:22::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6",
     |                  "mode": "inline",
     |                  "segs": "2000::5,2000::6,2000::7,2000::8",
     |                  "hmac": 0xf,
     |              },
     |          )
     |      
     |      Create SEG6 tunnel with ip4ip6 encapsulation (kernel >= 4.14)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="172.16.0.0/24",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6",
     |                  "mode": "encap",
     |                  "segs": "2000::5,2000::6",
     |              },
     |          )
     |      
     |      Create SEG6LOCAL tunnel End.DX4 action (kernel >= 4.14)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6local",
     |                  "action": "End.DX4",
     |                  "nh4": "172.16.0.10",
     |              },
     |          )
     |      
     |      Create SEG6LOCAL tunnel End.DT6 action (kernel >= 4.14)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6local",
     |                  "action": "End.DT6",
     |                  "table": "10",
     |              },
     |          )
     |      
     |      Create SEG6LOCAL tunnel End.DT4 action (kernel >= 5.11)::
     |      
     |          # $ sudo modprobe vrf
     |          # $ sudo sysctl -w net.vrf.strict_mode=1
     |          ipr.link(
     |              "add",
     |              ifname="vrf-foo",
     |              kind="vrf",
     |              vrf_table=10,
     |          )
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6local",
     |                  "action": "End.DT4",
     |                  "vrf_table": 10,
     |              },
     |          )
     |      
     |      Create SEG6LOCAL tunnel End.B6 action (kernel >= 4.14)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6local",
     |                  "action": "End.B6",
     |                  "srh": {"segs": "2000::5,2000::6"},
     |              },
     |          )
     |      
     |      Create SEG6LOCAL tunnel End.B6 action with hmac (kernel >= 4.14)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6local",
     |                  "action": "End.B6",
     |                  "srh": {
     |                      "segs": "2000::5,2000::6",
     |                      "hmac": 0xf,
     |                  },
     |              },
     |          )
     |      
     |      **change**, **replace**, **append**
     |      
     |      Commands `change`, `replace` and `append` have the same meanings
     |      as in ip-route(8): `change` modifies only existing route, while
     |      `replace` creates a new one, if there is no such route yet.
     |      `append` allows to create an IPv6 multipath route.
     |      
     |      **del**
     |      
     |      Remove the route. The same syntax as for **add**.
     |      
     |      **get**
     |      
     |      Get route by spec.
     |      
     |      **dump**
     |      
     |      Dump all routes.
     |  
     |  rule(self, command, **kwarg)
     |      Rule operations
     |      
     |          - command — add, delete
     |          - table — 0 < table id < 253
     |          - priority — 0 < rule's priority < 32766
     |          - action — type of rule, default 'FR_ACT_NOP' (see fibmsg.py)
     |          - rtscope — routing scope, default RT_SCOPE_UNIVERSE
     |              `(RT_SCOPE_UNIVERSE|RT_SCOPE_SITE|                RT_SCOPE_LINK|RT_SCOPE_HOST|RT_SCOPE_NOWHERE)`
     |          - family — rule's family (socket.AF_INET (default) or
     |              socket.AF_INET6)
     |          - src — IP source for Source Based (Policy Based) routing's rule
     |          - dst — IP for Destination Based (Policy Based) routing's rule
     |          - src_len — Mask for Source Based (Policy Based) routing's rule
     |          - dst_len — Mask for Destination Based (Policy Based) routing's
     |              rule
     |          - iifname — Input interface for Interface Based (Policy Based)
     |              routing's rule
     |          - oifname — Output interface for Interface Based (Policy Based)
     |              routing's rule
     |          - uid_range — Range of user identifiers, a string like "1000:1234"
     |          - dport_range — Range of destination ports, a string like "80-120"
     |          - sport_range — Range of source ports, as a string like "80-120"
     |      
     |      All packets route via table 10::
     |      
     |          # 32000: from all lookup 10
     |          # ...
     |          ip.rule('add', table=10, priority=32000)
     |      
     |      Default action::
     |      
     |          # 32001: from all lookup 11 unreachable
     |          # ...
     |          iproute.rule('add',
     |                       table=11,
     |                       priority=32001,
     |                       action='FR_ACT_UNREACHABLE')
     |      
     |      Use source address to choose a routing table::
     |      
     |          # 32004: from 10.64.75.141 lookup 14
     |          # ...
     |          iproute.rule('add',
     |                       table=14,
     |                       priority=32004,
     |                       src='10.64.75.141')
     |      
     |      Use dst address to choose a routing table::
     |      
     |          # 32005: from 10.64.75.141/24 lookup 15
     |          # ...
     |          iproute.rule('add',
     |                       table=15,
     |                       priority=32005,
     |                       dst='10.64.75.141',
     |                       dst_len=24)
     |      
     |      Match fwmark::
     |      
     |          # 32006: from 10.64.75.141 fwmark 0xa lookup 15
     |          # ...
     |          iproute.rule('add',
     |                       table=15,
     |                       priority=32006,
     |                       dst='10.64.75.141',
     |                       fwmark=10)
     |  
     |  stats(self, command, **kwarg)
     |      Stats prototype.
     |  
     |  tc(self, command, kind=None, index=0, handle=0, **kwarg)
     |      "Swiss knife" for traffic control. With the method you can
     |      add, delete or modify qdiscs, classes and filters.
     |      
     |      * command -- add or delete qdisc, class, filter.
     |      * kind -- a string identifier -- "sfq", "htb", "u32" and so on.
     |      * handle -- integer or string
     |      
     |      Command can be one of ("add", "del", "add-class", "del-class",
     |      "add-filter", "del-filter") (see `commands` dict in the code).
     |      
     |      Handle notice: traditional iproute2 notation, like "1:0", actually
     |      represents two parts in one four-bytes integer::
     |      
     |          1:0    ->    0x10000
     |          1:1    ->    0x10001
     |          ff:0   ->   0xff0000
     |          ffff:1 -> 0xffff0001
     |      
     |      Target notice: if your target is a class/qdisc that applies an
     |      algorithm that can only apply to upstream traffic profile, but your
     |      keys variable explicitly references a match that is only relevant for
     |      upstream traffic, the kernel will reject the filter.  Unless you're
     |      dealing with devices like IMQs
     |      
     |      For pyroute2 tc() you can use both forms: integer like 0xffff0000
     |      or string like 'ffff:0000'. By default, handle is 0, so you can add
     |      simple classless queues w/o need to specify handle. Ingress queue
     |      causes handle to be 0xffff0000.
     |      
     |      So, to set up sfq queue on interface 1, the function call
     |      will be like that::
     |      
     |          ip = IPRoute()
     |          ip.tc("add", "sfq", 1)
     |      
     |      Instead of string commands ("add", "del"...), you can use also
     |      module constants, `RTM_NEWQDISC`, `RTM_DELQDISC` and so on::
     |      
     |          ip = IPRoute()
     |          flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_CREATE | NLM_F_EXCL
     |          ip.tc((RTM_NEWQDISC, flags), "sfq", 1)
     |      
     |      It should be noted that "change", "change-class" and
     |      "change-filter" work like "replace", "replace-class" and
     |      "replace-filter", except they will fail if the node doesn't
     |      exist (while it would have been created by "replace"). This is
     |      not the same behaviour as with "tc" where "change" can be used
     |      to modify the value of some options while leaving the others
     |      unchanged. However, as not all entities support this
     |      operation, we believe the "change" commands as implemented
     |      here are more useful.
     |      
     |      
     |      Also available "modules" (returns tc plugins dict) and "help"
     |      commands::
     |      
     |          help(ip.tc("modules")["htb"])
     |          print(ip.tc("help", "htb"))
     |  
     |  unregister_link_kind(self, kind)
     |  
     |  vlan_filter(self, command, **kwarg)
     |      Vlan filters is another approach to support vlans in Linux.
     |      Before vlan filters were introduced, there was only one way
     |      to bridge vlans: one had to create vlan interfaces and
     |      then add them as ports::
     |      
     |                  +------+      +----------+
     |          net --> | eth0 | <--> | eth0.500 | <---+
     |                  +------+      +----------+     |
     |                                                 v
     |                  +------+                    +-----+
     |          net --> | eth1 |                    | br0 |
     |                  +------+                    +-----+
     |                                                 ^
     |                  +------+      +----------+     |
     |          net --> | eth2 | <--> | eth2.500 | <---+
     |                  +------+      +----------+
     |      
     |      It means that one has to create as many bridges, as there were
     |      vlans. Vlan filters allow to bridge together underlying interfaces
     |      and create vlans already on the bridge::
     |      
     |          # v500 label shows which interfaces have vlan filter
     |      
     |                  +------+ v500
     |          net --> | eth0 | <-------+
     |                  +------+         |
     |                                   v
     |                  +------+      +-----+    +---------+
     |          net --> | eth1 | <--> | br0 |<-->| br0v500 |
     |                  +------+      +-----+    +---------+
     |                                   ^
     |                  +------+ v500    |
     |          net --> | eth2 | <-------+
     |                  +------+
     |      
     |      In this example vlan 500 will be allowed only on ports `eth0` and
     |      `eth2`, though all three eth nics are bridged.
     |      
     |      Some example code::
     |      
     |          # create bridge
     |          ip.link("add",
     |                  ifname="br0",
     |                  kind="bridge")
     |      
     |          # attach a port
     |          ip.link("set",
     |                  index=ip.link_lookup(ifname="eth0")[0],
     |                  master=ip.link_lookup(ifname="br0")[0])
     |      
     |          # set vlan filter
     |          ip.vlan_filter("add",
     |                         index=ip.link_lookup(ifname="eth0")[0],
     |                         vlan_info={"vid": 500})
     |      
     |          # create vlan interface on the bridge
     |          ip.link("add",
     |                  ifname="br0v500",
     |                  kind="vlan",
     |                  link=ip.link_lookup(ifname="br0")[0],
     |                  vlan_id=500)
     |      
     |          # set all UP
     |          ip.link("set",
     |                  index=ip.link_lookup(ifname="br0")[0],
     |                  state="up")
     |          ip.link("set",
     |                  index=ip.link_lookup(ifname="br0v500")[0],
     |                  state="up")
     |          ip.link("set",
     |                  index=ip.link_lookup(ifname="eth0")[0],
     |                  state="up")
     |      
     |          # set IP address
     |          ip.addr("add",
     |                  index=ip.link_lookup(ifname="br0v500")[0],
     |                  address="172.16.5.2",
     |                  mask=24)
     |      
     |          Now all the traffic to the network 172.16.5.2/24 will go
     |          to vlan 500 only via ports that have such vlan filter.
     |      
     |      
     |      Required arguments for `vlan_filter()` -- `index` and `vlan_info`.
     |      Vlan info struct::
     |      
     |          {"vid": uint16,
     |           "flags": uint16}
     |      
     |      More details:
     |          * kernel:Documentation/networking/switchdev.txt
     |          * pyroute2.netlink.rtnl.ifinfmsg:... vlan_info
     |      
     |      One can specify `flags` as int or as a list of flag names:
     |          * `master` == 0x1
     |          * `pvid` == 0x2
     |          * `untagged` == 0x4
     |          * `range_begin` == 0x8
     |          * `range_end` == 0x10
     |          * `brentry` == 0x20
     |      
     |      E.g.::
     |      
     |          {"vid": 20,
     |           "flags": ["pvid", "untagged"]}
     |      
     |          # is equal to
     |          {"vid": 20,
     |           "flags": 6}
     |      
     |      Commands:
     |      
     |      **add**
     |      
     |      Add vlan filter to a bridge port. Example::
     |      
     |          ip.vlan_filter("add", index=2, vlan_info={"vid": 200})
     |      
     |      **del**
     |      
     |      Remove vlan filter from a bridge port. Example::
     |      
     |          ip.vlan_filter("del", index=2, vlan_info={"vid": 200})
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from RTNL_API:
     |  
     |  close_file(fd)
     |      Close a file that was previously opened with open_file().
     |  
     |  get_pid()
     |      Return the PID of the current process.
     |  
     |  open_file(path)
     |      Open a file (read only) and return its (fd, inode).
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from RTNL_API:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.rtnl.iprsocket.IPRSocketBase:
     |  
     |  bind(self, groups=None, **kwarg)
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.ChaoticNetlinkSocket:
     |  
     |  get(self, *argv, **kwarg)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.ChaoticNetlinkSocket:
     |  
     |  success_rate = 1
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocket:
     |  
     |  __getattr__(self, attr)
     |  
     |  add_membership(self, group)
     |  
     |  close(self, code=104)
     |      Correctly close the socket and free all resources.
     |  
     |  drop_membership(self, group)
     |  
     |  post_init(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  buffer_thread_routine(self)
     |  
     |  clone(self)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request(self, msg, msg_type, msg_flags=769, terminate=None, callback=None, parser=None)
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  recv(self, *argv, **kwarg)
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
    
    class CommitException(builtins.Exception)
     |  Common base class for all non-exit exceptions.
     |  
     |  Method resolution order:
     |      CommitException
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class Conntrack(pyroute2.netlink.nfnetlink.nfctsocket.NFCTSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  Conntrack(nlm_generator=True, **kwargs)
     |  
     |  High level conntrack functions
     |  
     |  Method resolution order:
     |      Conntrack
     |      pyroute2.netlink.nfnetlink.nfctsocket.NFCTSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, nlm_generator=True, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  conntrack_max_size(self)
     |      Return the max size of connection tracking table
     |      /proc/sys/net/netfilter/nf_conntrack_max
     |  
     |  count(self)
     |      Return current number of conntrack entries
     |      
     |      Same result than /proc/sys/net/netfilter/nf_conntrack_count file
     |      or conntrack -C command
     |  
     |  delete(self, entry)
     |  
     |  dump_entries(self, mark=None, mark_mask=4294967295, tuple_orig=None, tuple_reply=None)
     |      Dump all entries from conntrack table with filters
     |      
     |      Filters can be only part of a conntrack tuple
     |      
     |      :param NFCTAttrTuple tuple_orig: filter on original tuple
     |      :param NFCTAttrTuple tuple_reply: filter on reply tuple
     |      
     |      Examples::
     |          # Filter only on tcp connections
     |          for entry in ct.dump_entries(tuple_orig=NFCTAttrTuple(
     |                                           proto=socket.IPPROTO_TCP)):
     |              print("This entry is tcp: {}".format(entry))
     |      
     |          # Filter only on icmp message to 8.8.8.8
     |          for entry in ct.dump_entries(tuple_orig=NFCTAttrTuple(
     |                                           proto=socket.IPPROTO_ICMP,
     |                                           daddr='8.8.8.8')):
     |              print("This entry is icmp to 8.8.8.8: {}".format(entry))
     |  
     |  entry(self, cmd, **kwargs)
     |      Get or change a conntrack entry.
     |      
     |      Examples::
     |          # add an entry
     |          ct.entry('add', timeout=30,
     |                   tuple_orig=NFCTAttrTuple(
     |                       saddr='192.168.122.1', daddr='192.168.122.67',
     |                       proto=6, sport=34857, dport=5599),
     |                   tuple_reply=NFCTAttrTuple(
     |                       saddr='192.168.122.67', daddr='192.168.122.1',
     |                       proto=6, sport=5599, dport=34857))
     |      
     |          # set mark=5 on the matching entry
     |          ct.entry('set', mark=5,
     |                   tuple_orig=NFCTAttrTuple(
     |                       saddr='192.168.122.1', daddr='192.168.122.67',
     |                       proto=6, sport=34857, dport=5599))
     |      
     |          # get an entry
     |          ct.entry('get',
     |                   tuple_orig=NFCTAttrTuple(
     |                       saddr='192.168.122.1', daddr='192.168.122.67',
     |                       proto=6, sport=34857, dport=5599))
     |      
     |          # delete an entry
     |          ct.entry('del',
     |                   tuple_orig=NFCTAttrTuple(
     |                       saddr='192.168.122.1', daddr='192.168.122.67',
     |                       proto=6, sport=34857, dport=5599))
     |  
     |  stat(self)
     |      Return current statistics per CPU
     |      
     |      Same result than conntrack -S command but a list of dictionaries
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nfnetlink.nfctsocket.NFCTSocket:
     |  
     |  dump(self, mark=None, mark_mask=4294967295, tuple_orig=None, tuple_reply=None)
     |      Dump conntrack entries
     |      
     |      Several kernel side filtering are supported:
     |        * mark and mark_mask, for almost all kernel
     |        * tuple_orig and tuple_reply, since kernel 5.8 and newer.
     |          Warning: tuple_reply has a bug in kernel, fixed only recently.
     |      
     |      tuple_orig and tuple_reply are type NFCTAttrTuple.
     |      You can give only some attribute for filtering.
     |      
     |      Example::
     |          # Get only connections from 192.168.1.1
     |          filter = NFCTAttrTuple(saddr='192.168.1.1')
     |          ct.dump_entries(tuple_orig=filter)
     |      
     |          # Get HTTPS connections
     |          filter = NFCTAttrTuple(proto=socket.IPPROTO_TCP, dport=443)
     |          ct.dump_entries(tuple_orig=filter)
     |      
     |      Note that NFCTAttrTuple attributes are working like one AND operator.
     |      
     |      Example::
     |         # Get connections from 192.168.1.1 AND on port 443
     |         TCP = socket.IPPROTO_TCP
     |         filter = NFCTAttrTuple(saddr='192.168.1.1', proto=TCP, dport=443)
     |         ct.dump_entries(tuple_orig=filter)
     |  
     |  flush(self, mark=None, mark_mask=None)
     |  
     |  request(self, msg, msg_type, **kwargs)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nfnetlink.nfctsocket.NFCTSocket:
     |  
     |  policy = {256: <class 'pyroute2.netlink.nfnetlink.nfctsocket.nfct_msg'...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocket:
     |  
     |  __getattr__(self, attr)
     |  
     |  add_membership(self, group)
     |  
     |  bind(self, groups=0, pid=None, **kwarg)
     |      Bind the socket to given multicast groups, using
     |      given pid.
     |      
     |          - If pid is None, use automatic port allocation
     |          - If pid == 0, use process' pid
     |          - If pid == <int>, use the value instead of pid
     |  
     |  close(self, code=104)
     |      Correctly close the socket and free all resources.
     |  
     |  drop_membership(self, group)
     |  
     |  post_init(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  buffer_thread_routine(self)
     |  
     |  clone(self)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request(self, msg, msg_type, msg_flags=769, terminate=None, callback=None, parser=None)
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  recv(self, *argv, **kwarg)
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  get(self, bufsize=65536, msg_seq=0, terminate=None, callback=None, noraise=False)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class ConntrackEntry(builtins.object)
     |  ConntrackEntry(family, tuple_orig, tuple_reply, cta_status, cta_timeout, cta_protoinfo, cta_mark, cta_id, cta_use)
     |  
     |  Methods defined here:
     |  
     |  __init__(self, family, tuple_orig, tuple_reply, cta_status, cta_timeout, cta_protoinfo, cta_mark, cta_id, cta_use)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  status_name(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  id
     |  
     |  mark
     |  
     |  protoinfo
     |  
     |  status
     |  
     |  timeout
     |  
     |  tuple_orig
     |  
     |  tuple_reply
     |  
     |  use
    
    class Console(code.InteractiveConsole)
     |  Console(stdout=None, log=None, sources=None)
     |  
     |  Closely emulate the behavior of the interactive Python interpreter.
     |  
     |  This class builds on InteractiveInterpreter and adds prompting
     |  using the familiar sys.ps1 and sys.ps2, and input buffering.
     |  
     |  Method resolution order:
     |      Console
     |      code.InteractiveConsole
     |      code.InteractiveInterpreter
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, stdout=None, log=None, sources=None)
     |      Constructor.
     |      
     |      The optional locals argument will be passed to the
     |      InteractiveInterpreter base class.
     |      
     |      The optional filename argument should specify the (file)name
     |      of the input stream; it will show up in tracebacks.
     |  
     |  close(self)
     |  
     |  completer(self, text, state)
     |  
     |  display(self, line, matches, length)
     |  
     |  help(self)
     |  
     |  interact(self, readfunc=None)
     |      Closely emulate the interactive Python console.
     |      
     |      The optional banner argument specifies the banner to print
     |      before the first interaction; by default it prints a banner
     |      similar to the one printed by the real Python interpreter,
     |      followed by the current class name in parentheses (so as not
     |      to confuse this with the real interpreter -- since it's so
     |      close!).
     |      
     |      The optional exitmsg argument specifies the exit message
     |      printed when exiting. Pass the empty string to suppress
     |      printing an exit message. If exitmsg is not given or None,
     |      a default message is printed.
     |  
     |  loadrc(self, fname)
     |  
     |  set_prompt(self, prompt=None)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from code.InteractiveConsole:
     |  
     |  push(self, line)
     |      Push a line to the interpreter.
     |      
     |      The line should not have a trailing newline; it may have
     |      internal newlines.  The line is appended to a buffer and the
     |      interpreter's runsource() method is called with the
     |      concatenated contents of the buffer as source.  If this
     |      indicates that the command was executed or invalid, the buffer
     |      is reset; otherwise, the command is incomplete, and the buffer
     |      is left as it was after the line was appended.  The return
     |      value is 1 if more input is required, 0 if the line was dealt
     |      with in some way (this is the same as runsource()).
     |  
     |  raw_input(self, prompt='')
     |      Write a prompt and read a line.
     |      
     |      The returned line does not include the trailing newline.
     |      When the user enters the EOF key sequence, EOFError is raised.
     |      
     |      The base implementation uses the built-in function
     |      input(); a subclass may replace this with a different
     |      implementation.
     |  
     |  resetbuffer(self)
     |      Reset the input buffer.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from code.InteractiveInterpreter:
     |  
     |  runcode(self, code)
     |      Execute a code object.
     |      
     |      When an exception occurs, self.showtraceback() is called to
     |      display a traceback.  All exceptions are caught except
     |      SystemExit, which is reraised.
     |      
     |      A note about KeyboardInterrupt: this exception may occur
     |      elsewhere in this code, and may not always be caught.  The
     |      caller should be prepared to deal with it.
     |  
     |  runsource(self, source, filename='<input>', symbol='single')
     |      Compile and run some source in the interpreter.
     |      
     |      Arguments are as for compile_command().
     |      
     |      One of several things can happen:
     |      
     |      1) The input is incorrect; compile_command() raised an
     |      exception (SyntaxError or OverflowError).  A syntax traceback
     |      will be printed by calling the showsyntaxerror() method.
     |      
     |      2) The input is incomplete, and more input is required;
     |      compile_command() returned None.  Nothing happens.
     |      
     |      3) The input is complete; compile_command() returned a code
     |      object.  The code is executed by calling self.runcode() (which
     |      also handles run-time exceptions, except for SystemExit).
     |      
     |      The return value is True in case 2, False in the other cases (unless
     |      an exception is raised).  The return value can be used to
     |      decide whether to use sys.ps1 or sys.ps2 to prompt the next
     |      line.
     |  
     |  showsyntaxerror(self, filename=None)
     |      Display the syntax error that just occurred.
     |      
     |      This doesn't display a stack trace because there isn't one.
     |      
     |      If a filename is given, it is stuffed in the exception instead
     |      of what was there before (because Python's parser always uses
     |      "<string>" when reading from a string).
     |      
     |      The output is written by self.write(), below.
     |  
     |  showtraceback(self)
     |      Display the exception that just occurred.
     |      
     |      We remove the first stack item because it is our own code.
     |      
     |      The output is written by self.write(), below.
     |  
     |  write(self, data)
     |      Write a string.
     |      
     |      The base implementation writes to sys.stderr; a subclass may
     |      replace this with a different implementation.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from code.InteractiveInterpreter:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class CreateException(builtins.Exception)
     |  Common base class for all non-exit exceptions.
     |  
     |  Method resolution order:
     |      CreateException
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class DL(pyroute2.netlink.devlink.DevlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  DL(*argv, **kwarg)
     |  
     |  Low-level socket interface. Provides all the
     |  usual socket does, can be used in poll/select,
     |  doesn't create any implicit threads.
     |  
     |  Method resolution order:
     |      DL
     |      pyroute2.netlink.devlink.DevlinkSocket
     |      pyroute2.netlink.generic.GenericNetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, *argv, **kwarg)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  get_dump(self)
     |  
     |  get_port_dump(self)
     |  
     |  list(self)
     |  
     |  port_list(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.devlink.DevlinkSocket:
     |  
     |  bind(self, groups=0, **kwarg)
     |      Bind the socket and performs generic netlink
     |      proto lookup. The `proto` parameter is a string,
     |      like "TASKSTATS", `msg_class` is a class to
     |      parse messages with.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  add_membership(self, group)
     |  
     |  discovery(self, proto)
     |      Resolve generic netlink protocol -- takes a string
     |      as the only parameter, return protocol description
     |  
     |  drop_membership(self, group)
     |  
     |  get(self, *argv, **kwarg)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  nlm_request(self, *argv, **kwarg)
     |  
     |  policy(self, proto)
     |      Extract policy information for a generic netlink protocol -- takes
     |      a string as the only parameter, return protocol policy
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  prid
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  mcast_groups = {}
     |  
     |  module_err_level = 'error'
     |  
     |  module_err_message = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocket:
     |  
     |  __getattr__(self, attr)
     |  
     |  close(self, code=104)
     |      Correctly close the socket and free all resources.
     |  
     |  post_init(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  buffer_thread_routine(self)
     |  
     |  clone(self)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  recv(self, *argv, **kwarg)
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class DQuotSocket(pyroute2.netlink.event.EventSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  Low-level socket interface. Provides all the
     |  usual socket does, can be used in poll/select,
     |  doesn't create any implicit threads.
     |  
     |  Method resolution order:
     |      DQuotSocket
     |      pyroute2.netlink.event.EventSocket
     |      pyroute2.netlink.generic.GenericNetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  genl_family = 'VFS_DQUOT'
     |  
     |  marshal_class = <class 'pyroute2.netlink.event.dquot.MarshalDQuot'>
     |      Generic marshalling class
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.event.EventSocket:
     |  
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  bind(self, groups=0, **kwarg)
     |      Bind the socket and performs generic netlink
     |      proto lookup. The `proto` parameter is a string,
     |      like "TASKSTATS", `msg_class` is a class to
     |      parse messages with.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  add_membership(self, group)
     |  
     |  discovery(self, proto)
     |      Resolve generic netlink protocol -- takes a string
     |      as the only parameter, return protocol description
     |  
     |  drop_membership(self, group)
     |  
     |  get(self, *argv, **kwarg)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  nlm_request(self, *argv, **kwarg)
     |  
     |  policy(self, proto)
     |      Extract policy information for a generic netlink protocol -- takes
     |      a string as the only parameter, return protocol policy
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  prid
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  mcast_groups = {}
     |  
     |  module_err_level = 'error'
     |  
     |  module_err_message = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocket:
     |  
     |  __getattr__(self, attr)
     |  
     |  close(self, code=104)
     |      Correctly close the socket and free all resources.
     |  
     |  post_init(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  buffer_thread_routine(self)
     |  
     |  clone(self)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  recv(self, *argv, **kwarg)
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class DeprecationException(builtins.Exception)
     |  Common base class for all non-exit exceptions.
     |  
     |  Method resolution order:
     |      DeprecationException
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class DevlinkSocket(pyroute2.netlink.generic.GenericNetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  Low-level socket interface. Provides all the
     |  usual socket does, can be used in poll/select,
     |  doesn't create any implicit threads.
     |  
     |  Method resolution order:
     |      DevlinkSocket
     |      pyroute2.netlink.generic.GenericNetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  bind(self, groups=0, **kwarg)
     |      Bind the socket and performs generic netlink
     |      proto lookup. The `proto` parameter is a string,
     |      like "TASKSTATS", `msg_class` is a class to
     |      parse messages with.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  add_membership(self, group)
     |  
     |  discovery(self, proto)
     |      Resolve generic netlink protocol -- takes a string
     |      as the only parameter, return protocol description
     |  
     |  drop_membership(self, group)
     |  
     |  get(self, *argv, **kwarg)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  nlm_request(self, *argv, **kwarg)
     |  
     |  policy(self, proto)
     |      Extract policy information for a generic netlink protocol -- takes
     |      a string as the only parameter, return protocol policy
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  prid
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  mcast_groups = {}
     |  
     |  module_err_level = 'error'
     |  
     |  module_err_message = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocket:
     |  
     |  __getattr__(self, attr)
     |  
     |  close(self, code=104)
     |      Correctly close the socket and free all resources.
     |  
     |  post_init(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  buffer_thread_routine(self)
     |  
     |  clone(self)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  recv(self, *argv, **kwarg)
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class DiagSocket(pyroute2.netlink.nlsocket.NetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  DiagSocket(fileno=None)
     |  
     |  Usage::
     |  
     |      from pyroute2 import DiagSocket
     |      with DiagSocket() as ds:
     |          ds.bind()
     |          sstats = ds.get_sock_stats()
     |  
     |  Method resolution order:
     |      DiagSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, fileno=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  get_sock_stats(self, family=<AddressFamily.AF_UNIX: 1>, states=4095, protocol=6, extensions=0, show=15)
     |      Get sockets statistics.
     |      
     |      ACHTUNG: the get_sock_stats() signature will be changed
     |      before the next release, this one is a WIP-code!
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocket:
     |  
     |  __getattr__(self, attr)
     |  
     |  add_membership(self, group)
     |  
     |  bind(self, groups=0, pid=None, **kwarg)
     |      Bind the socket to given multicast groups, using
     |      given pid.
     |      
     |          - If pid is None, use automatic port allocation
     |          - If pid == 0, use process' pid
     |          - If pid == <int>, use the value instead of pid
     |  
     |  close(self, code=104)
     |      Correctly close the socket and free all resources.
     |  
     |  drop_membership(self, group)
     |  
     |  post_init(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  buffer_thread_routine(self)
     |  
     |  clone(self)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request(self, msg, msg_type, msg_flags=769, terminate=None, callback=None, parser=None)
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  recv(self, *argv, **kwarg)
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  get(self, bufsize=65536, msg_seq=0, terminate=None, callback=None, noraise=False)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Ethtool(builtins.object)
     |  Methods defined here:
     |  
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  close(self)
     |  
     |  get_coalesce(self, ifname)
     |  
     |  get_features(self, ifname)
     |  
     |  get_link_info(self, ifname, with_netlink=None)
     |  
     |  get_link_mode(self, ifname, with_netlink=None)
     |  
     |  get_strings_set(self, ifname, with_netlink=None)
     |  
     |  get_wol(self, ifname)
     |  
     |  set_coalesce(self, ifname, coalesce)
     |  
     |  set_features(self, ifname, features)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class GenericNetlinkSocket(pyroute2.netlink.nlsocket.NetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  GenericNetlinkSocket(family=16, port=None, pid=None, fileno=None, sndbuf=1048576, rcvbuf=1048576, all_ns=False, async_qsize=None, nlm_generator=None, target='localhost', ext_ack=False, strict_check=False, groups=0)
     |  
     |  Low-level socket interface. Provides all the
     |  usual socket does, can be used in poll/select,
     |  doesn't create any implicit threads.
     |  
     |  Method resolution order:
     |      GenericNetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  add_membership(self, group)
     |  
     |  bind(self, proto, msg_class, groups=0, pid=None, **kwarg)
     |      Bind the socket and performs generic netlink
     |      proto lookup. The `proto` parameter is a string,
     |      like "TASKSTATS", `msg_class` is a class to
     |      parse messages with.
     |  
     |  discovery(self, proto)
     |      Resolve generic netlink protocol -- takes a string
     |      as the only parameter, return protocol description
     |  
     |  drop_membership(self, group)
     |  
     |  get(self, *argv, **kwarg)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  nlm_request(self, *argv, **kwarg)
     |  
     |  policy(self, proto)
     |      Extract policy information for a generic netlink protocol -- takes
     |      a string as the only parameter, return protocol policy
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  prid
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  mcast_groups = {}
     |  
     |  module_err_level = 'error'
     |  
     |  module_err_message = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocket:
     |  
     |  __getattr__(self, attr)
     |  
     |  close(self, code=104)
     |      Correctly close the socket and free all resources.
     |  
     |  post_init(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  __init__(self, family=16, port=None, pid=None, fileno=None, sndbuf=1048576, rcvbuf=1048576, all_ns=False, async_qsize=None, nlm_generator=None, target='localhost', ext_ack=False, strict_check=False, groups=0)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  buffer_thread_routine(self)
     |  
     |  clone(self)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  recv(self, *argv, **kwarg)
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class IPBatch(RTNL_API, pyroute2.netlink.rtnl.iprsocket.IPBatchSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  IPBatch(*argv, **kwarg)
     |  
     |  Netlink requests compiler. Does not send any requests, but
     |  instead stores them in the internal binary buffer. The
     |  contents of the buffer can be used to send batch requests,
     |  to test custom netlink parsers and so on.
     |  
     |  Uses `RTNL_API` and provides all the same API as normal
     |  `IPRoute` objects::
     |  
     |      # create the batch compiler
     |      ipb = IPBatch()
     |      # compile requests into the internal buffer
     |      ipb.link("add", index=550, ifname="test", kind="dummy")
     |      ipb.link("set", index=550, state="up")
     |      ipb.addr("add", index=550, address="10.0.0.2", mask=24)
     |      # save the buffer
     |      data = ipb.batch
     |      # reset the buffer
     |      ipb.reset()
     |      ...
     |      # send the buffer
     |      IPRoute().sendto(data, (0, 0))
     |  
     |  Method resolution order:
     |      IPBatch
     |      RTNL_API
     |      pyroute2.netlink.rtnl.iprsocket.IPBatchSocket
     |      pyroute2.netlink.rtnl.iprsocket.IPRSocketBase
     |      pyroute2.netlink.nlsocket.BatchSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Methods inherited from RTNL_API:
     |  
     |  __init__(self, *argv, **kwarg)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  addr(self, command, *argv, **kwarg)
     |      Address operations
     |      
     |      * command -- add, delete, replace, dump
     |      * index -- device index
     |      * address -- IPv4 or IPv6 address
     |      * mask -- address mask
     |      * family -- socket.AF_INET for IPv4 or socket.AF_INET6 for IPv6
     |      * scope -- the address scope, see /etc/iproute2/rt_scopes
     |      * kwarg -- dictionary, any ifaddrmsg field or NLA
     |      
     |      Later the method signature will be changed to::
     |      
     |          def addr(self, command, match=None, **kwarg):
     |              # the method body
     |      
     |      So only keyword arguments (except of the command) will be accepted.
     |      The reason for this change is an unification of API.
     |      
     |      Example::
     |      
     |          idx = 62
     |          ip.addr('add', index=idx, address='10.0.0.1', mask=24)
     |          ip.addr('add', index=idx, address='10.0.0.2', mask=24)
     |      
     |      With more NLAs::
     |      
     |          # explicitly set broadcast address
     |          ip.addr('add', index=idx,
     |                  address='10.0.0.3',
     |                  broadcast='10.0.0.255',
     |                  prefixlen=24)
     |      
     |          # make the secondary address visible to ifconfig: add label
     |          ip.addr('add', index=idx,
     |                  address='10.0.0.4',
     |                  broadcast='10.0.0.255',
     |                  prefixlen=24,
     |                  label='eth0:1')
     |      
     |      Configure p2p address on an interface::
     |      
     |          ip.addr('add', index=idx,
     |                  address='10.1.1.2',
     |                  mask=24,
     |                  local='10.1.1.1')
     |  
     |  brport(self, command, **kwarg)
     |      Set bridge port parameters. Example::
     |      
     |          idx = ip.link_lookup(ifname='eth0')
     |          ip.brport("set", index=idx, unicast_flood=0, cost=200)
     |          ip.brport("show", index=idx)
     |      
     |      Possible keywords are NLA names for the `protinfo_bridge` class,
     |      without the prefix and in lower letters.
     |  
     |  dump(self, groups=None)
     |      Dump network objects.
     |      
     |      On OpenBSD:
     |      
     |      * get_links()
     |      * get_addr()
     |      * get_neighbours()
     |      * get_routes()
     |      
     |      On Linux:
     |      
     |      * get_links()
     |      * get_addr()
     |      * get_neighbours()
     |      * get_vlans()
     |      * dump FDB
     |      * IPv4 and IPv6 rules
     |  
     |  fdb(self, command, **kwarg)
     |      Bridge forwarding database management.
     |      
     |      More details:
     |          * kernel:Documentation/networking/switchdev.txt
     |          * pyroute2.netlink.rtnl.ndmsg
     |      
     |      **add**
     |      
     |      Add a new FDB record. Works in the same way as ARP cache
     |      management, but some additional NLAs can be used::
     |      
     |          # simple FDB record
     |          #
     |          ip.fdb('add',
     |                 ifindex=ip.link_lookup(ifname='br0')[0],
     |                 lladdr='00:11:22:33:44:55',
     |                 dst='10.0.0.1')
     |      
     |          # specify vlan
     |          # NB: vlan should exist on the device, use
     |          # `vlan_filter()`
     |          #
     |          ip.fdb('add',
     |                 ifindex=ip.link_lookup(ifname='br0')[0],
     |                 lladdr='00:11:22:33:44:55',
     |                 dst='10.0.0.1',
     |                 vlan=200)
     |      
     |          # specify vxlan id and port
     |          # NB: works only for vxlan devices, use
     |          # `link("add", kind="vxlan", ...)`
     |          #
     |          # if port is not specified, the default one is used
     |          # by the kernel.
     |          #
     |          # if vni (vxlan id) is equal to the device vni,
     |          # the kernel doesn't report it back
     |          #
     |          ip.fdb('add',
     |                 ifindex=ip.link_lookup(ifname='vx500')[0]
     |                 lladdr='00:11:22:33:44:55',
     |                 dst='10.0.0.1',
     |                 port=5678,
     |                 vni=600)
     |      
     |      **append**
     |      
     |      Append a new FDB record. The same syntax as for **add**.
     |      
     |      **del**
     |      
     |      Remove an existing FDB record. The same syntax as for **add**.
     |      
     |      **dump**
     |      
     |      Dump all the FDB records. If any `**kwarg` is provided,
     |      results will be filtered::
     |      
     |          # dump all the records
     |          ip.fdb('dump')
     |      
     |          # show only specific lladdr, dst, vlan etc.
     |          ip.fdb('dump', lladdr='00:11:22:33:44:55')
     |          ip.fdb('dump', dst='10.0.0.1')
     |          ip.fdb('dump', vlan=200)
     |  
     |  filter_messages(self, dump_filter, msgs)
     |      Filter messages using `dump_filter`. The filter might be a
     |      callable, then it will be called for every message in the list.
     |      Or it might be a dict, where keys are used to get values
     |      from messages, and dict values are used to match the message.
     |      
     |      The method might be called directly. It is also used by calls
     |      like `ipr.link('dump', ....)`, where keyword arguments work as
     |      `dump_filter` for `ipr.filter_messages()`.
     |      
     |      A callable `dump_filter` must return True or False:
     |      
     |      .. code-block:: python
     |      
     |          # get all links with names starting with eth:
     |          #
     |          ipr.filter_messages(
     |              lambda x: x.get_attr('IFLA_IFNAME').startswith('eth'),
     |              ipr.link('dump')
     |          )
     |      
     |      A dict `dump_filter` can have callables as values:
     |      
     |      .. code-block:: python
     |      
     |          # get all links with names starting with eth, and
     |          # MAC address in a database:
     |          #
     |          ipr.filter_messages(
     |              {
     |                  'ifname': lambda x: x.startswith('eth'),
     |                  'address': lambda x: x in database,
     |              },
     |              ipr.link('dump')
     |          )
     |      
     |      ... or constants to compare with:
     |      
     |      .. code-block:: python
     |      
     |          # get all links in state up:
     |          #
     |          ipr.filter_message({'state': 'up'}, ipr.link('dump'))
     |  
     |  flush_addr(self, *argv, **kwarg)
     |      Flush IP addresses.
     |      
     |      Examples::
     |      
     |          # flush all addresses on the interface with index 2:
     |          ipr.flush_addr(index=2)
     |      
     |          # flush all addresses with IFA_LABEL='eth0':
     |          ipr.flush_addr(label='eth0')
     |  
     |  flush_routes(self, *argv, **kwarg)
     |      Flush routes -- purge route records from a table.
     |      Arguments are the same as for `get_routes()`
     |      routine. Actually, this routine implements a pipe from
     |      `get_routes()` to `nlm_request()`.
     |  
     |  flush_rules(self, *argv, **kwarg)
     |      Flush rules. Please keep in mind, that by default the function
     |      operates on **all** rules of **all** families. To work only on
     |      IPv4 rules, one should explicitly specify `family=AF_INET`.
     |      
     |      Examples::
     |      
     |          # flush all IPv4 rule with priorities above 5 and below 32000
     |          ipr.flush_rules(family=AF_INET, priority=lambda x: 5 < x < 32000)
     |      
     |          # flush all IPv6 rules that point to table 250:
     |          ipr.flush_rules(family=socket.AF_INET6, table=250)
     |  
     |  get_addr(self, family=<AddressFamily.AF_UNSPEC: 0>, match=None, **kwarg)
     |      Dump addresses.
     |      
     |      If family is not specified, both AF_INET and AF_INET6 addresses
     |      will be dumped::
     |      
     |          # get all addresses
     |          ip.get_addr()
     |      
     |      It is possible to apply filters on the results::
     |      
     |          # get addresses for the 2nd interface
     |          ip.get_addr(index=2)
     |      
     |          # get addresses with IFA_LABEL == 'eth0'
     |          ip.get_addr(label='eth0')
     |      
     |          # get all the subnet addresses on the interface, identified
     |          # by broadcast address (should be explicitly specified upon
     |          # creation)
     |          ip.get_addr(index=2, broadcast='192.168.1.255')
     |      
     |      A custom predicate can be used as a filter::
     |      
     |          ip.get_addr(match=lambda x: x['index'] == 1)
     |  
     |  get_classes(self, index=0)
     |      Get classes for specified interface.
     |  
     |  get_default_routes(self, family=<AddressFamily.AF_UNSPEC: 0>, table=254)
     |      Get default routes
     |  
     |  get_filters(self, index=0, handle=0, parent=0)
     |      Get filters for specified interface, handle and parent.
     |  
     |  get_links(self, *argv, **kwarg)
     |      Get network interfaces.
     |      
     |      By default returns all interfaces. Arguments vector
     |      can contain interface indices or a special keyword
     |      'all'::
     |      
     |          ip.get_links()
     |          ip.get_links('all')
     |          ip.get_links(1, 2, 3)
     |      
     |          interfaces = [1, 2, 3]
     |          ip.get_links(*interfaces)
     |  
     |  get_neighbours(self, family=<AddressFamily.AF_UNSPEC: 0>, match=None, **kwarg)
     |      Dump ARP cache records.
     |      
     |      The `family` keyword sets the family for the request:
     |      e.g. `AF_INET` or `AF_INET6` for arp cache, `AF_BRIDGE`
     |      for fdb.
     |      
     |      If other keyword arguments not empty, they are used as
     |      filter. Also, one can explicitly set filter as a function
     |      with the `match` parameter.
     |      
     |      Examples::
     |      
     |          # get neighbours on the 3rd link:
     |          ip.get_neighbours(ifindex=3)
     |      
     |          # get a particular record by dst:
     |          ip.get_neighbours(dst='172.16.0.1')
     |      
     |          # get fdb records:
     |          ip.get_neighbours(AF_BRIDGE)
     |      
     |          # and filter them by a function:
     |          ip.get_neighbours(AF_BRIDGE, match=lambda x: x['state'] == 2)
     |  
     |  get_netns_info(self, list_proc=False)
     |      A prototype method to list available netns and associated
     |      interfaces. A bit weird to have it here and not under
     |      `pyroute2.netns`, but it uses RTNL to get all the info.
     |  
     |  get_netnsid(self, nsid=None, pid=None, fd=None, target_nsid=None)
     |      Return a dict containing the result of a RTM_GETNSID query.
     |      This loosely corresponds to the "ip netns list-id" command.
     |  
     |  get_ntables(self, family=<AddressFamily.AF_UNSPEC: 0>)
     |      Get neighbour tables
     |  
     |  get_qdiscs(self, index=None)
     |      Get all queue disciplines for all interfaces or for specified
     |      one.
     |  
     |  get_routes(self, family=255, match=None, **kwarg)
     |      Get all routes. You can specify the table. There
     |      are up to 4294967295 routing classes (tables), and the kernel
     |      returns all the routes on each request. So the
     |      routine filters routes from full output. Note the number of
     |      tables is increased from 255 in Linux 2.6+.
     |      
     |      Example::
     |      
     |          ip.get_routes()  # get all the routes for all families
     |          ip.get_routes(family=AF_INET6)  # get only IPv6 routes
     |          ip.get_routes(table=254)  # get routes from 254 table
     |      
     |      The default family=255 is a hack. Despite the specs,
     |      the kernel returns only IPv4 routes for AF_UNSPEC family.
     |      But it returns all the routes for all the families if one
     |      uses an invalid value here. Hack but true. And let's hope
     |      the kernel team will not fix this bug.
     |  
     |  get_rules(self, family=<AddressFamily.AF_UNSPEC: 0>, match=None, **kwarg)
     |      Get all rules. By default return all rules. To explicitly
     |      request the IPv4 rules use `family=AF_INET`.
     |      
     |      Example::
     |          ip.get_rules() # get all the rules for all families
     |          ip.get_rules(family=AF_INET6)  # get only IPv6 rules
     |  
     |  get_vlans(self, **kwarg)
     |      Dump available vlan info on bridge ports
     |  
     |  link(self, command, **kwarg)
     |      Link operations.
     |      
     |      Keywords to set up ifinfmsg fields:
     |          * index -- interface index
     |          * family -- AF_BRIDGE for bridge operations, otherwise 0
     |          * flags -- device flags
     |          * change -- change mask
     |      
     |      All other keywords will be translated to NLA names, e.g.
     |      `mtu -> IFLA_MTU`, `af_spec -> IFLA_AF_SPEC` etc. You can
     |      provide a complete NLA structure or let filters do it for
     |      you. E.g., these pairs show equal statements::
     |      
     |          # set device MTU
     |          ip.link("set", index=x, mtu=1000)
     |          ip.link("set", index=x, IFLA_MTU=1000)
     |      
     |          # add vlan device
     |          ip.link("add", ifname="test", kind="dummy")
     |          ip.link("add", ifname="test",
     |                  IFLA_LINKINFO={'attrs': [['IFLA_INFO_KIND', 'dummy']]})
     |      
     |      Filters are implemented in the `pyroute2.iproute.req` module.
     |      You can contribute your own if you miss shortcuts.
     |      
     |      Commands:
     |      
     |      **add**
     |      
     |      To create an interface, one should specify the interface kind::
     |      
     |          ip.link("add",
     |                  ifname="test",
     |                  kind="dummy")
     |      
     |      The kind can be any of those supported by kernel. It can be
     |      `dummy`, `bridge`, `bond` etc. On modern kernels one can specify
     |      even interface index::
     |      
     |          ip.link("add",
     |                  ifname="br-test",
     |                  kind="bridge",
     |                  index=2345)
     |      
     |      Specific type notes:
     |      
     |      ► geneve
     |      
     |      Create GENEVE tunnel::
     |      
     |          ip.link("add",
     |                  ifname="genx",
     |                  kind="geneve",
     |                  geneve_id=42,
     |                  geneve_remote="172.16.0.101")
     |      
     |      Support for GENEVE over IPv6 is also included; use `geneve_remote6`
     |      to configure a remote IPv6 address.
     |      
     |      ► gre
     |      
     |      Create GRE tunnel::
     |      
     |          ip.link("add",
     |                  ifname="grex",
     |                  kind="gre",
     |                  gre_local="172.16.0.1",
     |                  gre_remote="172.16.0.101",
     |                  gre_ttl=16)
     |      
     |      The keyed GRE requires explicit iflags/oflags specification::
     |      
     |          ip.link("add",
     |                  ifname="grex",
     |                  kind="gre",
     |                  gre_local="172.16.0.1",
     |                  gre_remote="172.16.0.101",
     |                  gre_ttl=16,
     |                  gre_ikey=10,
     |                  gre_okey=10,
     |                  gre_iflags=32,
     |                  gre_oflags=32)
     |      
     |      Support for GRE over IPv6 is also included; use `kind=ip6gre` and
     |      `ip6gre_` as the prefix for its values.
     |      
     |      ► ipip
     |      
     |      Create ipip tunnel::
     |      
     |          ip.link("add",
     |                  ifname="tun1",
     |                  kind="ipip",
     |                  ipip_local="172.16.0.1",
     |                  ipip_remote="172.16.0.101",
     |                  ipip_ttl=16)
     |      
     |      Support for sit and ip6tnl is also included; use `kind=sit` and `sit_`
     |      as prefix for sit tunnels, and `kind=ip6tnl` and `ip6tnl_` prefix for
     |      ip6tnl tunnels.
     |      
     |      ► macvlan
     |      
     |      Macvlan interfaces act like VLANs within OS. The macvlan driver
     |      provides an ability to add several MAC addresses on one interface,
     |      where every MAC address is reflected with a virtual interface in
     |      the system.
     |      
     |      In some setups macvlan interfaces can replace bridge interfaces,
     |      providing more simple and at the same time high-performance
     |      solution::
     |      
     |          ip.link("add",
     |                  ifname="mvlan0",
     |                  kind="macvlan",
     |                  link=ip.link_lookup(ifname="em1")[0],
     |                  macvlan_mode="private").commit()
     |      
     |      Several macvlan modes are available: "private", "vepa", "bridge",
     |      "passthru". Ususally the default is "vepa".
     |      
     |      ► macvtap
     |      
     |      Almost the same as macvlan, but creates also a character tap device::
     |      
     |          ip.link("add",
     |                  ifname="mvtap0",
     |                  kind="macvtap",
     |                  link=ip.link_lookup(ifname="em1")[0],
     |                  macvtap_mode="vepa").commit()
     |      
     |      Will create a device file `"/dev/tap%s" % index`
     |      
     |      ► tuntap
     |      
     |      Possible `tuntap` keywords:
     |      
     |      * `mode` — "tun" or "tap"
     |      * `uid` — integer
     |      * `gid` — integer
     |      * `ifr` — dict of tuntap flags (see ifinfmsg:... tuntap_data)
     |      
     |      Create a tap interface::
     |      
     |          ip.link("add",
     |                  ifname="tap0",
     |                  kind="tuntap",
     |                  mode="tap")
     |      
     |      Tun/tap interfaces are created using `ioctl()`, but the library
     |      provides a transparent way to manage them using netlink API.
     |      
     |      ► veth
     |      
     |      To properly create `veth` interface, one should specify
     |      `peer` also, since `veth` interfaces are created in pairs::
     |      
     |          # simple call
     |          ip.link("add", ifname="v1p0", kind="veth", peer="v1p1")
     |      
     |          # set up specific veth peer attributes
     |          ip.link("add",
     |                  ifname="v1p0",
     |                  kind="veth",
     |                  peer={"ifname": "v1p1",
     |                        "net_ns_fd": "test_netns"})
     |      
     |      ► vlan
     |      
     |      VLAN interfaces require additional parameters, `vlan_id` and
     |      `link`, where `link` is a master interface to create VLAN on::
     |      
     |          ip.link("add",
     |                  ifname="v100",
     |                  kind="vlan",
     |                  link=ip.link_lookup(ifname="eth0")[0],
     |                  vlan_id=100)
     |      
     |      There is a possibility to create also 802.1ad interfaces::
     |      
     |          # create external vlan 802.1ad, s-tag
     |          ip.link("add",
     |                  ifname="v100s",
     |                  kind="vlan",
     |                  link=ip.link_lookup(ifname="eth0")[0],
     |                  vlan_id=100,
     |                  vlan_protocol=0x88a8)
     |      
     |          # create internal vlan 802.1q, c-tag
     |          ip.link("add",
     |                  ifname="v200c",
     |                  kind="vlan",
     |                  link=ip.link_lookup(ifname="v100s")[0],
     |                  vlan_id=200,
     |                  vlan_protocol=0x8100)
     |      
     |      
     |      ► vrf
     |      
     |      VRF interfaces (see linux/Documentation/networking/vrf.txt)::
     |      
     |          ip.link("add",
     |                  ifname="vrf-foo",
     |                  kind="vrf",
     |                  vrf_table=42)
     |      
     |      ► vxlan
     |      
     |      VXLAN interfaces are like VLAN ones, but require a bit more
     |      parameters::
     |      
     |          ip.link("add",
     |                  ifname="vx101",
     |                  kind="vxlan",
     |                  vxlan_link=ip.link_lookup(ifname="eth0")[0],
     |                  vxlan_id=101,
     |                  vxlan_group='239.1.1.1',
     |                  vxlan_ttl=16)
     |      
     |      All possible vxlan parameters are listed in the module
     |      `pyroute2.netlink.rtnl.ifinfmsg:... vxlan_data`.
     |      
     |      ► ipoib
     |      
     |      IPoIB driver provides an ability to create several ip interfaces
     |      on one interface.
     |      IPoIB interfaces requires the following parameter:
     |      
     |      `link` : The master interface to create IPoIB on.
     |      
     |      The following parameters can also be provided:
     |      
     |      * `pkey`- Inifiniband partition key the ip interface is associated with
     |      * `mode`- Underlying infiniband transport mode. One
     |        of:  ['datagram' ,'connected']
     |      * `umcast`- If set(1), multicast group membership for this interface is
     |        handled by user space.
     |      
     |      Example::
     |      
     |          ip.link("add",
     |                  ifname="ipoib1",
     |                  kind="ipoib",
     |                  link=ip.link_lookup(ifname="ib0")[0],
     |                  pkey=10)
     |      
     |      **set**
     |      
     |      Set interface attributes::
     |      
     |          # get interface index
     |          x = ip.link_lookup(ifname="eth0")[0]
     |          # put link down
     |          ip.link("set", index=x, state="down")
     |          # rename and set MAC addr
     |          ip.link("set", index=x, address="00:11:22:33:44:55", name="bala")
     |          # set MTU and TX queue length
     |          ip.link("set", index=x, mtu=1000, txqlen=2000)
     |          # bring link up
     |          ip.link("set", index=x, state="up")
     |      
     |      Seting bridge or tunnel attributes require `kind` to be
     |      specified in order to properly encode `IFLA_LINKINFO`::
     |      
     |          ip.link("set",
     |                  index=x,
     |                  kind="bridge",
     |                  br_forward_delay=2000)
     |      
     |          ip.link("set",
     |                  index=x,
     |                  kind="gre",
     |                  gre_local="10.0.0.1",
     |                  gre_remote="10.1.0.103")
     |      
     |      Keyword "state" is reserved. State can be "up" or "down",
     |      it is a shortcut::
     |      
     |          state="up":   flags=1, mask=1
     |          state="down": flags=0, mask=0
     |      
     |      SR-IOV virtual function setup::
     |      
     |          # get PF index
     |          x = ip.link_lookup(ifname="eth0")[0]
     |          # setup macaddr
     |          ip.link("set",
     |                  index=x,                          # PF index
     |                  vf={"vf": 0,                      # VF index
     |                      "mac": "00:11:22:33:44:55"})  # address
     |          # setup vlan
     |          ip.link("set",
     |                  index=x,           # PF index
     |                  vf={"vf": 0,       # VF index
     |                      "vlan": 100})  # the simplest case
     |          # setup QinQ
     |          ip.link("set",
     |                  index=x,                           # PF index
     |                  vf={"vf": 0,                       # VF index
     |                      "vlan": [{"vlan": 100,         # vlan id
     |                                "proto": 0x88a8},    # 802.1ad
     |                               {"vlan": 200,         # vlan id
     |                                "proto": 0x8100}]})  # 802.1q
     |      
     |      **update**
     |      
     |      Almost the same as `set`, except it uses different flags
     |      and message type. Mostly does the same, but in some cases
     |      differs. If you're not sure what to use, use `set`.
     |      
     |      **del**
     |      
     |      Destroy the interface::
     |      
     |          ip.link("del", index=ip.link_lookup(ifname="dummy0")[0])
     |      
     |      **dump**
     |      
     |      Dump info for all interfaces
     |      
     |      **get**
     |      
     |      Get specific interface info::
     |      
     |          ip.link("get", index=ip.link_lookup(ifname="br0")[0])
     |      
     |      Get extended attributes like SR-IOV setup::
     |      
     |          ip.link("get", index=3, ext_mask=1)
     |  
     |  link_lookup(self, match=None, **kwarg)
     |      Lookup interface index (indeces) by first level NLA
     |      value.
     |      
     |      Example::
     |      
     |          ip.link_lookup(address="52:54:00:9d:4e:3d")
     |          ip.link_lookup(ifname="lo")
     |          ip.link_lookup(operstate="UP")
     |      
     |      Please note, that link_lookup() returns list, not one
     |      value.
     |  
     |  list_link_kind(self)
     |  
     |  neigh(self, command, **kwarg)
     |      Neighbours operations, same as `ip neigh` or `bridge fdb`
     |      
     |      **add**
     |      
     |      Add a neighbour record, e.g.::
     |      
     |          from pyroute2 import IPRoute
     |          from pyroute2.netlink.rtnl import ndmsg
     |      
     |          # add a permanent record on veth0
     |          idx = ip.link_lookup(ifname='veth0')[0]
     |          ip.neigh('add',
     |                   dst='172.16.45.1',
     |                   lladdr='00:11:22:33:44:55',
     |                   ifindex=idx,
     |                   state=ndmsg.states['permanent'])
     |      
     |      **set**
     |      
     |      Set an existing record or create a new one, if it doesn't exist.
     |      The same as above, but the command is "set"::
     |      
     |          ip.neigh('set',
     |                   dst='172.16.45.1',
     |                   lladdr='00:11:22:33:44:55',
     |                   ifindex=idx,
     |                   state=ndmsg.states['permanent'])
     |      
     |      
     |      **change**
     |      
     |      Change an existing record. If the record doesn't exist, fail.
     |      
     |      **del**
     |      
     |      Delete an existing record.
     |      
     |      **dump**
     |      
     |      Dump all the records in the NDB::
     |      
     |          ip.neigh('dump')
     |      
     |      **get**
     |      
     |      Get specific record (dst and ifindex are mandatory). Available
     |      only on recent kernel::
     |      
     |          ip.neigh('get',
     |                   dst='172.16.45.1',
     |                   ifindex=idx)
     |  
     |  poll(self, method, command, timeout=10, interval=0.2, **spec)
     |      Run `method` with a positional argument `command` and keyword
     |      arguments `**spec` every `interval` seconds, but not more than
     |      `timeout`, until it returns a result which doesn't evaluate to
     |      `False`.
     |      
     |      Example:
     |      
     |      .. code-block:: python
     |      
     |          # create a bridge interface and wait for it:
     |          #
     |          spec = {
     |              'ifname': 'br0',
     |              'kind': 'bridge',
     |              'state': 'up',
     |              'br_stp_state': 1,
     |          }
     |          ipr.link('add', **spec)
     |          ret = ipr.poll(ipr.link, 'dump', **spec)
     |      
     |          assert ret[0].get('ifname') == 'br0'
     |          assert ret[0].get('state') == 'up'
     |          assert ret[0].get(('linkinfo', 'data', 'br_stp_state')) == 1
     |  
     |  register_link_kind(self, path=None, pkg=None, module=None)
     |  
     |  route(self, command, **kwarg)
     |      Route operations.
     |      
     |      Keywords to set up rtmsg fields:
     |      
     |      * dst_len, src_len -- destination and source mask(see `dst` below)
     |      * tos -- type of service
     |      * table -- routing table
     |      * proto -- `redirect`, `boot`, `static` (see `rt_proto`)
     |      * scope -- routing realm
     |      * type -- `unicast`, `local`, etc. (see `rt_type`)
     |      
     |      `pyroute2/netlink/rtnl/rtmsg.py` rtmsg.nla_map:
     |      
     |      * table -- routing table to use (default: 254)
     |      * gateway -- via address
     |      * prefsrc -- preferred source IP address
     |      * dst -- the same as `prefix`
     |      * iif -- incoming traffic interface
     |      * oif -- outgoing traffic interface
     |      
     |      etc.
     |      
     |      One can specify mask not as `dst_len`, but as a part of `dst`,
     |      e.g.: `dst="10.0.0.0/24"`.
     |      
     |      Commands:
     |      
     |      **add**
     |      
     |      Example::
     |      
     |          ipr.route("add", dst="10.0.0.0/24", gateway="192.168.0.1")
     |      
     |      ...
     |      
     |      More `route()` examples. Blackhole route::
     |      
     |          ipr.route(
     |              "add",
     |              dst="10.0.0.0/24",
     |              type="blackhole",
     |          )
     |      
     |      Create a route with metrics::
     |      
     |          ipr.route(
     |              "add",
     |              dst="172.16.0.0/24",
     |              gateway="10.0.0.10",
     |              metrics={
     |                  "mtu": 1400,
     |                  "hoplimit": 16,
     |              },
     |          )
     |      
     |      Multipath route::
     |      
     |          ipr.route(
     |              "add",
     |              dst="10.0.0.0/24",
     |              multipath=[
     |                  {"gateway": "192.168.0.1", "hops": 2},
     |                  {"gateway": "192.168.0.2", "hops": 1},
     |                  {"gateway": "192.168.0.3"},
     |              ],
     |          )
     |      
     |      MPLS lwtunnel on eth0::
     |      
     |          ipr.route(
     |              "add",
     |              dst="10.0.0.0/24",
     |              oif=ip.link_lookup(ifname="eth0"),
     |              encap={
     |                  "type": "mpls",
     |                  "labels": "200/300",
     |              },
     |          )
     |      
     |      IPv6 next hop for IPv4 dst::
     |      
     |          ipr.route(
     |              "add",
     |              prefsrc="10.127.30.4",
     |              dst="172.16.0.0/24",
     |              via={"family": AF_INET6, "addr": "fe80::1337"},
     |              oif=ipr.link_lookup(ifname="eth0"),
     |              table=100,
     |          )
     |      
     |      Create MPLS route: push label::
     |      
     |          # $ sudo modprobe mpls_router
     |          # $ sudo sysctl net.mpls.platform_labels=1024
     |          ipr.route(
     |              "add",
     |              family=AF_MPLS,
     |              oif=ipr.link_lookup(ifname="eth0"),
     |              dst=0x200,
     |              newdst=[0x200, 0x300],
     |          )
     |      
     |      MPLS multipath::
     |      
     |          ipr.route(
     |              "add",
     |              dst="10.0.0.0/24",
     |              table=20,
     |              multipath=[
     |                  {
     |                      "gateway": "192.168.0.1",
     |                      "encap": {"type": "mpls", "labels": 200},
     |                  },
     |                  {
     |                      "ifindex": ipr.link_lookup(ifname="eth0"),
     |                      "encap": {"type": "mpls", "labels": 300},
     |                  },
     |              ],
     |          )
     |      
     |      MPLS target can be int, string, dict or list::
     |      
     |          "labels": 300    # simple label
     |          "labels": "300"  # the same
     |          "labels": (200, 300)  # stacked
     |          "labels": "200/300"   # the same
     |      
     |          # explicit label definition
     |          "labels": {
     |              "bos": 1,
     |              "label": 300,
     |              "tc": 0,
     |              "ttl": 16,
     |          }
     |      
     |      Create SEG6 tunnel encap mode (kernel >= 4.10)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6",
     |                  "mode": "encap",
     |                  "segs": "2000::5,2000::6",
     |              },
     |          )
     |      
     |      Create SEG6 tunnel inline mode (kernel >= 4.10)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6",
     |                  "mode": "inline",
     |                  "segs": ["2000::5", "2000::6"],
     |              },
     |          )
     |      
     |      Create SEG6 tunnel inline mode with hmac (kernel >= 4.10)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:22::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6",
     |                  "mode": "inline",
     |                  "segs": "2000::5,2000::6,2000::7,2000::8",
     |                  "hmac": 0xf,
     |              },
     |          )
     |      
     |      Create SEG6 tunnel with ip4ip6 encapsulation (kernel >= 4.14)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="172.16.0.0/24",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6",
     |                  "mode": "encap",
     |                  "segs": "2000::5,2000::6",
     |              },
     |          )
     |      
     |      Create SEG6LOCAL tunnel End.DX4 action (kernel >= 4.14)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6local",
     |                  "action": "End.DX4",
     |                  "nh4": "172.16.0.10",
     |              },
     |          )
     |      
     |      Create SEG6LOCAL tunnel End.DT6 action (kernel >= 4.14)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6local",
     |                  "action": "End.DT6",
     |                  "table": "10",
     |              },
     |          )
     |      
     |      Create SEG6LOCAL tunnel End.DT4 action (kernel >= 5.11)::
     |      
     |          # $ sudo modprobe vrf
     |          # $ sudo sysctl -w net.vrf.strict_mode=1
     |          ipr.link(
     |              "add",
     |              ifname="vrf-foo",
     |              kind="vrf",
     |              vrf_table=10,
     |          )
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6local",
     |                  "action": "End.DT4",
     |                  "vrf_table": 10,
     |              },
     |          )
     |      
     |      Create SEG6LOCAL tunnel End.B6 action (kernel >= 4.14)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6local",
     |                  "action": "End.B6",
     |                  "srh": {"segs": "2000::5,2000::6"},
     |              },
     |          )
     |      
     |      Create SEG6LOCAL tunnel End.B6 action with hmac (kernel >= 4.14)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6local",
     |                  "action": "End.B6",
     |                  "srh": {
     |                      "segs": "2000::5,2000::6",
     |                      "hmac": 0xf,
     |                  },
     |              },
     |          )
     |      
     |      **change**, **replace**, **append**
     |      
     |      Commands `change`, `replace` and `append` have the same meanings
     |      as in ip-route(8): `change` modifies only existing route, while
     |      `replace` creates a new one, if there is no such route yet.
     |      `append` allows to create an IPv6 multipath route.
     |      
     |      **del**
     |      
     |      Remove the route. The same syntax as for **add**.
     |      
     |      **get**
     |      
     |      Get route by spec.
     |      
     |      **dump**
     |      
     |      Dump all routes.
     |  
     |  rule(self, command, **kwarg)
     |      Rule operations
     |      
     |          - command — add, delete
     |          - table — 0 < table id < 253
     |          - priority — 0 < rule's priority < 32766
     |          - action — type of rule, default 'FR_ACT_NOP' (see fibmsg.py)
     |          - rtscope — routing scope, default RT_SCOPE_UNIVERSE
     |              `(RT_SCOPE_UNIVERSE|RT_SCOPE_SITE|                RT_SCOPE_LINK|RT_SCOPE_HOST|RT_SCOPE_NOWHERE)`
     |          - family — rule's family (socket.AF_INET (default) or
     |              socket.AF_INET6)
     |          - src — IP source for Source Based (Policy Based) routing's rule
     |          - dst — IP for Destination Based (Policy Based) routing's rule
     |          - src_len — Mask for Source Based (Policy Based) routing's rule
     |          - dst_len — Mask for Destination Based (Policy Based) routing's
     |              rule
     |          - iifname — Input interface for Interface Based (Policy Based)
     |              routing's rule
     |          - oifname — Output interface for Interface Based (Policy Based)
     |              routing's rule
     |          - uid_range — Range of user identifiers, a string like "1000:1234"
     |          - dport_range — Range of destination ports, a string like "80-120"
     |          - sport_range — Range of source ports, as a string like "80-120"
     |      
     |      All packets route via table 10::
     |      
     |          # 32000: from all lookup 10
     |          # ...
     |          ip.rule('add', table=10, priority=32000)
     |      
     |      Default action::
     |      
     |          # 32001: from all lookup 11 unreachable
     |          # ...
     |          iproute.rule('add',
     |                       table=11,
     |                       priority=32001,
     |                       action='FR_ACT_UNREACHABLE')
     |      
     |      Use source address to choose a routing table::
     |      
     |          # 32004: from 10.64.75.141 lookup 14
     |          # ...
     |          iproute.rule('add',
     |                       table=14,
     |                       priority=32004,
     |                       src='10.64.75.141')
     |      
     |      Use dst address to choose a routing table::
     |      
     |          # 32005: from 10.64.75.141/24 lookup 15
     |          # ...
     |          iproute.rule('add',
     |                       table=15,
     |                       priority=32005,
     |                       dst='10.64.75.141',
     |                       dst_len=24)
     |      
     |      Match fwmark::
     |      
     |          # 32006: from 10.64.75.141 fwmark 0xa lookup 15
     |          # ...
     |          iproute.rule('add',
     |                       table=15,
     |                       priority=32006,
     |                       dst='10.64.75.141',
     |                       fwmark=10)
     |  
     |  stats(self, command, **kwarg)
     |      Stats prototype.
     |  
     |  tc(self, command, kind=None, index=0, handle=0, **kwarg)
     |      "Swiss knife" for traffic control. With the method you can
     |      add, delete or modify qdiscs, classes and filters.
     |      
     |      * command -- add or delete qdisc, class, filter.
     |      * kind -- a string identifier -- "sfq", "htb", "u32" and so on.
     |      * handle -- integer or string
     |      
     |      Command can be one of ("add", "del", "add-class", "del-class",
     |      "add-filter", "del-filter") (see `commands` dict in the code).
     |      
     |      Handle notice: traditional iproute2 notation, like "1:0", actually
     |      represents two parts in one four-bytes integer::
     |      
     |          1:0    ->    0x10000
     |          1:1    ->    0x10001
     |          ff:0   ->   0xff0000
     |          ffff:1 -> 0xffff0001
     |      
     |      Target notice: if your target is a class/qdisc that applies an
     |      algorithm that can only apply to upstream traffic profile, but your
     |      keys variable explicitly references a match that is only relevant for
     |      upstream traffic, the kernel will reject the filter.  Unless you're
     |      dealing with devices like IMQs
     |      
     |      For pyroute2 tc() you can use both forms: integer like 0xffff0000
     |      or string like 'ffff:0000'. By default, handle is 0, so you can add
     |      simple classless queues w/o need to specify handle. Ingress queue
     |      causes handle to be 0xffff0000.
     |      
     |      So, to set up sfq queue on interface 1, the function call
     |      will be like that::
     |      
     |          ip = IPRoute()
     |          ip.tc("add", "sfq", 1)
     |      
     |      Instead of string commands ("add", "del"...), you can use also
     |      module constants, `RTM_NEWQDISC`, `RTM_DELQDISC` and so on::
     |      
     |          ip = IPRoute()
     |          flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_CREATE | NLM_F_EXCL
     |          ip.tc((RTM_NEWQDISC, flags), "sfq", 1)
     |      
     |      It should be noted that "change", "change-class" and
     |      "change-filter" work like "replace", "replace-class" and
     |      "replace-filter", except they will fail if the node doesn't
     |      exist (while it would have been created by "replace"). This is
     |      not the same behaviour as with "tc" where "change" can be used
     |      to modify the value of some options while leaving the others
     |      unchanged. However, as not all entities support this
     |      operation, we believe the "change" commands as implemented
     |      here are more useful.
     |      
     |      
     |      Also available "modules" (returns tc plugins dict) and "help"
     |      commands::
     |      
     |          help(ip.tc("modules")["htb"])
     |          print(ip.tc("help", "htb"))
     |  
     |  unregister_link_kind(self, kind)
     |  
     |  vlan_filter(self, command, **kwarg)
     |      Vlan filters is another approach to support vlans in Linux.
     |      Before vlan filters were introduced, there was only one way
     |      to bridge vlans: one had to create vlan interfaces and
     |      then add them as ports::
     |      
     |                  +------+      +----------+
     |          net --> | eth0 | <--> | eth0.500 | <---+
     |                  +------+      +----------+     |
     |                                                 v
     |                  +------+                    +-----+
     |          net --> | eth1 |                    | br0 |
     |                  +------+                    +-----+
     |                                                 ^
     |                  +------+      +----------+     |
     |          net --> | eth2 | <--> | eth2.500 | <---+
     |                  +------+      +----------+
     |      
     |      It means that one has to create as many bridges, as there were
     |      vlans. Vlan filters allow to bridge together underlying interfaces
     |      and create vlans already on the bridge::
     |      
     |          # v500 label shows which interfaces have vlan filter
     |      
     |                  +------+ v500
     |          net --> | eth0 | <-------+
     |                  +------+         |
     |                                   v
     |                  +------+      +-----+    +---------+
     |          net --> | eth1 | <--> | br0 |<-->| br0v500 |
     |                  +------+      +-----+    +---------+
     |                                   ^
     |                  +------+ v500    |
     |          net --> | eth2 | <-------+
     |                  +------+
     |      
     |      In this example vlan 500 will be allowed only on ports `eth0` and
     |      `eth2`, though all three eth nics are bridged.
     |      
     |      Some example code::
     |      
     |          # create bridge
     |          ip.link("add",
     |                  ifname="br0",
     |                  kind="bridge")
     |      
     |          # attach a port
     |          ip.link("set",
     |                  index=ip.link_lookup(ifname="eth0")[0],
     |                  master=ip.link_lookup(ifname="br0")[0])
     |      
     |          # set vlan filter
     |          ip.vlan_filter("add",
     |                         index=ip.link_lookup(ifname="eth0")[0],
     |                         vlan_info={"vid": 500})
     |      
     |          # create vlan interface on the bridge
     |          ip.link("add",
     |                  ifname="br0v500",
     |                  kind="vlan",
     |                  link=ip.link_lookup(ifname="br0")[0],
     |                  vlan_id=500)
     |      
     |          # set all UP
     |          ip.link("set",
     |                  index=ip.link_lookup(ifname="br0")[0],
     |                  state="up")
     |          ip.link("set",
     |                  index=ip.link_lookup(ifname="br0v500")[0],
     |                  state="up")
     |          ip.link("set",
     |                  index=ip.link_lookup(ifname="eth0")[0],
     |                  state="up")
     |      
     |          # set IP address
     |          ip.addr("add",
     |                  index=ip.link_lookup(ifname="br0v500")[0],
     |                  address="172.16.5.2",
     |                  mask=24)
     |      
     |          Now all the traffic to the network 172.16.5.2/24 will go
     |          to vlan 500 only via ports that have such vlan filter.
     |      
     |      
     |      Required arguments for `vlan_filter()` -- `index` and `vlan_info`.
     |      Vlan info struct::
     |      
     |          {"vid": uint16,
     |           "flags": uint16}
     |      
     |      More details:
     |          * kernel:Documentation/networking/switchdev.txt
     |          * pyroute2.netlink.rtnl.ifinfmsg:... vlan_info
     |      
     |      One can specify `flags` as int or as a list of flag names:
     |          * `master` == 0x1
     |          * `pvid` == 0x2
     |          * `untagged` == 0x4
     |          * `range_begin` == 0x8
     |          * `range_end` == 0x10
     |          * `brentry` == 0x20
     |      
     |      E.g.::
     |      
     |          {"vid": 20,
     |           "flags": ["pvid", "untagged"]}
     |      
     |          # is equal to
     |          {"vid": 20,
     |           "flags": 6}
     |      
     |      Commands:
     |      
     |      **add**
     |      
     |      Add vlan filter to a bridge port. Example::
     |      
     |          ip.vlan_filter("add", index=2, vlan_info={"vid": 200})
     |      
     |      **del**
     |      
     |      Remove vlan filter from a bridge port. Example::
     |      
     |          ip.vlan_filter("del", index=2, vlan_info={"vid": 200})
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from RTNL_API:
     |  
     |  close_file(fd)
     |      Close a file that was previously opened with open_file().
     |  
     |  get_pid()
     |      Return the PID of the current process.
     |  
     |  open_file(path)
     |      Open a file (read only) and return its (fd, inode).
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from RTNL_API:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.rtnl.iprsocket.IPRSocketBase:
     |  
     |  bind(self, groups=None, **kwarg)
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.BatchSocket:
     |  
     |  get(self, *argv, **kwarg)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  nlm_request(self, msg, msg_type, msg_flags=769, terminate=None, callback=None)
     |  
     |  post_init(self)
     |  
     |  reset(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  buffer_thread_routine(self)
     |  
     |  clone(self)
     |  
     |  close(self, code=104)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  recv(self, *argv, **kwarg)
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
    
    class IPDB(builtins.object)
     |  IPDB(nl=None, mode='implicit', restart_on_error=None, nl_async=None, sndbuf=1048576, rcvbuf=1048576, nl_bind_groups=67372509, ignore_rtables=None, callbacks=None, sort_addresses=False, plugins=None, deprecation_warning=True)
     |  
     |  The class that maintains information about network setup
     |  of the host. Monitoring netlink events allows it to react
     |  immediately. It uses no polling.
     |  
     |  Methods defined here:
     |  
     |  __dir__(self)
     |      Default dir() implementation.
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  __getattribute__(self, name)
     |      Return getattr(self, name).
     |  
     |  __init__(self, nl=None, mode='implicit', restart_on_error=None, nl_async=None, sndbuf=1048576, rcvbuf=1048576, nl_bind_groups=67372509, ignore_rtables=None, callbacks=None, sort_addresses=False, plugins=None, deprecation_warning=True)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  commit(self, transactions=None, phase=1)
     |  
     |  create(self, kind, ifname, reuse=False, **kwarg)
     |  
     |  drop(self)
     |  
     |  dump(self)
     |  
     |  ensure(self, cmd='add', reachable=None, condition=None)
     |  
     |  eventloop(self, qsize=8192, block=True, timeout=None)
     |      Event generator for simple cases when there is no need for initial
     |      state setup. Initialize event queue and yield events as they happen.
     |  
     |  eventqueue(self, qsize=8192, block=True, timeout=None)
     |      Initializes event queue and returns event queue context manager.
     |      Once the context manager is initialized, events start to be collected,
     |      so it is possible to read initial state from the system without losing
     |      last moment changes, and once that is done, start processing events.
     |      
     |      Example::
     |      
     |          ipdb = IPDB()
     |          with ipdb.eventqueue() as evq:
     |              my_state = ipdb.<needed_attribute>...
     |              for msg in evq:
     |                  update_state_by_msg(my_state, msg)
     |  
     |  initdb(self)
     |  
     |  items(self)
     |  
     |  load(self, config, ptr=None)
     |  
     |  register_callback(self, callback, mode='post')
     |      IPDB callbacks are routines executed on a RT netlink
     |      message arrival. There are two types of callbacks:
     |      "post" and "pre" callbacks.
     |      
     |      ...
     |      
     |      "Post" callbacks are executed after the message is
     |      processed by IPDB and all corresponding objects are
     |      created or deleted. Using ipdb reference in "post"
     |      callbacks you will access the most up-to-date state
     |      of the IP database.
     |      
     |      "Post" callbacks are executed asynchronously in
     |      separate threads. These threads can work as long
     |      as you want them to. Callback threads are joined
     |      occasionally, so for a short time there can exist
     |      stopped threads.
     |      
     |      ...
     |      
     |      "Pre" callbacks are synchronous routines, executed
     |      before the message gets processed by IPDB. It gives
     |      you the way to patch arriving messages, but also
     |      places a restriction: until the callback exits, the
     |      main event IPDB loop is blocked.
     |      
     |      Normally, only "post" callbacks are required. But in
     |      some specific cases "pre" also can be useful.
     |      
     |      ...
     |      
     |      The routine, `register_callback()`, takes two arguments:
     |          - callback function
     |          - mode (optional, default="post")
     |      
     |      The callback should be a routine, that accepts three
     |      arguments::
     |      
     |          cb(ipdb, msg, action)
     |      
     |      Arguments are:
     |      
     |          - **ipdb** is a reference to IPDB instance, that invokes
     |              the callback.
     |          - **msg** is a message arrived
     |          - **action** is just a msg['event'] field
     |      
     |      E.g., to work on a new interface, you should catch
     |      action == 'RTM_NEWLINK' and with the interface index
     |      (arrived in msg['index']) get it from IPDB::
     |      
     |          index = msg['index']
     |          interface = ipdb.interfaces[index]
     |  
     |  release(self)
     |      Shutdown IPDB instance and sync the state. Since
     |      IPDB is asyncronous, some operations continue in the
     |      background, e.g. callbacks. So, prior to exit the
     |      script, it is required to properly shutdown IPDB.
     |      
     |      The shutdown sequence is not forced in an interactive
     |      python session, since it is easier for users and there
     |      is enough time to sync the state. But for the scripts
     |      the `release()` call is required.
     |  
     |  review(self)
     |  
     |  unregister_callback(self, cuid, mode='post')
     |  
     |  watchdog(self, wdops='RTM_NEWLINK', **kwarg)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    IPMock = class IPRoute(pyroute2.lab.LAB_API, pyroute2.netlink.nlsocket.NetlinkSocketBase, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  IPMock(*argv, **kwarg)
     |  
     |  Generic netlink socket.
     |  
     |  Method resolution order:
     |      IPRoute
     |      pyroute2.lab.LAB_API
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, *argv, **kwarg)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  addr(self, command, **spec)
     |  
     |  bind(self, async_cache=True, clone_socket=True)
     |  
     |  dump(self, groups=None)
     |  
     |  get_addr(self)
     |  
     |  get_links(self)
     |  
     |  get_routes(self)
     |  
     |  link(self, command, **spec)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pyroute2.lab.LAB_API:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  buffer_thread_routine(self)
     |  
     |  clone(self)
     |  
     |  close(self, code=104)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request(self, msg, msg_type, msg_flags=769, terminate=None, callback=None, parser=None)
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  post_init(self)
     |  
     |  recv(self, *argv, **kwarg)
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  get(self, bufsize=65536, msg_seq=0, terminate=None, callback=None, noraise=False)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
    
    class IPQSocket(pyroute2.netlink.nlsocket.NetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  IPQSocket(family=16, port=None, pid=None, fileno=None, sndbuf=1048576, rcvbuf=1048576, all_ns=False, async_qsize=None, nlm_generator=None, target='localhost', ext_ack=False, strict_check=False, groups=0)
     |  
     |  Low-level socket interface. Provides all the
     |  usual socket does, can be used in poll/select,
     |  doesn't create any implicit threads.
     |  
     |  Method resolution order:
     |      IPQSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  bind(self, mode=2)
     |      Bind the socket and performs IPQ mode configuration.
     |      The only parameter is mode, the default value is
     |      IPQ_COPY_PACKET (copy all the packet data).
     |  
     |  verdict(self, seq, v)
     |      Issue a verdict `v` for a packet `seq`.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocket:
     |  
     |  __getattr__(self, attr)
     |  
     |  add_membership(self, group)
     |  
     |  close(self, code=104)
     |      Correctly close the socket and free all resources.
     |  
     |  drop_membership(self, group)
     |  
     |  post_init(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  __init__(self, family=16, port=None, pid=None, fileno=None, sndbuf=1048576, rcvbuf=1048576, all_ns=False, async_qsize=None, nlm_generator=None, target='localhost', ext_ack=False, strict_check=False, groups=0)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  buffer_thread_routine(self)
     |  
     |  clone(self)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request(self, msg, msg_type, msg_flags=769, terminate=None, callback=None, parser=None)
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  recv(self, *argv, **kwarg)
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  get(self, bufsize=65536, msg_seq=0, terminate=None, callback=None, noraise=False)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class IPRSocket(IPRSocketBase, pyroute2.netlink.nlsocket.NetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  IPRSocket(*argv, **kwarg)
     |  
     |  The simplest class, that connects together the netlink parser and
     |  a generic Python socket implementation. Provides method get() to
     |  receive the next message from netlink socket and parse it. It is
     |  just simple socket-like class, it implements no buffering or
     |  like that. It spawns no additional threads, leaving this up to
     |  developers.
     |  
     |  Please note, that netlink is an asynchronous protocol with
     |  non-guaranteed delivery. You should be fast enough to get all the
     |  messages in time. If the message flow rate is higher than the
     |  speed you parse them with, exceeding messages will be dropped.
     |  
     |  *Usage*
     |  
     |  Threadless RT netlink monitoring with blocking I/O calls:
     |  
     |      >>> from pyroute2 import IPRSocket
     |      >>> from pprint import pprint
     |      >>> s = IPRSocket()
     |      >>> s.bind()
     |      >>> pprint(s.get())
     |      [{'attrs': [('RTA_TABLE', 254),
     |                  ('RTA_DST', '2a00:1450:4009:808::1002'),
     |                  ('RTA_GATEWAY', 'fe80:52:0:2282::1fe'),
     |                  ('RTA_OIF', 2),
     |                  ('RTA_PRIORITY', 0),
     |                  ('RTA_CACHEINFO', {'rta_clntref': 0,
     |                                     'rta_error': 0,
     |                                     'rta_expires': 0,
     |                                     'rta_id': 0,
     |                                     'rta_lastuse': 5926,
     |                                     'rta_ts': 0,
     |                                     'rta_tsage': 0,
     |                                     'rta_used': 1})],
     |        'dst_len': 128,
     |        'event': 'RTM_DELROUTE',
     |        'family': 10,
     |        'flags': 512,
     |        'header': {'error': None,
     |                   'flags': 0,
     |                   'length': 128,
     |                   'pid': 0,
     |                   'sequence_number': 0,
     |                   'type': 25},
     |        'proto': 9,
     |        'scope': 0,
     |        'src_len': 0,
     |        'table': 254,
     |        'tos': 0,
     |        'type': 1}]
     |      >>>
     |  
     |  Method resolution order:
     |      IPRSocket
     |      IPRSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  bind(self, *argv, **kwarg)
     |      Bind the socket to given multicast groups, using
     |      given pid.
     |      
     |          - If pid is None, use automatic port allocation
     |          - If pid == 0, use process' pid
     |          - If pid == <int>, use the value instead of pid
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from IPRSocketBase:
     |  
     |  __init__(self, *argv, **kwarg)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from IPRSocketBase:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocket:
     |  
     |  __getattr__(self, attr)
     |  
     |  add_membership(self, group)
     |  
     |  close(self, code=104)
     |      Correctly close the socket and free all resources.
     |  
     |  drop_membership(self, group)
     |  
     |  post_init(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  buffer_thread_routine(self)
     |  
     |  clone(self)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request(self, msg, msg_type, msg_flags=769, terminate=None, callback=None, parser=None)
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  recv(self, *argv, **kwarg)
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  get(self, bufsize=65536, msg_seq=0, terminate=None, callback=None, noraise=False)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
    
    class IPRoute(pyroute2.lab.LAB_API, RTNL_API, pyroute2.netlink.rtnl.iprsocket.IPRSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  IPRoute(*argv, **kwarg)
     |  
     |  Regular ordinary utility class, see RTNL API for the list of methods.
     |  
     |  Method resolution order:
     |      IPRoute
     |      pyroute2.lab.LAB_API
     |      RTNL_API
     |      pyroute2.netlink.rtnl.iprsocket.IPRSocket
     |      pyroute2.netlink.rtnl.iprsocket.IPRSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Methods inherited from pyroute2.lab.LAB_API:
     |  
     |  __init__(self, *argv, **kwarg)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pyroute2.lab.LAB_API:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from RTNL_API:
     |  
     |  addr(self, command, *argv, **kwarg)
     |      Address operations
     |      
     |      * command -- add, delete, replace, dump
     |      * index -- device index
     |      * address -- IPv4 or IPv6 address
     |      * mask -- address mask
     |      * family -- socket.AF_INET for IPv4 or socket.AF_INET6 for IPv6
     |      * scope -- the address scope, see /etc/iproute2/rt_scopes
     |      * kwarg -- dictionary, any ifaddrmsg field or NLA
     |      
     |      Later the method signature will be changed to::
     |      
     |          def addr(self, command, match=None, **kwarg):
     |              # the method body
     |      
     |      So only keyword arguments (except of the command) will be accepted.
     |      The reason for this change is an unification of API.
     |      
     |      Example::
     |      
     |          idx = 62
     |          ip.addr('add', index=idx, address='10.0.0.1', mask=24)
     |          ip.addr('add', index=idx, address='10.0.0.2', mask=24)
     |      
     |      With more NLAs::
     |      
     |          # explicitly set broadcast address
     |          ip.addr('add', index=idx,
     |                  address='10.0.0.3',
     |                  broadcast='10.0.0.255',
     |                  prefixlen=24)
     |      
     |          # make the secondary address visible to ifconfig: add label
     |          ip.addr('add', index=idx,
     |                  address='10.0.0.4',
     |                  broadcast='10.0.0.255',
     |                  prefixlen=24,
     |                  label='eth0:1')
     |      
     |      Configure p2p address on an interface::
     |      
     |          ip.addr('add', index=idx,
     |                  address='10.1.1.2',
     |                  mask=24,
     |                  local='10.1.1.1')
     |  
     |  brport(self, command, **kwarg)
     |      Set bridge port parameters. Example::
     |      
     |          idx = ip.link_lookup(ifname='eth0')
     |          ip.brport("set", index=idx, unicast_flood=0, cost=200)
     |          ip.brport("show", index=idx)
     |      
     |      Possible keywords are NLA names for the `protinfo_bridge` class,
     |      without the prefix and in lower letters.
     |  
     |  dump(self, groups=None)
     |      Dump network objects.
     |      
     |      On OpenBSD:
     |      
     |      * get_links()
     |      * get_addr()
     |      * get_neighbours()
     |      * get_routes()
     |      
     |      On Linux:
     |      
     |      * get_links()
     |      * get_addr()
     |      * get_neighbours()
     |      * get_vlans()
     |      * dump FDB
     |      * IPv4 and IPv6 rules
     |  
     |  fdb(self, command, **kwarg)
     |      Bridge forwarding database management.
     |      
     |      More details:
     |          * kernel:Documentation/networking/switchdev.txt
     |          * pyroute2.netlink.rtnl.ndmsg
     |      
     |      **add**
     |      
     |      Add a new FDB record. Works in the same way as ARP cache
     |      management, but some additional NLAs can be used::
     |      
     |          # simple FDB record
     |          #
     |          ip.fdb('add',
     |                 ifindex=ip.link_lookup(ifname='br0')[0],
     |                 lladdr='00:11:22:33:44:55',
     |                 dst='10.0.0.1')
     |      
     |          # specify vlan
     |          # NB: vlan should exist on the device, use
     |          # `vlan_filter()`
     |          #
     |          ip.fdb('add',
     |                 ifindex=ip.link_lookup(ifname='br0')[0],
     |                 lladdr='00:11:22:33:44:55',
     |                 dst='10.0.0.1',
     |                 vlan=200)
     |      
     |          # specify vxlan id and port
     |          # NB: works only for vxlan devices, use
     |          # `link("add", kind="vxlan", ...)`
     |          #
     |          # if port is not specified, the default one is used
     |          # by the kernel.
     |          #
     |          # if vni (vxlan id) is equal to the device vni,
     |          # the kernel doesn't report it back
     |          #
     |          ip.fdb('add',
     |                 ifindex=ip.link_lookup(ifname='vx500')[0]
     |                 lladdr='00:11:22:33:44:55',
     |                 dst='10.0.0.1',
     |                 port=5678,
     |                 vni=600)
     |      
     |      **append**
     |      
     |      Append a new FDB record. The same syntax as for **add**.
     |      
     |      **del**
     |      
     |      Remove an existing FDB record. The same syntax as for **add**.
     |      
     |      **dump**
     |      
     |      Dump all the FDB records. If any `**kwarg` is provided,
     |      results will be filtered::
     |      
     |          # dump all the records
     |          ip.fdb('dump')
     |      
     |          # show only specific lladdr, dst, vlan etc.
     |          ip.fdb('dump', lladdr='00:11:22:33:44:55')
     |          ip.fdb('dump', dst='10.0.0.1')
     |          ip.fdb('dump', vlan=200)
     |  
     |  filter_messages(self, dump_filter, msgs)
     |      Filter messages using `dump_filter`. The filter might be a
     |      callable, then it will be called for every message in the list.
     |      Or it might be a dict, where keys are used to get values
     |      from messages, and dict values are used to match the message.
     |      
     |      The method might be called directly. It is also used by calls
     |      like `ipr.link('dump', ....)`, where keyword arguments work as
     |      `dump_filter` for `ipr.filter_messages()`.
     |      
     |      A callable `dump_filter` must return True or False:
     |      
     |      .. code-block:: python
     |      
     |          # get all links with names starting with eth:
     |          #
     |          ipr.filter_messages(
     |              lambda x: x.get_attr('IFLA_IFNAME').startswith('eth'),
     |              ipr.link('dump')
     |          )
     |      
     |      A dict `dump_filter` can have callables as values:
     |      
     |      .. code-block:: python
     |      
     |          # get all links with names starting with eth, and
     |          # MAC address in a database:
     |          #
     |          ipr.filter_messages(
     |              {
     |                  'ifname': lambda x: x.startswith('eth'),
     |                  'address': lambda x: x in database,
     |              },
     |              ipr.link('dump')
     |          )
     |      
     |      ... or constants to compare with:
     |      
     |      .. code-block:: python
     |      
     |          # get all links in state up:
     |          #
     |          ipr.filter_message({'state': 'up'}, ipr.link('dump'))
     |  
     |  flush_addr(self, *argv, **kwarg)
     |      Flush IP addresses.
     |      
     |      Examples::
     |      
     |          # flush all addresses on the interface with index 2:
     |          ipr.flush_addr(index=2)
     |      
     |          # flush all addresses with IFA_LABEL='eth0':
     |          ipr.flush_addr(label='eth0')
     |  
     |  flush_routes(self, *argv, **kwarg)
     |      Flush routes -- purge route records from a table.
     |      Arguments are the same as for `get_routes()`
     |      routine. Actually, this routine implements a pipe from
     |      `get_routes()` to `nlm_request()`.
     |  
     |  flush_rules(self, *argv, **kwarg)
     |      Flush rules. Please keep in mind, that by default the function
     |      operates on **all** rules of **all** families. To work only on
     |      IPv4 rules, one should explicitly specify `family=AF_INET`.
     |      
     |      Examples::
     |      
     |          # flush all IPv4 rule with priorities above 5 and below 32000
     |          ipr.flush_rules(family=AF_INET, priority=lambda x: 5 < x < 32000)
     |      
     |          # flush all IPv6 rules that point to table 250:
     |          ipr.flush_rules(family=socket.AF_INET6, table=250)
     |  
     |  get_addr(self, family=<AddressFamily.AF_UNSPEC: 0>, match=None, **kwarg)
     |      Dump addresses.
     |      
     |      If family is not specified, both AF_INET and AF_INET6 addresses
     |      will be dumped::
     |      
     |          # get all addresses
     |          ip.get_addr()
     |      
     |      It is possible to apply filters on the results::
     |      
     |          # get addresses for the 2nd interface
     |          ip.get_addr(index=2)
     |      
     |          # get addresses with IFA_LABEL == 'eth0'
     |          ip.get_addr(label='eth0')
     |      
     |          # get all the subnet addresses on the interface, identified
     |          # by broadcast address (should be explicitly specified upon
     |          # creation)
     |          ip.get_addr(index=2, broadcast='192.168.1.255')
     |      
     |      A custom predicate can be used as a filter::
     |      
     |          ip.get_addr(match=lambda x: x['index'] == 1)
     |  
     |  get_classes(self, index=0)
     |      Get classes for specified interface.
     |  
     |  get_default_routes(self, family=<AddressFamily.AF_UNSPEC: 0>, table=254)
     |      Get default routes
     |  
     |  get_filters(self, index=0, handle=0, parent=0)
     |      Get filters for specified interface, handle and parent.
     |  
     |  get_links(self, *argv, **kwarg)
     |      Get network interfaces.
     |      
     |      By default returns all interfaces. Arguments vector
     |      can contain interface indices or a special keyword
     |      'all'::
     |      
     |          ip.get_links()
     |          ip.get_links('all')
     |          ip.get_links(1, 2, 3)
     |      
     |          interfaces = [1, 2, 3]
     |          ip.get_links(*interfaces)
     |  
     |  get_neighbours(self, family=<AddressFamily.AF_UNSPEC: 0>, match=None, **kwarg)
     |      Dump ARP cache records.
     |      
     |      The `family` keyword sets the family for the request:
     |      e.g. `AF_INET` or `AF_INET6` for arp cache, `AF_BRIDGE`
     |      for fdb.
     |      
     |      If other keyword arguments not empty, they are used as
     |      filter. Also, one can explicitly set filter as a function
     |      with the `match` parameter.
     |      
     |      Examples::
     |      
     |          # get neighbours on the 3rd link:
     |          ip.get_neighbours(ifindex=3)
     |      
     |          # get a particular record by dst:
     |          ip.get_neighbours(dst='172.16.0.1')
     |      
     |          # get fdb records:
     |          ip.get_neighbours(AF_BRIDGE)
     |      
     |          # and filter them by a function:
     |          ip.get_neighbours(AF_BRIDGE, match=lambda x: x['state'] == 2)
     |  
     |  get_netns_info(self, list_proc=False)
     |      A prototype method to list available netns and associated
     |      interfaces. A bit weird to have it here and not under
     |      `pyroute2.netns`, but it uses RTNL to get all the info.
     |  
     |  get_netnsid(self, nsid=None, pid=None, fd=None, target_nsid=None)
     |      Return a dict containing the result of a RTM_GETNSID query.
     |      This loosely corresponds to the "ip netns list-id" command.
     |  
     |  get_ntables(self, family=<AddressFamily.AF_UNSPEC: 0>)
     |      Get neighbour tables
     |  
     |  get_qdiscs(self, index=None)
     |      Get all queue disciplines for all interfaces or for specified
     |      one.
     |  
     |  get_routes(self, family=255, match=None, **kwarg)
     |      Get all routes. You can specify the table. There
     |      are up to 4294967295 routing classes (tables), and the kernel
     |      returns all the routes on each request. So the
     |      routine filters routes from full output. Note the number of
     |      tables is increased from 255 in Linux 2.6+.
     |      
     |      Example::
     |      
     |          ip.get_routes()  # get all the routes for all families
     |          ip.get_routes(family=AF_INET6)  # get only IPv6 routes
     |          ip.get_routes(table=254)  # get routes from 254 table
     |      
     |      The default family=255 is a hack. Despite the specs,
     |      the kernel returns only IPv4 routes for AF_UNSPEC family.
     |      But it returns all the routes for all the families if one
     |      uses an invalid value here. Hack but true. And let's hope
     |      the kernel team will not fix this bug.
     |  
     |  get_rules(self, family=<AddressFamily.AF_UNSPEC: 0>, match=None, **kwarg)
     |      Get all rules. By default return all rules. To explicitly
     |      request the IPv4 rules use `family=AF_INET`.
     |      
     |      Example::
     |          ip.get_rules() # get all the rules for all families
     |          ip.get_rules(family=AF_INET6)  # get only IPv6 rules
     |  
     |  get_vlans(self, **kwarg)
     |      Dump available vlan info on bridge ports
     |  
     |  link(self, command, **kwarg)
     |      Link operations.
     |      
     |      Keywords to set up ifinfmsg fields:
     |          * index -- interface index
     |          * family -- AF_BRIDGE for bridge operations, otherwise 0
     |          * flags -- device flags
     |          * change -- change mask
     |      
     |      All other keywords will be translated to NLA names, e.g.
     |      `mtu -> IFLA_MTU`, `af_spec -> IFLA_AF_SPEC` etc. You can
     |      provide a complete NLA structure or let filters do it for
     |      you. E.g., these pairs show equal statements::
     |      
     |          # set device MTU
     |          ip.link("set", index=x, mtu=1000)
     |          ip.link("set", index=x, IFLA_MTU=1000)
     |      
     |          # add vlan device
     |          ip.link("add", ifname="test", kind="dummy")
     |          ip.link("add", ifname="test",
     |                  IFLA_LINKINFO={'attrs': [['IFLA_INFO_KIND', 'dummy']]})
     |      
     |      Filters are implemented in the `pyroute2.iproute.req` module.
     |      You can contribute your own if you miss shortcuts.
     |      
     |      Commands:
     |      
     |      **add**
     |      
     |      To create an interface, one should specify the interface kind::
     |      
     |          ip.link("add",
     |                  ifname="test",
     |                  kind="dummy")
     |      
     |      The kind can be any of those supported by kernel. It can be
     |      `dummy`, `bridge`, `bond` etc. On modern kernels one can specify
     |      even interface index::
     |      
     |          ip.link("add",
     |                  ifname="br-test",
     |                  kind="bridge",
     |                  index=2345)
     |      
     |      Specific type notes:
     |      
     |      ► geneve
     |      
     |      Create GENEVE tunnel::
     |      
     |          ip.link("add",
     |                  ifname="genx",
     |                  kind="geneve",
     |                  geneve_id=42,
     |                  geneve_remote="172.16.0.101")
     |      
     |      Support for GENEVE over IPv6 is also included; use `geneve_remote6`
     |      to configure a remote IPv6 address.
     |      
     |      ► gre
     |      
     |      Create GRE tunnel::
     |      
     |          ip.link("add",
     |                  ifname="grex",
     |                  kind="gre",
     |                  gre_local="172.16.0.1",
     |                  gre_remote="172.16.0.101",
     |                  gre_ttl=16)
     |      
     |      The keyed GRE requires explicit iflags/oflags specification::
     |      
     |          ip.link("add",
     |                  ifname="grex",
     |                  kind="gre",
     |                  gre_local="172.16.0.1",
     |                  gre_remote="172.16.0.101",
     |                  gre_ttl=16,
     |                  gre_ikey=10,
     |                  gre_okey=10,
     |                  gre_iflags=32,
     |                  gre_oflags=32)
     |      
     |      Support for GRE over IPv6 is also included; use `kind=ip6gre` and
     |      `ip6gre_` as the prefix for its values.
     |      
     |      ► ipip
     |      
     |      Create ipip tunnel::
     |      
     |          ip.link("add",
     |                  ifname="tun1",
     |                  kind="ipip",
     |                  ipip_local="172.16.0.1",
     |                  ipip_remote="172.16.0.101",
     |                  ipip_ttl=16)
     |      
     |      Support for sit and ip6tnl is also included; use `kind=sit` and `sit_`
     |      as prefix for sit tunnels, and `kind=ip6tnl` and `ip6tnl_` prefix for
     |      ip6tnl tunnels.
     |      
     |      ► macvlan
     |      
     |      Macvlan interfaces act like VLANs within OS. The macvlan driver
     |      provides an ability to add several MAC addresses on one interface,
     |      where every MAC address is reflected with a virtual interface in
     |      the system.
     |      
     |      In some setups macvlan interfaces can replace bridge interfaces,
     |      providing more simple and at the same time high-performance
     |      solution::
     |      
     |          ip.link("add",
     |                  ifname="mvlan0",
     |                  kind="macvlan",
     |                  link=ip.link_lookup(ifname="em1")[0],
     |                  macvlan_mode="private").commit()
     |      
     |      Several macvlan modes are available: "private", "vepa", "bridge",
     |      "passthru". Ususally the default is "vepa".
     |      
     |      ► macvtap
     |      
     |      Almost the same as macvlan, but creates also a character tap device::
     |      
     |          ip.link("add",
     |                  ifname="mvtap0",
     |                  kind="macvtap",
     |                  link=ip.link_lookup(ifname="em1")[0],
     |                  macvtap_mode="vepa").commit()
     |      
     |      Will create a device file `"/dev/tap%s" % index`
     |      
     |      ► tuntap
     |      
     |      Possible `tuntap` keywords:
     |      
     |      * `mode` — "tun" or "tap"
     |      * `uid` — integer
     |      * `gid` — integer
     |      * `ifr` — dict of tuntap flags (see ifinfmsg:... tuntap_data)
     |      
     |      Create a tap interface::
     |      
     |          ip.link("add",
     |                  ifname="tap0",
     |                  kind="tuntap",
     |                  mode="tap")
     |      
     |      Tun/tap interfaces are created using `ioctl()`, but the library
     |      provides a transparent way to manage them using netlink API.
     |      
     |      ► veth
     |      
     |      To properly create `veth` interface, one should specify
     |      `peer` also, since `veth` interfaces are created in pairs::
     |      
     |          # simple call
     |          ip.link("add", ifname="v1p0", kind="veth", peer="v1p1")
     |      
     |          # set up specific veth peer attributes
     |          ip.link("add",
     |                  ifname="v1p0",
     |                  kind="veth",
     |                  peer={"ifname": "v1p1",
     |                        "net_ns_fd": "test_netns"})
     |      
     |      ► vlan
     |      
     |      VLAN interfaces require additional parameters, `vlan_id` and
     |      `link`, where `link` is a master interface to create VLAN on::
     |      
     |          ip.link("add",
     |                  ifname="v100",
     |                  kind="vlan",
     |                  link=ip.link_lookup(ifname="eth0")[0],
     |                  vlan_id=100)
     |      
     |      There is a possibility to create also 802.1ad interfaces::
     |      
     |          # create external vlan 802.1ad, s-tag
     |          ip.link("add",
     |                  ifname="v100s",
     |                  kind="vlan",
     |                  link=ip.link_lookup(ifname="eth0")[0],
     |                  vlan_id=100,
     |                  vlan_protocol=0x88a8)
     |      
     |          # create internal vlan 802.1q, c-tag
     |          ip.link("add",
     |                  ifname="v200c",
     |                  kind="vlan",
     |                  link=ip.link_lookup(ifname="v100s")[0],
     |                  vlan_id=200,
     |                  vlan_protocol=0x8100)
     |      
     |      
     |      ► vrf
     |      
     |      VRF interfaces (see linux/Documentation/networking/vrf.txt)::
     |      
     |          ip.link("add",
     |                  ifname="vrf-foo",
     |                  kind="vrf",
     |                  vrf_table=42)
     |      
     |      ► vxlan
     |      
     |      VXLAN interfaces are like VLAN ones, but require a bit more
     |      parameters::
     |      
     |          ip.link("add",
     |                  ifname="vx101",
     |                  kind="vxlan",
     |                  vxlan_link=ip.link_lookup(ifname="eth0")[0],
     |                  vxlan_id=101,
     |                  vxlan_group='239.1.1.1',
     |                  vxlan_ttl=16)
     |      
     |      All possible vxlan parameters are listed in the module
     |      `pyroute2.netlink.rtnl.ifinfmsg:... vxlan_data`.
     |      
     |      ► ipoib
     |      
     |      IPoIB driver provides an ability to create several ip interfaces
     |      on one interface.
     |      IPoIB interfaces requires the following parameter:
     |      
     |      `link` : The master interface to create IPoIB on.
     |      
     |      The following parameters can also be provided:
     |      
     |      * `pkey`- Inifiniband partition key the ip interface is associated with
     |      * `mode`- Underlying infiniband transport mode. One
     |        of:  ['datagram' ,'connected']
     |      * `umcast`- If set(1), multicast group membership for this interface is
     |        handled by user space.
     |      
     |      Example::
     |      
     |          ip.link("add",
     |                  ifname="ipoib1",
     |                  kind="ipoib",
     |                  link=ip.link_lookup(ifname="ib0")[0],
     |                  pkey=10)
     |      
     |      **set**
     |      
     |      Set interface attributes::
     |      
     |          # get interface index
     |          x = ip.link_lookup(ifname="eth0")[0]
     |          # put link down
     |          ip.link("set", index=x, state="down")
     |          # rename and set MAC addr
     |          ip.link("set", index=x, address="00:11:22:33:44:55", name="bala")
     |          # set MTU and TX queue length
     |          ip.link("set", index=x, mtu=1000, txqlen=2000)
     |          # bring link up
     |          ip.link("set", index=x, state="up")
     |      
     |      Seting bridge or tunnel attributes require `kind` to be
     |      specified in order to properly encode `IFLA_LINKINFO`::
     |      
     |          ip.link("set",
     |                  index=x,
     |                  kind="bridge",
     |                  br_forward_delay=2000)
     |      
     |          ip.link("set",
     |                  index=x,
     |                  kind="gre",
     |                  gre_local="10.0.0.1",
     |                  gre_remote="10.1.0.103")
     |      
     |      Keyword "state" is reserved. State can be "up" or "down",
     |      it is a shortcut::
     |      
     |          state="up":   flags=1, mask=1
     |          state="down": flags=0, mask=0
     |      
     |      SR-IOV virtual function setup::
     |      
     |          # get PF index
     |          x = ip.link_lookup(ifname="eth0")[0]
     |          # setup macaddr
     |          ip.link("set",
     |                  index=x,                          # PF index
     |                  vf={"vf": 0,                      # VF index
     |                      "mac": "00:11:22:33:44:55"})  # address
     |          # setup vlan
     |          ip.link("set",
     |                  index=x,           # PF index
     |                  vf={"vf": 0,       # VF index
     |                      "vlan": 100})  # the simplest case
     |          # setup QinQ
     |          ip.link("set",
     |                  index=x,                           # PF index
     |                  vf={"vf": 0,                       # VF index
     |                      "vlan": [{"vlan": 100,         # vlan id
     |                                "proto": 0x88a8},    # 802.1ad
     |                               {"vlan": 200,         # vlan id
     |                                "proto": 0x8100}]})  # 802.1q
     |      
     |      **update**
     |      
     |      Almost the same as `set`, except it uses different flags
     |      and message type. Mostly does the same, but in some cases
     |      differs. If you're not sure what to use, use `set`.
     |      
     |      **del**
     |      
     |      Destroy the interface::
     |      
     |          ip.link("del", index=ip.link_lookup(ifname="dummy0")[0])
     |      
     |      **dump**
     |      
     |      Dump info for all interfaces
     |      
     |      **get**
     |      
     |      Get specific interface info::
     |      
     |          ip.link("get", index=ip.link_lookup(ifname="br0")[0])
     |      
     |      Get extended attributes like SR-IOV setup::
     |      
     |          ip.link("get", index=3, ext_mask=1)
     |  
     |  link_lookup(self, match=None, **kwarg)
     |      Lookup interface index (indeces) by first level NLA
     |      value.
     |      
     |      Example::
     |      
     |          ip.link_lookup(address="52:54:00:9d:4e:3d")
     |          ip.link_lookup(ifname="lo")
     |          ip.link_lookup(operstate="UP")
     |      
     |      Please note, that link_lookup() returns list, not one
     |      value.
     |  
     |  list_link_kind(self)
     |  
     |  neigh(self, command, **kwarg)
     |      Neighbours operations, same as `ip neigh` or `bridge fdb`
     |      
     |      **add**
     |      
     |      Add a neighbour record, e.g.::
     |      
     |          from pyroute2 import IPRoute
     |          from pyroute2.netlink.rtnl import ndmsg
     |      
     |          # add a permanent record on veth0
     |          idx = ip.link_lookup(ifname='veth0')[0]
     |          ip.neigh('add',
     |                   dst='172.16.45.1',
     |                   lladdr='00:11:22:33:44:55',
     |                   ifindex=idx,
     |                   state=ndmsg.states['permanent'])
     |      
     |      **set**
     |      
     |      Set an existing record or create a new one, if it doesn't exist.
     |      The same as above, but the command is "set"::
     |      
     |          ip.neigh('set',
     |                   dst='172.16.45.1',
     |                   lladdr='00:11:22:33:44:55',
     |                   ifindex=idx,
     |                   state=ndmsg.states['permanent'])
     |      
     |      
     |      **change**
     |      
     |      Change an existing record. If the record doesn't exist, fail.
     |      
     |      **del**
     |      
     |      Delete an existing record.
     |      
     |      **dump**
     |      
     |      Dump all the records in the NDB::
     |      
     |          ip.neigh('dump')
     |      
     |      **get**
     |      
     |      Get specific record (dst and ifindex are mandatory). Available
     |      only on recent kernel::
     |      
     |          ip.neigh('get',
     |                   dst='172.16.45.1',
     |                   ifindex=idx)
     |  
     |  poll(self, method, command, timeout=10, interval=0.2, **spec)
     |      Run `method` with a positional argument `command` and keyword
     |      arguments `**spec` every `interval` seconds, but not more than
     |      `timeout`, until it returns a result which doesn't evaluate to
     |      `False`.
     |      
     |      Example:
     |      
     |      .. code-block:: python
     |      
     |          # create a bridge interface and wait for it:
     |          #
     |          spec = {
     |              'ifname': 'br0',
     |              'kind': 'bridge',
     |              'state': 'up',
     |              'br_stp_state': 1,
     |          }
     |          ipr.link('add', **spec)
     |          ret = ipr.poll(ipr.link, 'dump', **spec)
     |      
     |          assert ret[0].get('ifname') == 'br0'
     |          assert ret[0].get('state') == 'up'
     |          assert ret[0].get(('linkinfo', 'data', 'br_stp_state')) == 1
     |  
     |  register_link_kind(self, path=None, pkg=None, module=None)
     |  
     |  route(self, command, **kwarg)
     |      Route operations.
     |      
     |      Keywords to set up rtmsg fields:
     |      
     |      * dst_len, src_len -- destination and source mask(see `dst` below)
     |      * tos -- type of service
     |      * table -- routing table
     |      * proto -- `redirect`, `boot`, `static` (see `rt_proto`)
     |      * scope -- routing realm
     |      * type -- `unicast`, `local`, etc. (see `rt_type`)
     |      
     |      `pyroute2/netlink/rtnl/rtmsg.py` rtmsg.nla_map:
     |      
     |      * table -- routing table to use (default: 254)
     |      * gateway -- via address
     |      * prefsrc -- preferred source IP address
     |      * dst -- the same as `prefix`
     |      * iif -- incoming traffic interface
     |      * oif -- outgoing traffic interface
     |      
     |      etc.
     |      
     |      One can specify mask not as `dst_len`, but as a part of `dst`,
     |      e.g.: `dst="10.0.0.0/24"`.
     |      
     |      Commands:
     |      
     |      **add**
     |      
     |      Example::
     |      
     |          ipr.route("add", dst="10.0.0.0/24", gateway="192.168.0.1")
     |      
     |      ...
     |      
     |      More `route()` examples. Blackhole route::
     |      
     |          ipr.route(
     |              "add",
     |              dst="10.0.0.0/24",
     |              type="blackhole",
     |          )
     |      
     |      Create a route with metrics::
     |      
     |          ipr.route(
     |              "add",
     |              dst="172.16.0.0/24",
     |              gateway="10.0.0.10",
     |              metrics={
     |                  "mtu": 1400,
     |                  "hoplimit": 16,
     |              },
     |          )
     |      
     |      Multipath route::
     |      
     |          ipr.route(
     |              "add",
     |              dst="10.0.0.0/24",
     |              multipath=[
     |                  {"gateway": "192.168.0.1", "hops": 2},
     |                  {"gateway": "192.168.0.2", "hops": 1},
     |                  {"gateway": "192.168.0.3"},
     |              ],
     |          )
     |      
     |      MPLS lwtunnel on eth0::
     |      
     |          ipr.route(
     |              "add",
     |              dst="10.0.0.0/24",
     |              oif=ip.link_lookup(ifname="eth0"),
     |              encap={
     |                  "type": "mpls",
     |                  "labels": "200/300",
     |              },
     |          )
     |      
     |      IPv6 next hop for IPv4 dst::
     |      
     |          ipr.route(
     |              "add",
     |              prefsrc="10.127.30.4",
     |              dst="172.16.0.0/24",
     |              via={"family": AF_INET6, "addr": "fe80::1337"},
     |              oif=ipr.link_lookup(ifname="eth0"),
     |              table=100,
     |          )
     |      
     |      Create MPLS route: push label::
     |      
     |          # $ sudo modprobe mpls_router
     |          # $ sudo sysctl net.mpls.platform_labels=1024
     |          ipr.route(
     |              "add",
     |              family=AF_MPLS,
     |              oif=ipr.link_lookup(ifname="eth0"),
     |              dst=0x200,
     |              newdst=[0x200, 0x300],
     |          )
     |      
     |      MPLS multipath::
     |      
     |          ipr.route(
     |              "add",
     |              dst="10.0.0.0/24",
     |              table=20,
     |              multipath=[
     |                  {
     |                      "gateway": "192.168.0.1",
     |                      "encap": {"type": "mpls", "labels": 200},
     |                  },
     |                  {
     |                      "ifindex": ipr.link_lookup(ifname="eth0"),
     |                      "encap": {"type": "mpls", "labels": 300},
     |                  },
     |              ],
     |          )
     |      
     |      MPLS target can be int, string, dict or list::
     |      
     |          "labels": 300    # simple label
     |          "labels": "300"  # the same
     |          "labels": (200, 300)  # stacked
     |          "labels": "200/300"   # the same
     |      
     |          # explicit label definition
     |          "labels": {
     |              "bos": 1,
     |              "label": 300,
     |              "tc": 0,
     |              "ttl": 16,
     |          }
     |      
     |      Create SEG6 tunnel encap mode (kernel >= 4.10)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6",
     |                  "mode": "encap",
     |                  "segs": "2000::5,2000::6",
     |              },
     |          )
     |      
     |      Create SEG6 tunnel inline mode (kernel >= 4.10)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6",
     |                  "mode": "inline",
     |                  "segs": ["2000::5", "2000::6"],
     |              },
     |          )
     |      
     |      Create SEG6 tunnel inline mode with hmac (kernel >= 4.10)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:22::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6",
     |                  "mode": "inline",
     |                  "segs": "2000::5,2000::6,2000::7,2000::8",
     |                  "hmac": 0xf,
     |              },
     |          )
     |      
     |      Create SEG6 tunnel with ip4ip6 encapsulation (kernel >= 4.14)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="172.16.0.0/24",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6",
     |                  "mode": "encap",
     |                  "segs": "2000::5,2000::6",
     |              },
     |          )
     |      
     |      Create SEG6LOCAL tunnel End.DX4 action (kernel >= 4.14)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6local",
     |                  "action": "End.DX4",
     |                  "nh4": "172.16.0.10",
     |              },
     |          )
     |      
     |      Create SEG6LOCAL tunnel End.DT6 action (kernel >= 4.14)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6local",
     |                  "action": "End.DT6",
     |                  "table": "10",
     |              },
     |          )
     |      
     |      Create SEG6LOCAL tunnel End.DT4 action (kernel >= 5.11)::
     |      
     |          # $ sudo modprobe vrf
     |          # $ sudo sysctl -w net.vrf.strict_mode=1
     |          ipr.link(
     |              "add",
     |              ifname="vrf-foo",
     |              kind="vrf",
     |              vrf_table=10,
     |          )
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6local",
     |                  "action": "End.DT4",
     |                  "vrf_table": 10,
     |              },
     |          )
     |      
     |      Create SEG6LOCAL tunnel End.B6 action (kernel >= 4.14)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6local",
     |                  "action": "End.B6",
     |                  "srh": {"segs": "2000::5,2000::6"},
     |              },
     |          )
     |      
     |      Create SEG6LOCAL tunnel End.B6 action with hmac (kernel >= 4.14)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6local",
     |                  "action": "End.B6",
     |                  "srh": {
     |                      "segs": "2000::5,2000::6",
     |                      "hmac": 0xf,
     |                  },
     |              },
     |          )
     |      
     |      **change**, **replace**, **append**
     |      
     |      Commands `change`, `replace` and `append` have the same meanings
     |      as in ip-route(8): `change` modifies only existing route, while
     |      `replace` creates a new one, if there is no such route yet.
     |      `append` allows to create an IPv6 multipath route.
     |      
     |      **del**
     |      
     |      Remove the route. The same syntax as for **add**.
     |      
     |      **get**
     |      
     |      Get route by spec.
     |      
     |      **dump**
     |      
     |      Dump all routes.
     |  
     |  rule(self, command, **kwarg)
     |      Rule operations
     |      
     |          - command — add, delete
     |          - table — 0 < table id < 253
     |          - priority — 0 < rule's priority < 32766
     |          - action — type of rule, default 'FR_ACT_NOP' (see fibmsg.py)
     |          - rtscope — routing scope, default RT_SCOPE_UNIVERSE
     |              `(RT_SCOPE_UNIVERSE|RT_SCOPE_SITE|                RT_SCOPE_LINK|RT_SCOPE_HOST|RT_SCOPE_NOWHERE)`
     |          - family — rule's family (socket.AF_INET (default) or
     |              socket.AF_INET6)
     |          - src — IP source for Source Based (Policy Based) routing's rule
     |          - dst — IP for Destination Based (Policy Based) routing's rule
     |          - src_len — Mask for Source Based (Policy Based) routing's rule
     |          - dst_len — Mask for Destination Based (Policy Based) routing's
     |              rule
     |          - iifname — Input interface for Interface Based (Policy Based)
     |              routing's rule
     |          - oifname — Output interface for Interface Based (Policy Based)
     |              routing's rule
     |          - uid_range — Range of user identifiers, a string like "1000:1234"
     |          - dport_range — Range of destination ports, a string like "80-120"
     |          - sport_range — Range of source ports, as a string like "80-120"
     |      
     |      All packets route via table 10::
     |      
     |          # 32000: from all lookup 10
     |          # ...
     |          ip.rule('add', table=10, priority=32000)
     |      
     |      Default action::
     |      
     |          # 32001: from all lookup 11 unreachable
     |          # ...
     |          iproute.rule('add',
     |                       table=11,
     |                       priority=32001,
     |                       action='FR_ACT_UNREACHABLE')
     |      
     |      Use source address to choose a routing table::
     |      
     |          # 32004: from 10.64.75.141 lookup 14
     |          # ...
     |          iproute.rule('add',
     |                       table=14,
     |                       priority=32004,
     |                       src='10.64.75.141')
     |      
     |      Use dst address to choose a routing table::
     |      
     |          # 32005: from 10.64.75.141/24 lookup 15
     |          # ...
     |          iproute.rule('add',
     |                       table=15,
     |                       priority=32005,
     |                       dst='10.64.75.141',
     |                       dst_len=24)
     |      
     |      Match fwmark::
     |      
     |          # 32006: from 10.64.75.141 fwmark 0xa lookup 15
     |          # ...
     |          iproute.rule('add',
     |                       table=15,
     |                       priority=32006,
     |                       dst='10.64.75.141',
     |                       fwmark=10)
     |  
     |  stats(self, command, **kwarg)
     |      Stats prototype.
     |  
     |  tc(self, command, kind=None, index=0, handle=0, **kwarg)
     |      "Swiss knife" for traffic control. With the method you can
     |      add, delete or modify qdiscs, classes and filters.
     |      
     |      * command -- add or delete qdisc, class, filter.
     |      * kind -- a string identifier -- "sfq", "htb", "u32" and so on.
     |      * handle -- integer or string
     |      
     |      Command can be one of ("add", "del", "add-class", "del-class",
     |      "add-filter", "del-filter") (see `commands` dict in the code).
     |      
     |      Handle notice: traditional iproute2 notation, like "1:0", actually
     |      represents two parts in one four-bytes integer::
     |      
     |          1:0    ->    0x10000
     |          1:1    ->    0x10001
     |          ff:0   ->   0xff0000
     |          ffff:1 -> 0xffff0001
     |      
     |      Target notice: if your target is a class/qdisc that applies an
     |      algorithm that can only apply to upstream traffic profile, but your
     |      keys variable explicitly references a match that is only relevant for
     |      upstream traffic, the kernel will reject the filter.  Unless you're
     |      dealing with devices like IMQs
     |      
     |      For pyroute2 tc() you can use both forms: integer like 0xffff0000
     |      or string like 'ffff:0000'. By default, handle is 0, so you can add
     |      simple classless queues w/o need to specify handle. Ingress queue
     |      causes handle to be 0xffff0000.
     |      
     |      So, to set up sfq queue on interface 1, the function call
     |      will be like that::
     |      
     |          ip = IPRoute()
     |          ip.tc("add", "sfq", 1)
     |      
     |      Instead of string commands ("add", "del"...), you can use also
     |      module constants, `RTM_NEWQDISC`, `RTM_DELQDISC` and so on::
     |      
     |          ip = IPRoute()
     |          flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_CREATE | NLM_F_EXCL
     |          ip.tc((RTM_NEWQDISC, flags), "sfq", 1)
     |      
     |      It should be noted that "change", "change-class" and
     |      "change-filter" work like "replace", "replace-class" and
     |      "replace-filter", except they will fail if the node doesn't
     |      exist (while it would have been created by "replace"). This is
     |      not the same behaviour as with "tc" where "change" can be used
     |      to modify the value of some options while leaving the others
     |      unchanged. However, as not all entities support this
     |      operation, we believe the "change" commands as implemented
     |      here are more useful.
     |      
     |      
     |      Also available "modules" (returns tc plugins dict) and "help"
     |      commands::
     |      
     |          help(ip.tc("modules")["htb"])
     |          print(ip.tc("help", "htb"))
     |  
     |  unregister_link_kind(self, kind)
     |  
     |  vlan_filter(self, command, **kwarg)
     |      Vlan filters is another approach to support vlans in Linux.
     |      Before vlan filters were introduced, there was only one way
     |      to bridge vlans: one had to create vlan interfaces and
     |      then add them as ports::
     |      
     |                  +------+      +----------+
     |          net --> | eth0 | <--> | eth0.500 | <---+
     |                  +------+      +----------+     |
     |                                                 v
     |                  +------+                    +-----+
     |          net --> | eth1 |                    | br0 |
     |                  +------+                    +-----+
     |                                                 ^
     |                  +------+      +----------+     |
     |          net --> | eth2 | <--> | eth2.500 | <---+
     |                  +------+      +----------+
     |      
     |      It means that one has to create as many bridges, as there were
     |      vlans. Vlan filters allow to bridge together underlying interfaces
     |      and create vlans already on the bridge::
     |      
     |          # v500 label shows which interfaces have vlan filter
     |      
     |                  +------+ v500
     |          net --> | eth0 | <-------+
     |                  +------+         |
     |                                   v
     |                  +------+      +-----+    +---------+
     |          net --> | eth1 | <--> | br0 |<-->| br0v500 |
     |                  +------+      +-----+    +---------+
     |                                   ^
     |                  +------+ v500    |
     |          net --> | eth2 | <-------+
     |                  +------+
     |      
     |      In this example vlan 500 will be allowed only on ports `eth0` and
     |      `eth2`, though all three eth nics are bridged.
     |      
     |      Some example code::
     |      
     |          # create bridge
     |          ip.link("add",
     |                  ifname="br0",
     |                  kind="bridge")
     |      
     |          # attach a port
     |          ip.link("set",
     |                  index=ip.link_lookup(ifname="eth0")[0],
     |                  master=ip.link_lookup(ifname="br0")[0])
     |      
     |          # set vlan filter
     |          ip.vlan_filter("add",
     |                         index=ip.link_lookup(ifname="eth0")[0],
     |                         vlan_info={"vid": 500})
     |      
     |          # create vlan interface on the bridge
     |          ip.link("add",
     |                  ifname="br0v500",
     |                  kind="vlan",
     |                  link=ip.link_lookup(ifname="br0")[0],
     |                  vlan_id=500)
     |      
     |          # set all UP
     |          ip.link("set",
     |                  index=ip.link_lookup(ifname="br0")[0],
     |                  state="up")
     |          ip.link("set",
     |                  index=ip.link_lookup(ifname="br0v500")[0],
     |                  state="up")
     |          ip.link("set",
     |                  index=ip.link_lookup(ifname="eth0")[0],
     |                  state="up")
     |      
     |          # set IP address
     |          ip.addr("add",
     |                  index=ip.link_lookup(ifname="br0v500")[0],
     |                  address="172.16.5.2",
     |                  mask=24)
     |      
     |          Now all the traffic to the network 172.16.5.2/24 will go
     |          to vlan 500 only via ports that have such vlan filter.
     |      
     |      
     |      Required arguments for `vlan_filter()` -- `index` and `vlan_info`.
     |      Vlan info struct::
     |      
     |          {"vid": uint16,
     |           "flags": uint16}
     |      
     |      More details:
     |          * kernel:Documentation/networking/switchdev.txt
     |          * pyroute2.netlink.rtnl.ifinfmsg:... vlan_info
     |      
     |      One can specify `flags` as int or as a list of flag names:
     |          * `master` == 0x1
     |          * `pvid` == 0x2
     |          * `untagged` == 0x4
     |          * `range_begin` == 0x8
     |          * `range_end` == 0x10
     |          * `brentry` == 0x20
     |      
     |      E.g.::
     |      
     |          {"vid": 20,
     |           "flags": ["pvid", "untagged"]}
     |      
     |          # is equal to
     |          {"vid": 20,
     |           "flags": 6}
     |      
     |      Commands:
     |      
     |      **add**
     |      
     |      Add vlan filter to a bridge port. Example::
     |      
     |          ip.vlan_filter("add", index=2, vlan_info={"vid": 200})
     |      
     |      **del**
     |      
     |      Remove vlan filter from a bridge port. Example::
     |      
     |          ip.vlan_filter("del", index=2, vlan_info={"vid": 200})
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from RTNL_API:
     |  
     |  close_file(fd)
     |      Close a file that was previously opened with open_file().
     |  
     |  get_pid()
     |      Return the PID of the current process.
     |  
     |  open_file(path)
     |      Open a file (read only) and return its (fd, inode).
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.rtnl.iprsocket.IPRSocket:
     |  
     |  bind(self, *argv, **kwarg)
     |      Bind the socket to given multicast groups, using
     |      given pid.
     |      
     |          - If pid is None, use automatic port allocation
     |          - If pid == 0, use process' pid
     |          - If pid == <int>, use the value instead of pid
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.rtnl.iprsocket.IPRSocketBase:
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocket:
     |  
     |  __getattr__(self, attr)
     |  
     |  add_membership(self, group)
     |  
     |  close(self, code=104)
     |      Correctly close the socket and free all resources.
     |  
     |  drop_membership(self, group)
     |  
     |  post_init(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  buffer_thread_routine(self)
     |  
     |  clone(self)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request(self, msg, msg_type, msg_flags=769, terminate=None, callback=None, parser=None)
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  recv(self, *argv, **kwarg)
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  get(self, bufsize=65536, msg_seq=0, terminate=None, callback=None, noraise=False)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
    
    class IPSet(pyroute2.netlink.nlsocket.NetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  IPSet(version=None, attr_revision=None, nfgen_family=2)
     |  
     |  NFNetlink socket (family=NETLINK_NETFILTER).
     |  
     |  Implements API to the ipset functionality.
     |  
     |  Method resolution order:
     |      IPSet
     |      pyroute2.netlink.nlsocket.NetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, version=None, attr_revision=None, nfgen_family=2)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  add(self, name, entry, family=<AddressFamily.AF_INET: 2>, exclusive=True, comment=None, timeout=None, etype='ip', skbmark=None, skbprio=None, skbqueue=None, wildcard=False, **kwargs)
     |      Add a member to the ipset.
     |      
     |      etype is the entry type that you add to the ipset. It's related to
     |      the ipset type. For example, use "ip" for one hash:ip or bitmap:ip
     |      ipset.
     |      
     |      When your ipset store a tuple, like "hash:net,iface", you must use a
     |      comma a separator (etype="net,iface")
     |      
     |      entry is a string for "ip" and "net" objects. For ipset with several
     |      dimensions, you must use a tuple (or a list) of objects.
     |      
     |      "port" type is specific, since you can use integer of specialized
     |      containers like :class:`PortEntry` and :class:`PortRange`
     |      
     |      Examples::
     |      
     |          ipset = IPSet()
     |          ipset.create("foo", stype="hash:ip")
     |          ipset.add("foo", "198.51.100.1", etype="ip")
     |      
     |          ipset = IPSet()
     |          ipset.create("bar", stype="bitmap:port",
     |                       bitmap_ports_range=(1000, 2000))
     |          ipset.add("bar", 1001, etype="port")
     |          ipset.add("bar", PortRange(1500, 2000), etype="port")
     |      
     |          ipset = IPSet()
     |          import socket
     |          protocol = socket.getprotobyname("tcp")
     |          ipset.create("foobar", stype="hash:net,port")
     |          port_entry = PortEntry(80, protocol=protocol)
     |          ipset.add("foobar", ("198.51.100.0/24", port_entry),
     |                    etype="net,port")
     |      
     |      wildcard option enable kernel wildcard matching on interface
     |      name for net,iface entries.
     |  
     |  create(self, name, stype='hash:ip', family=<AddressFamily.AF_INET: 2>, exclusive=True, counters=False, comment=False, maxelem=None, forceadd=False, hashsize=None, timeout=None, bitmap_ports_range=None, size=None, skbinfo=False)
     |      Create an ipset `name` of type `stype`, by default
     |      `hash:ip`.
     |      
     |      Common ipset options are supported:
     |      
     |      * exclusive -- if set, raise an error if the ipset exists
     |      * counters -- enable data/packets counters
     |      * comment -- enable comments capability
     |      * maxelem -- max size of the ipset
     |      * forceadd -- you should refer to the ipset manpage
     |      * hashsize -- size of the hashtable (if any)
     |      * timeout -- enable and set a default value for entries (if not None)
     |      * bitmap_ports_range -- set the specified inclusive portrange for
     |                              the bitmap ipset structure (0, 65536)
     |      * size -- Size of the list:set, the default is 8
     |      * skbinfo -- enable skbinfo capability
     |  
     |  delete(self, name, entry, family=<AddressFamily.AF_INET: 2>, exclusive=True, etype='ip')
     |      Delete a member from the ipset.
     |      
     |      See :func:`add` method for more information on etype.
     |  
     |  destroy(self, name=None)
     |      Destroy one (when name is set) or all ipset (when name is None)
     |  
     |  flush(self, name=None)
     |      Flush all ipsets. When name is set, flush only this ipset.
     |  
     |  get_proto_version(self, version=6)
     |      Get supported protocol version by kernel.
     |      
     |      version parameter allow to set mandatory (but unused?)
     |      IPSET_ATTR_PROTOCOL netlink attribute in the request.
     |  
     |  get_set_byindex(self, index)
     |      Get a set by its index
     |  
     |  get_set_byname(self, name)
     |      Get a set by its name
     |  
     |  get_supported_revisions(self, stype, family=<AddressFamily.AF_INET: 2>)
     |      Return minimum and maximum of revisions supported by the kernel.
     |      
     |      Each ipset module (like hash:net, hash:ip, etc) has several
     |      revisions. Newer revisions often have more features or more
     |      performances. Thanks to this call, you can ask the kernel
     |      the list of supported revisions.
     |      
     |      You can manually set/force revisions used in IPSet constructor.
     |      
     |      Example::
     |      
     |          ipset = IPSet()
     |          ipset.get_supported_revisions("hash:net")
     |      
     |          ipset.get_supported_revisions("hash:net,port,net")
     |  
     |  headers(self, name, **kwargs)
     |      Get headers of the named ipset. It can be used to test if one ipset
     |      exists, since it returns a no such file or directory.
     |  
     |  list(self, *argv, **kwargs)
     |      List installed ipsets. If `name` is provided, list
     |      the named ipset or return an empty list.
     |      
     |      Be warned: netlink does not return an error if given name does not
     |      exit, you will receive an empty list.
     |  
     |  rename(self, name_src, name_dst)
     |      Rename the ipset.
     |  
     |  request(self, msg, msg_type, msg_flags=769, terminate=None)
     |  
     |  swap(self, set_a, set_b)
     |      Swap two ipsets. They must have compatible content type.
     |  
     |  test(self, name, entry, family=<AddressFamily.AF_INET: 2>, etype='ip')
     |      Test if entry is part of an ipset
     |      
     |      See :func:`add` method for more information on etype.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  attr_map = {'iface': 'IPSET_ATTR_IFACE', 'mark': 'IPSET_ATTR_MARK', 's...
     |  
     |  policy = {1: <class 'pyroute2.netlink.nfnetlink.ipset.ipset_msg'>, 7: ...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocket:
     |  
     |  __getattr__(self, attr)
     |  
     |  add_membership(self, group)
     |  
     |  bind(self, groups=0, pid=None, **kwarg)
     |      Bind the socket to given multicast groups, using
     |      given pid.
     |      
     |          - If pid is None, use automatic port allocation
     |          - If pid == 0, use process' pid
     |          - If pid == <int>, use the value instead of pid
     |  
     |  close(self, code=104)
     |      Correctly close the socket and free all resources.
     |  
     |  drop_membership(self, group)
     |  
     |  post_init(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  buffer_thread_routine(self)
     |  
     |  clone(self)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request(self, msg, msg_type, msg_flags=769, terminate=None, callback=None, parser=None)
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  recv(self, *argv, **kwarg)
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  get(self, bufsize=65536, msg_seq=0, terminate=None, callback=None, noraise=False)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class IW(pyroute2.netlink.nl80211.NL80211, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  IW(*argv, **kwarg)
     |  
     |  Low-level socket interface. Provides all the
     |  usual socket does, can be used in poll/select,
     |  doesn't create any implicit threads.
     |  
     |  Method resolution order:
     |      IW
     |      pyroute2.netlink.nl80211.NL80211
     |      pyroute2.netlink.generic.GenericNetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, *argv, **kwarg)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  add_interface(self, ifname, iftype, dev=None, phy=0)
     |      Create a virtual interface
     |      
     |          - ifname — name of the interface to create
     |          - iftype — interface type to create
     |          - dev — device index
     |          - phy — phy index
     |      
     |      One should specify `dev` (device index) or `phy`
     |      (phy index). If no one specified, phy == 0.
     |      
     |      `iftype` can be integer or string:
     |      
     |      1. adhoc
     |      2. station
     |      3. ap
     |      4. ap_vlan
     |      5. wds
     |      6. monitor
     |      7. mesh_point
     |      8. p2p_client
     |      9. p2p_go
     |      10. p2p_device
     |      11. ocb
     |  
     |  associate(self, ifindex, bssid, ssid, freq, info_elements=None)
     |      Send an Association request frame.
     |  
     |  authenticate(self, ifindex, bssid, ssid, freq, auth_type=0)
     |      Send an Authentication management frame.
     |  
     |  connect(self, ifindex, ssid, bssid=None)
     |      Connect to the ap with ssid and bssid
     |  
     |  deauthenticate(self, ifindex, bssid, reason_code=1)
     |      Send a Deauthentication management frame.
     |  
     |  del_interface(self, dev)
     |      Delete a virtual interface
     |      
     |          - dev — device index
     |  
     |  disassociate(self, ifindex, bssid, reason_code=3)
     |      Send a Disassociation management frame.
     |  
     |  disconnect(self, ifindex)
     |      Disconnect the device
     |  
     |  get_associated_bss(self, ifindex)
     |      Returns the same info like scan() does, but only about the
     |      currently associated BSS.
     |      
     |      Unlike scan(), it returns immediately and doesn't require root.
     |  
     |  get_interface_by_ifindex(self, ifindex)
     |      Get interface by ifindex ( use x.get_attr('NL80211_ATTR_IFINDEX')
     |  
     |  get_interface_by_phy(self, attr)
     |      Get interface by phy ( use x.get_attr('NL80211_ATTR_WIPHY') )
     |  
     |  get_interfaces_dict(self)
     |      Get interfaces dictionary
     |  
     |  get_interfaces_dump(self)
     |      Get interfaces dump
     |  
     |  get_regulatory_domain(self, attr=None)
     |      Get regulatory domain information. If attr specified, get regulatory
     |      domain information for this device
     |      ( use x.get_attr('NL80211_ATTR_WIPHY') ).
     |  
     |  get_stations(self, ifindex)
     |      Get stations by ifindex
     |  
     |  join_ibss(self, ifindex, ssid, freq, bssid=None, channel_fixed=False, width=None, center=None, center2=None)
     |      Connect to network by ssid
     |          - ifindex - IFINDEX of the interface to perform the connection
     |          - ssid - Service set identification
     |          - freq - Frequency in MHz
     |          - bssid - The MAC address of target interface
     |          - channel_fixed: Boolean flag
     |          - width - Channel width
     |          - center - Central frequency of the 40/80/160 MHz channel
     |          - center2 - Center frequency of second segment if 80P80
     |      
     |      If the flag of channel_fixed is True, one should specify both the width
     |      and center of the channel
     |      
     |      `width` can be integer of string:
     |      
     |      0. 20_noht
     |      1. 20
     |      2. 40
     |      3. 80
     |      4. 80p80
     |      5. 160
     |      6. 5
     |      7. 10
     |  
     |  leave_ibss(self, ifindex)
     |      Leave the IBSS -- the IBSS is determined by the network interface
     |  
     |  list_dev(self)
     |      Get list of all wifi network interfaces
     |  
     |  list_wiphy(self)
     |      Get list of all phy devices
     |  
     |  scan(self, ifindex, ssids=None, flush_cache=False)
     |      Trigger scan and get results.
     |      
     |      Triggering scan usually requires root, and can take a
     |      couple of seconds.
     |  
     |  set_regulatory_domain(self, alpha2)
     |      Set regulatory domain.
     |  
     |  set_tx_power(self, dev, mode, mbm=None)
     |      Set TX power of interface.
     |      
     |          - dev — device index
     |          - mode — TX power setting (0 - auto, 1 - limit, 2 - fixed)
     |          - mbm — TX power in mBm (dBm * 100)
     |  
     |  set_wiphy_netns_by_fd(self, wiphy, netns_fd)
     |      Set wiphy network namespace to namespace referenced by fd.
     |  
     |  set_wiphy_netns_by_pid(self, wiphy, pid)
     |      Set wiphy network namespace to process network namespace.
     |  
     |  survey(self, ifindex)
     |      Return the survey info.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nl80211.NL80211:
     |  
     |  bind(self, groups=0, **kwarg)
     |      Bind the socket and performs generic netlink
     |      proto lookup. The `proto` parameter is a string,
     |      like "TASKSTATS", `msg_class` is a class to
     |      parse messages with.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  add_membership(self, group)
     |  
     |  discovery(self, proto)
     |      Resolve generic netlink protocol -- takes a string
     |      as the only parameter, return protocol description
     |  
     |  drop_membership(self, group)
     |  
     |  get(self, *argv, **kwarg)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  nlm_request(self, *argv, **kwarg)
     |  
     |  policy(self, proto)
     |      Extract policy information for a generic netlink protocol -- takes
     |      a string as the only parameter, return protocol policy
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  prid
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  mcast_groups = {}
     |  
     |  module_err_level = 'error'
     |  
     |  module_err_message = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocket:
     |  
     |  __getattr__(self, attr)
     |  
     |  close(self, code=104)
     |      Correctly close the socket and free all resources.
     |  
     |  post_init(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  buffer_thread_routine(self)
     |  
     |  clone(self)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  recv(self, *argv, **kwarg)
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class L2tp(pyroute2.netlink.generic.GenericNetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  Low-level socket interface. Provides all the
     |  usual socket does, can be used in poll/select,
     |  doesn't create any implicit threads.
     |  
     |  Method resolution order:
     |      L2tp
     |      pyroute2.netlink.generic.GenericNetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  create_session(self, tunnel_id, session_id, peer_session_id=None, ifname=None, l2spec_type=None, cookie=None, peer_cookie=None, debug=None, seq=None, lns_mode=None, recv_timeout=None, pwtype=5)
     |      Add a new session to a tunnel
     |      :param tunnel_id: local tunnel id
     |      :param session_id: local session id
     |      :param peer_session_id: remote session id
     |      :param ifname: interface name
     |      :param l2spec_type: layer2 specific header type of the session
     |      :param cookie: local cookie value to be assigned to the session
     |      :param peer_cookie: remote cookie value to be assigned to the session
     |      :param debug: enable or disable debugging using kernel printk for the
     |                    session
     |      :param seq: controls sequence numbering to prevent or detect out of
     |                  order packets
     |      :param lns_mode: LNS mode
     |      :param recv_timeout: Reorder timeout
     |      :param pwtype: pseudowire type
     |      :return: netlink response
     |  
     |  create_tunnel(self, tunnel_id, peer_tunnel_id, protocol=3, remote=None, local=None, fd=None, encap='udp', udp_sport=None, udp_dport=None, udp_csum=None, udp6_csum_rx=None, udp6_csum_tx=None, debug=False)
     |      Create a new L2TP tunnel
     |      :param tunnel_id: local tunnel id
     |      :param peer_tunnel_id: remote tunnel id
     |      :param protocol: L2TP version
     |      :param remote: IP address of the remote peer
     |      :param local: IP address of the local interface
     |      :param fd: file descriptor of socket to use
     |      :param encap: encapsulation type of the tunnel (udp, ip)
     |      :param udp_sport: UDP source port to be used for the tunnel
     |      :param udp_dport: UDP destination port to be used for the tunnel
     |      :param udp_csum: control if IPv4 UDP checksums should be calculated and
     |                       checked
     |      :param udp6_csum_rx: control if IPv6 UDP rx checksums should be
     |                           calculated
     |      :param udp6_csum_tx: control if IPv6 UDP tx checksums should be
     |                           calculated
     |      :param debug: enable or disable debugging using kernel printk for the
     |                    tunnel
     |      :return: Netlink response
     |  
     |  delete_session(self, tunnel_id, session_id)
     |      Delete a session
     |      :param tunnel_id: tunnel id in which the session to be deleted is
     |                        located
     |      :param session_id: session id of the session to be deleted
     |      :return:z
     |  
     |  delete_tunnel(self, tunnel_id)
     |      Delete a tunnel
     |      :param tunnel_id: tunnel id of the tunnel to be deleted
     |      :return: netlink response
     |  
     |  get_session(self, tunnel_id=None, session_id=None)
     |      Get one or more sessions
     |      :param tunnel_id: tunnel id of the tunnel for which to show the
     |                        session(s)
     |      :param session_id: session id of the session to show, if not set all
     |                         sessions will be returned
     |      :return: netlink response
     |  
     |  get_tunnel(self, tunnel_id=None)
     |      Get one or more tunnels
     |      :param tunnel_id: tunnel id of the tunnel to show, if not set all
     |                        tunnels will be returned
     |      :return: netlink response
     |  
     |  modify_session(self, tunnel_id, session_id, debug=None, seq=None, lns_mode=None, recv_timeout=None)
     |      Modify an existing session
     |      :param tunnel_id: local tunnel id
     |      :param session_id: local session id
     |      :param debug: enable or disable debugging for the session
     |      :param seq: controls sequence numbering to prevent or detect out of
     |                  order packets
     |      :param lns_mode: LNS mode
     |      :param recv_timeout: Reorder timeout
     |      :return: netlink response
     |  
     |  modify_tunnel(self, tunnel_id, debug)
     |      Modify an existing L2TP tunnel
     |      :param tunnel_id: local tunnel id
     |      :param debug: enable or disable debugging using kernel printk for the
     |                    tunnel
     |      :return: netlink response
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  add_membership(self, group)
     |  
     |  bind(self, proto, msg_class, groups=0, pid=None, **kwarg)
     |      Bind the socket and performs generic netlink
     |      proto lookup. The `proto` parameter is a string,
     |      like "TASKSTATS", `msg_class` is a class to
     |      parse messages with.
     |  
     |  discovery(self, proto)
     |      Resolve generic netlink protocol -- takes a string
     |      as the only parameter, return protocol description
     |  
     |  drop_membership(self, group)
     |  
     |  get(self, *argv, **kwarg)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  nlm_request(self, *argv, **kwarg)
     |  
     |  policy(self, proto)
     |      Extract policy information for a generic netlink protocol -- takes
     |      a string as the only parameter, return protocol policy
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  prid
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  mcast_groups = {}
     |  
     |  module_err_level = 'error'
     |  
     |  module_err_message = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocket:
     |  
     |  __getattr__(self, attr)
     |  
     |  close(self, code=104)
     |      Correctly close the socket and free all resources.
     |  
     |  post_init(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  buffer_thread_routine(self)
     |  
     |  clone(self)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  recv(self, *argv, **kwarg)
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class MPTCP(pyroute2.netlink.generic.GenericNetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  MPTCP(ext_ack=True)
     |  
     |  Low-level socket interface. Provides all the
     |  usual socket does, can be used in poll/select,
     |  doesn't create any implicit threads.
     |  
     |  Method resolution order:
     |      MPTCP
     |      pyroute2.netlink.generic.GenericNetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, ext_ack=True)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  endpoint(self, cmd, **kwarg)
     |      Usage::
     |      
     |          mptcp.endpoint('show')
     |          mptcp.endpoint('add', addr='172.17.20.2')
     |          mptcp.endpoint('del', id=4)
     |          mptcp.endpoint('flush')
     |      
     |      Argument `addr` is equal to `addr4` and implies `family=AF_INET`,
     |      while `addr6` implies `family=AF_INET6`
     |  
     |  limits(self, cmd, **kwarg)
     |      Usage::
     |      
     |          mptcp.limits('show')
     |          mptcp.limits('set', subflows=10)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  add_membership(self, group)
     |  
     |  bind(self, proto, msg_class, groups=0, pid=None, **kwarg)
     |      Bind the socket and performs generic netlink
     |      proto lookup. The `proto` parameter is a string,
     |      like "TASKSTATS", `msg_class` is a class to
     |      parse messages with.
     |  
     |  discovery(self, proto)
     |      Resolve generic netlink protocol -- takes a string
     |      as the only parameter, return protocol description
     |  
     |  drop_membership(self, group)
     |  
     |  get(self, *argv, **kwarg)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  nlm_request(self, *argv, **kwarg)
     |  
     |  policy(self, proto)
     |      Extract policy information for a generic netlink protocol -- takes
     |      a string as the only parameter, return protocol policy
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  prid
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  mcast_groups = {}
     |  
     |  module_err_level = 'error'
     |  
     |  module_err_message = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocket:
     |  
     |  __getattr__(self, attr)
     |  
     |  close(self, code=104)
     |      Correctly close the socket and free all resources.
     |  
     |  post_init(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  buffer_thread_routine(self)
     |  
     |  clone(self)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  recv(self, *argv, **kwarg)
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class NDB(builtins.object)
     |  NDB(sources=None, localhost='localhost', db_provider='sqlite3', db_spec=':memory:', db_cleanup=True, rtnl_debug=False, log=False, auto_netns=False, libc=None, messenger=None)
     |  
     |  Methods defined here:
     |  
     |  __dbm__(self)
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  __init__(self, sources=None, localhost='localhost', db_provider='sqlite3', db_spec=':memory:', db_cleanup=True, rtnl_debug=False, log=False, auto_netns=False, libc=None, messenger=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __mm__(self)
     |  
     |  auth_proxy(self, auth_manager)
     |  
     |  backup(self, spec)
     |  
     |  begin(self)
     |  
     |  close(self)
     |  
     |  readonly(self)
     |  
     |  register_handler(self, event, handler)
     |  
     |  reload(self, kinds=None)
     |  
     |  unregister_handler(self, event, handler)
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  nsmanager
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class NFCTSocket(pyroute2.netlink.nlsocket.NetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  NFCTSocket(nfgen_family=<AddressFamily.AF_INET: 2>, **kwargs)
     |  
     |  Generic netlink socket.
     |  
     |  Method resolution order:
     |      NFCTSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, nfgen_family=<AddressFamily.AF_INET: 2>, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  conntrack_max_size(self)
     |  
     |  count(self)
     |  
     |  dump(self, mark=None, mark_mask=4294967295, tuple_orig=None, tuple_reply=None)
     |      Dump conntrack entries
     |      
     |      Several kernel side filtering are supported:
     |        * mark and mark_mask, for almost all kernel
     |        * tuple_orig and tuple_reply, since kernel 5.8 and newer.
     |          Warning: tuple_reply has a bug in kernel, fixed only recently.
     |      
     |      tuple_orig and tuple_reply are type NFCTAttrTuple.
     |      You can give only some attribute for filtering.
     |      
     |      Example::
     |          # Get only connections from 192.168.1.1
     |          filter = NFCTAttrTuple(saddr='192.168.1.1')
     |          ct.dump_entries(tuple_orig=filter)
     |      
     |          # Get HTTPS connections
     |          filter = NFCTAttrTuple(proto=socket.IPPROTO_TCP, dport=443)
     |          ct.dump_entries(tuple_orig=filter)
     |      
     |      Note that NFCTAttrTuple attributes are working like one AND operator.
     |      
     |      Example::
     |         # Get connections from 192.168.1.1 AND on port 443
     |         TCP = socket.IPPROTO_TCP
     |         filter = NFCTAttrTuple(saddr='192.168.1.1', proto=TCP, dport=443)
     |         ct.dump_entries(tuple_orig=filter)
     |  
     |  entry(self, cmd, **kwargs)
     |      Get or change a conntrack entry.
     |      
     |      Examples::
     |          # add an entry
     |          ct.entry('add', timeout=30,
     |                   tuple_orig=NFCTAttrTuple(
     |                       saddr='192.168.122.1', daddr='192.168.122.67',
     |                       proto=6, sport=34857, dport=5599),
     |                   tuple_reply=NFCTAttrTuple(
     |                       saddr='192.168.122.67', daddr='192.168.122.1',
     |                       proto=6, sport=5599, dport=34857))
     |      
     |          # set mark=5 on the matching entry
     |          ct.entry('set', mark=5,
     |                   tuple_orig=NFCTAttrTuple(
     |                       saddr='192.168.122.1', daddr='192.168.122.67',
     |                       proto=6, sport=34857, dport=5599))
     |      
     |          # get an entry
     |          ct.entry('get',
     |                   tuple_orig=NFCTAttrTuple(
     |                       saddr='192.168.122.1', daddr='192.168.122.67',
     |                       proto=6, sport=34857, dport=5599))
     |      
     |          # delete an entry
     |          ct.entry('del',
     |                   tuple_orig=NFCTAttrTuple(
     |                       saddr='192.168.122.1', daddr='192.168.122.67',
     |                       proto=6, sport=34857, dport=5599))
     |  
     |  flush(self, mark=None, mark_mask=None)
     |  
     |  request(self, msg, msg_type, **kwargs)
     |  
     |  stat(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  policy = {256: <class 'pyroute2.netlink.nfnetlink.nfctsocket.nfct_msg'...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocket:
     |  
     |  __getattr__(self, attr)
     |  
     |  add_membership(self, group)
     |  
     |  bind(self, groups=0, pid=None, **kwarg)
     |      Bind the socket to given multicast groups, using
     |      given pid.
     |      
     |          - If pid is None, use automatic port allocation
     |          - If pid == 0, use process' pid
     |          - If pid == <int>, use the value instead of pid
     |  
     |  close(self, code=104)
     |      Correctly close the socket and free all resources.
     |  
     |  drop_membership(self, group)
     |  
     |  post_init(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  buffer_thread_routine(self)
     |  
     |  clone(self)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request(self, msg, msg_type, msg_flags=769, terminate=None, callback=None, parser=None)
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  recv(self, *argv, **kwarg)
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  get(self, bufsize=65536, msg_seq=0, terminate=None, callback=None, noraise=False)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class NFTSocket(pyroute2.netlink.nlsocket.NetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  NFTSocket(version=1, attr_revision=0, nfgen_family=2)
     |  
     |  NFNetlink socket (family=NETLINK_NETFILTER).
     |  
     |  Implements API to the nftables functionality.
     |  
     |  Method resolution order:
     |      NFTSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, version=1, attr_revision=0, nfgen_family=2)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  begin(self)
     |  
     |  commit(self)
     |  
     |  request_get(self, msg, msg_type, msg_flags=769, terminate=None)
     |      Read-only requests do not require transactions. Just run
     |      the request and get an answer.
     |  
     |  request_put(self, msg, msg_type, msg_flags=1)
     |      Read-write requests.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  policy = {0: <class 'pyroute2.netlink.nfnetlink.nftsocket.nft_table_ms...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocket:
     |  
     |  __getattr__(self, attr)
     |  
     |  add_membership(self, group)
     |  
     |  bind(self, groups=0, pid=None, **kwarg)
     |      Bind the socket to given multicast groups, using
     |      given pid.
     |      
     |          - If pid is None, use automatic port allocation
     |          - If pid == 0, use process' pid
     |          - If pid == <int>, use the value instead of pid
     |  
     |  close(self, code=104)
     |      Correctly close the socket and free all resources.
     |  
     |  drop_membership(self, group)
     |  
     |  post_init(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  buffer_thread_routine(self)
     |  
     |  clone(self)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request(self, msg, msg_type, msg_flags=769, terminate=None, callback=None, parser=None)
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  recv(self, *argv, **kwarg)
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  get(self, bufsize=65536, msg_seq=0, terminate=None, callback=None, noraise=False)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class NFTables(pyroute2.netlink.nfnetlink.nftsocket.NFTSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  NFTables(version=1, attr_revision=0, nfgen_family=2)
     |  
     |  NFNetlink socket (family=NETLINK_NETFILTER).
     |  
     |  Implements API to the nftables functionality.
     |  
     |  Method resolution order:
     |      NFTables
     |      pyroute2.netlink.nfnetlink.nftsocket.NFTSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  chain(self, cmd, **kwarg)
     |      Example::
     |      
     |          #
     |          # default policy 'drop' for input
     |          #
     |          nft.chain('add',
     |                    table='test0',
     |                    name='test_chain0',
     |                    hook='input',
     |                    type='filter',
     |                    policy=0)
     |  
     |  get_chains(self)
     |  
     |  get_rules(self)
     |  
     |  get_sets(self)
     |  
     |  get_tables(self)
     |  
     |  rule(self, cmd, **kwarg)
     |      Example::
     |      
     |          from pyroute2.nftables.expressions import ipv4addr, verdict
     |          #
     |          # allow all traffic from 192.168.0.0/24
     |          #
     |          nft.rule('add',
     |                   table='test0',
     |                   chain='test_chain0',
     |                   expressions=(ipv4addr(src='192.168.0.0/24'),
     |                                verdict(code=1)))
     |  
     |  table(self, cmd, **kwarg)
     |      Example::
     |      
     |          nft.table('add', name='test0')
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nfnetlink.nftsocket.NFTSocket:
     |  
     |  __init__(self, version=1, attr_revision=0, nfgen_family=2)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  begin(self)
     |  
     |  commit(self)
     |  
     |  request_get(self, msg, msg_type, msg_flags=769, terminate=None)
     |      Read-only requests do not require transactions. Just run
     |      the request and get an answer.
     |  
     |  request_put(self, msg, msg_type, msg_flags=1)
     |      Read-write requests.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nfnetlink.nftsocket.NFTSocket:
     |  
     |  policy = {0: <class 'pyroute2.netlink.nfnetlink.nftsocket.nft_table_ms...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocket:
     |  
     |  __getattr__(self, attr)
     |  
     |  add_membership(self, group)
     |  
     |  bind(self, groups=0, pid=None, **kwarg)
     |      Bind the socket to given multicast groups, using
     |      given pid.
     |      
     |          - If pid is None, use automatic port allocation
     |          - If pid == 0, use process' pid
     |          - If pid == <int>, use the value instead of pid
     |  
     |  close(self, code=104)
     |      Correctly close the socket and free all resources.
     |  
     |  drop_membership(self, group)
     |  
     |  post_init(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  buffer_thread_routine(self)
     |  
     |  clone(self)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request(self, msg, msg_type, msg_flags=769, terminate=None, callback=None, parser=None)
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  recv(self, *argv, **kwarg)
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  get(self, bufsize=65536, msg_seq=0, terminate=None, callback=None, noraise=False)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class NL80211(pyroute2.netlink.generic.GenericNetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  Low-level socket interface. Provides all the
     |  usual socket does, can be used in poll/select,
     |  doesn't create any implicit threads.
     |  
     |  Method resolution order:
     |      NL80211
     |      pyroute2.netlink.generic.GenericNetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  bind(self, groups=0, **kwarg)
     |      Bind the socket and performs generic netlink
     |      proto lookup. The `proto` parameter is a string,
     |      like "TASKSTATS", `msg_class` is a class to
     |      parse messages with.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  add_membership(self, group)
     |  
     |  discovery(self, proto)
     |      Resolve generic netlink protocol -- takes a string
     |      as the only parameter, return protocol description
     |  
     |  drop_membership(self, group)
     |  
     |  get(self, *argv, **kwarg)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  nlm_request(self, *argv, **kwarg)
     |  
     |  policy(self, proto)
     |      Extract policy information for a generic netlink protocol -- takes
     |      a string as the only parameter, return protocol policy
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  prid
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  mcast_groups = {}
     |  
     |  module_err_level = 'error'
     |  
     |  module_err_message = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocket:
     |  
     |  __getattr__(self, attr)
     |  
     |  close(self, code=104)
     |      Correctly close the socket and free all resources.
     |  
     |  post_init(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  buffer_thread_routine(self)
     |  
     |  clone(self)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  recv(self, *argv, **kwarg)
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class NSPopen(ObjNS)
     |  NSPopen(nsname, *argv, **kwarg)
     |  
     |  A proxy class to run `Popen()` object in some network namespace.
     |  
     |  Sample to run `ip ad` command in `nsname` network namespace::
     |  
     |      nsp = NSPopen('nsname', ['ip', 'ad'], stdout=subprocess.PIPE)
     |      print(nsp.communicate())
     |      nsp.wait()
     |      nsp.release()
     |  
     |  The `NSPopen` class was intended to be a drop-in replacement
     |  for the `Popen` class, but there are still some important
     |  differences.
     |  
     |  The `NSPopen` object implicitly spawns a child python process
     |  to be run in the background in a network namespace. The target
     |  process specified as the argument of the `NSPopen` will be
     |  started in its turn from this child. Thus all the fd numbers
     |  of the running `NSPopen` object are meaningless in the context
     |  of the main process. Trying to operate on them, one will get
     |  'Bad file descriptor' in the best case or a system call working
     |  on a wrong file descriptor in the worst case. A possible
     |  solution would be to transfer file descriptors between the
     |  `NSPopen` object and the main process, but it is not implemented
     |  yet.
     |  
     |  The process' diagram for `NSPopen('test', ['ip', 'ad'])`::
     |  
     |      +---------------------+     +--------------+     +------------+
     |      | main python process |<--->| child python |<--->| netns test |
     |      | NSPopen()           |     | Popen()      |     | $ ip ad    |
     |      +---------------------+     +--------------+     +------------+
     |  
     |  As a workaround for the issue with file descriptors, some
     |  additional methods are available on file objects `stdin`,
     |  `stdout` and `stderr`. E.g., one can run fcntl calls::
     |  
     |      from fcntl import F_GETFL
     |      from pyroute2 import NSPopen
     |      from subprocess import PIPE
     |  
     |      proc = NSPopen('test', ['my_program'], stdout=PIPE)
     |      flags = proc.stdout.fcntl(F_GETFL)
     |  
     |  In that way one can use `fcntl()`, `ioctl()`, `flock()` and
     |  `lockf()` calls.
     |  
     |  Another additional method is `release()`, which can be used to
     |  explicitly stop the proxy process and release all the resources.
     |  
     |  Method resolution order:
     |      NSPopen
     |      ObjNS
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __del__ = proxy(*argv, **kwarg)
     |  
     |  __dir__(self)
     |      Default dir() implementation.
     |  
     |  __init__(self, nsname, *argv, **kwarg)
     |      The only differences from the `subprocess.Popen` init are:
     |      * `nsname` -- network namespace name
     |      * `flags` keyword argument
     |      
     |      All other arguments are passed directly to `subprocess.Popen`.
     |      
     |      Flags usage samples. Create a network namespace, if it doesn't
     |      exist yet::
     |      
     |          import os
     |          nsp = NSPopen('nsname', ['command'], flags=os.O_CREAT)
     |      
     |      Create a network namespace only if it doesn't exist, otherwise
     |      fail and raise an exception::
     |      
     |          import os
     |          nsp = NSPopen('nsname', ['command'], flags=os.O_CREAT | os.O_EXCL)
     |  
     |  communicate = proxy(*argv, **kwarg)
     |      Interact with process: Send data to stdin and close it.
     |      Read data from stdout and stderr, until end-of-file is
     |      reached.  Wait for process to terminate.
     |      
     |      The optional "input" argument should be data to be sent to the
     |      child process, or None, if no data should be sent to the child.
     |      communicate() returns a tuple (stdout, stderr).
     |      
     |      By default, all communication is in bytes, and therefore any
     |      "input" should be bytes, and the (stdout, stderr) will be bytes.
     |      If in text mode (indicated by self.text_mode), any "input" should
     |      be a string, and (stdout, stderr) will be strings decoded
     |      according to locale encoding, or by "encoding" if set. Text mode
     |      is triggered by setting any of text, encoding, errors or
     |      universal_newlines.
     |  
     |  kill = proxy(*argv, **kwarg)
     |      Kill the process with SIGKILL
     |  
     |  poll = proxy(*argv, **kwarg)
     |      Check if child process has terminated. Set and return returncode
     |      attribute.
     |  
     |  release(self)
     |      Explicitly stop the proxy process and release all the
     |      resources. The `NSPopen` object can not be used after
     |      the `release()` call.
     |  
     |  send_signal = proxy(*argv, **kwarg)
     |      Send a signal to the process.
     |  
     |  terminate = proxy(*argv, **kwarg)
     |      Terminate the process with SIGTERM
     |  
     |  wait = proxy(*argv, **kwarg)
     |      Wait for child process to terminate; returns self.returncode.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  universal_newlines
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ObjNS:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  __getattribute__(self, key)
     |      Return getattr(self, name).
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ObjNS:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class NetNS(pyroute2.iproute.linux.RTNL_API, pyroute2.remote.transport.RemoteSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  NetNS(netns, flags=64, target=None, libc=None, groups=67372509)
     |  
     |  NetNS is the IPRoute API with network namespace support.
     |  
     |  **Why not IPRoute?**
     |  
     |  The task to run netlink commands in some network namespace, being in
     |  another network namespace, requires the architecture, that differs
     |  too much from a simple Netlink socket.
     |  
     |  NetNS starts a proxy process in a network namespace and uses
     |  `multiprocessing` communication channels between the main and the proxy
     |  processes to route all `recv()` and `sendto()` requests/responses.
     |  
     |  **Any specific API calls?**
     |  
     |  Nope. `NetNS` supports all the same, that `IPRoute` does, in the same
     |  way. It provides full `socket`-compatible API and can be used in
     |  poll/select as well.
     |  
     |  The only difference is the `close()` call. In the case of `NetNS` it
     |  is **mandatory** to close the socket before exit.
     |  
     |  Method resolution order:
     |      NetNS
     |      pyroute2.iproute.linux.RTNL_API
     |      pyroute2.remote.transport.RemoteSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, netns, flags=64, target=None, libc=None, groups=67372509)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  clone(self)
     |  
     |  close(self, code=104)
     |  
     |  close_file(self, fd)
     |      Proxy the close_file method if we are the parent.
     |  
     |  get_pid(self)
     |      Proxy the get_pid method if we are the parent.
     |  
     |  open_file(self, path)
     |      Proxy the open_file method if we are the parent.
     |  
     |  post_init(self)
     |  
     |  remove(self)
     |      Try to remove this network namespace from the system.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.iproute.linux.RTNL_API:
     |  
     |  addr(self, command, *argv, **kwarg)
     |      Address operations
     |      
     |      * command -- add, delete, replace, dump
     |      * index -- device index
     |      * address -- IPv4 or IPv6 address
     |      * mask -- address mask
     |      * family -- socket.AF_INET for IPv4 or socket.AF_INET6 for IPv6
     |      * scope -- the address scope, see /etc/iproute2/rt_scopes
     |      * kwarg -- dictionary, any ifaddrmsg field or NLA
     |      
     |      Later the method signature will be changed to::
     |      
     |          def addr(self, command, match=None, **kwarg):
     |              # the method body
     |      
     |      So only keyword arguments (except of the command) will be accepted.
     |      The reason for this change is an unification of API.
     |      
     |      Example::
     |      
     |          idx = 62
     |          ip.addr('add', index=idx, address='10.0.0.1', mask=24)
     |          ip.addr('add', index=idx, address='10.0.0.2', mask=24)
     |      
     |      With more NLAs::
     |      
     |          # explicitly set broadcast address
     |          ip.addr('add', index=idx,
     |                  address='10.0.0.3',
     |                  broadcast='10.0.0.255',
     |                  prefixlen=24)
     |      
     |          # make the secondary address visible to ifconfig: add label
     |          ip.addr('add', index=idx,
     |                  address='10.0.0.4',
     |                  broadcast='10.0.0.255',
     |                  prefixlen=24,
     |                  label='eth0:1')
     |      
     |      Configure p2p address on an interface::
     |      
     |          ip.addr('add', index=idx,
     |                  address='10.1.1.2',
     |                  mask=24,
     |                  local='10.1.1.1')
     |  
     |  brport(self, command, **kwarg)
     |      Set bridge port parameters. Example::
     |      
     |          idx = ip.link_lookup(ifname='eth0')
     |          ip.brport("set", index=idx, unicast_flood=0, cost=200)
     |          ip.brport("show", index=idx)
     |      
     |      Possible keywords are NLA names for the `protinfo_bridge` class,
     |      without the prefix and in lower letters.
     |  
     |  dump(self, groups=None)
     |      Dump network objects.
     |      
     |      On OpenBSD:
     |      
     |      * get_links()
     |      * get_addr()
     |      * get_neighbours()
     |      * get_routes()
     |      
     |      On Linux:
     |      
     |      * get_links()
     |      * get_addr()
     |      * get_neighbours()
     |      * get_vlans()
     |      * dump FDB
     |      * IPv4 and IPv6 rules
     |  
     |  fdb(self, command, **kwarg)
     |      Bridge forwarding database management.
     |      
     |      More details:
     |          * kernel:Documentation/networking/switchdev.txt
     |          * pyroute2.netlink.rtnl.ndmsg
     |      
     |      **add**
     |      
     |      Add a new FDB record. Works in the same way as ARP cache
     |      management, but some additional NLAs can be used::
     |      
     |          # simple FDB record
     |          #
     |          ip.fdb('add',
     |                 ifindex=ip.link_lookup(ifname='br0')[0],
     |                 lladdr='00:11:22:33:44:55',
     |                 dst='10.0.0.1')
     |      
     |          # specify vlan
     |          # NB: vlan should exist on the device, use
     |          # `vlan_filter()`
     |          #
     |          ip.fdb('add',
     |                 ifindex=ip.link_lookup(ifname='br0')[0],
     |                 lladdr='00:11:22:33:44:55',
     |                 dst='10.0.0.1',
     |                 vlan=200)
     |      
     |          # specify vxlan id and port
     |          # NB: works only for vxlan devices, use
     |          # `link("add", kind="vxlan", ...)`
     |          #
     |          # if port is not specified, the default one is used
     |          # by the kernel.
     |          #
     |          # if vni (vxlan id) is equal to the device vni,
     |          # the kernel doesn't report it back
     |          #
     |          ip.fdb('add',
     |                 ifindex=ip.link_lookup(ifname='vx500')[0]
     |                 lladdr='00:11:22:33:44:55',
     |                 dst='10.0.0.1',
     |                 port=5678,
     |                 vni=600)
     |      
     |      **append**
     |      
     |      Append a new FDB record. The same syntax as for **add**.
     |      
     |      **del**
     |      
     |      Remove an existing FDB record. The same syntax as for **add**.
     |      
     |      **dump**
     |      
     |      Dump all the FDB records. If any `**kwarg` is provided,
     |      results will be filtered::
     |      
     |          # dump all the records
     |          ip.fdb('dump')
     |      
     |          # show only specific lladdr, dst, vlan etc.
     |          ip.fdb('dump', lladdr='00:11:22:33:44:55')
     |          ip.fdb('dump', dst='10.0.0.1')
     |          ip.fdb('dump', vlan=200)
     |  
     |  filter_messages(self, dump_filter, msgs)
     |      Filter messages using `dump_filter`. The filter might be a
     |      callable, then it will be called for every message in the list.
     |      Or it might be a dict, where keys are used to get values
     |      from messages, and dict values are used to match the message.
     |      
     |      The method might be called directly. It is also used by calls
     |      like `ipr.link('dump', ....)`, where keyword arguments work as
     |      `dump_filter` for `ipr.filter_messages()`.
     |      
     |      A callable `dump_filter` must return True or False:
     |      
     |      .. code-block:: python
     |      
     |          # get all links with names starting with eth:
     |          #
     |          ipr.filter_messages(
     |              lambda x: x.get_attr('IFLA_IFNAME').startswith('eth'),
     |              ipr.link('dump')
     |          )
     |      
     |      A dict `dump_filter` can have callables as values:
     |      
     |      .. code-block:: python
     |      
     |          # get all links with names starting with eth, and
     |          # MAC address in a database:
     |          #
     |          ipr.filter_messages(
     |              {
     |                  'ifname': lambda x: x.startswith('eth'),
     |                  'address': lambda x: x in database,
     |              },
     |              ipr.link('dump')
     |          )
     |      
     |      ... or constants to compare with:
     |      
     |      .. code-block:: python
     |      
     |          # get all links in state up:
     |          #
     |          ipr.filter_message({'state': 'up'}, ipr.link('dump'))
     |  
     |  flush_addr(self, *argv, **kwarg)
     |      Flush IP addresses.
     |      
     |      Examples::
     |      
     |          # flush all addresses on the interface with index 2:
     |          ipr.flush_addr(index=2)
     |      
     |          # flush all addresses with IFA_LABEL='eth0':
     |          ipr.flush_addr(label='eth0')
     |  
     |  flush_routes(self, *argv, **kwarg)
     |      Flush routes -- purge route records from a table.
     |      Arguments are the same as for `get_routes()`
     |      routine. Actually, this routine implements a pipe from
     |      `get_routes()` to `nlm_request()`.
     |  
     |  flush_rules(self, *argv, **kwarg)
     |      Flush rules. Please keep in mind, that by default the function
     |      operates on **all** rules of **all** families. To work only on
     |      IPv4 rules, one should explicitly specify `family=AF_INET`.
     |      
     |      Examples::
     |      
     |          # flush all IPv4 rule with priorities above 5 and below 32000
     |          ipr.flush_rules(family=AF_INET, priority=lambda x: 5 < x < 32000)
     |      
     |          # flush all IPv6 rules that point to table 250:
     |          ipr.flush_rules(family=socket.AF_INET6, table=250)
     |  
     |  get_addr(self, family=<AddressFamily.AF_UNSPEC: 0>, match=None, **kwarg)
     |      Dump addresses.
     |      
     |      If family is not specified, both AF_INET and AF_INET6 addresses
     |      will be dumped::
     |      
     |          # get all addresses
     |          ip.get_addr()
     |      
     |      It is possible to apply filters on the results::
     |      
     |          # get addresses for the 2nd interface
     |          ip.get_addr(index=2)
     |      
     |          # get addresses with IFA_LABEL == 'eth0'
     |          ip.get_addr(label='eth0')
     |      
     |          # get all the subnet addresses on the interface, identified
     |          # by broadcast address (should be explicitly specified upon
     |          # creation)
     |          ip.get_addr(index=2, broadcast='192.168.1.255')
     |      
     |      A custom predicate can be used as a filter::
     |      
     |          ip.get_addr(match=lambda x: x['index'] == 1)
     |  
     |  get_classes(self, index=0)
     |      Get classes for specified interface.
     |  
     |  get_default_routes(self, family=<AddressFamily.AF_UNSPEC: 0>, table=254)
     |      Get default routes
     |  
     |  get_filters(self, index=0, handle=0, parent=0)
     |      Get filters for specified interface, handle and parent.
     |  
     |  get_links(self, *argv, **kwarg)
     |      Get network interfaces.
     |      
     |      By default returns all interfaces. Arguments vector
     |      can contain interface indices or a special keyword
     |      'all'::
     |      
     |          ip.get_links()
     |          ip.get_links('all')
     |          ip.get_links(1, 2, 3)
     |      
     |          interfaces = [1, 2, 3]
     |          ip.get_links(*interfaces)
     |  
     |  get_neighbours(self, family=<AddressFamily.AF_UNSPEC: 0>, match=None, **kwarg)
     |      Dump ARP cache records.
     |      
     |      The `family` keyword sets the family for the request:
     |      e.g. `AF_INET` or `AF_INET6` for arp cache, `AF_BRIDGE`
     |      for fdb.
     |      
     |      If other keyword arguments not empty, they are used as
     |      filter. Also, one can explicitly set filter as a function
     |      with the `match` parameter.
     |      
     |      Examples::
     |      
     |          # get neighbours on the 3rd link:
     |          ip.get_neighbours(ifindex=3)
     |      
     |          # get a particular record by dst:
     |          ip.get_neighbours(dst='172.16.0.1')
     |      
     |          # get fdb records:
     |          ip.get_neighbours(AF_BRIDGE)
     |      
     |          # and filter them by a function:
     |          ip.get_neighbours(AF_BRIDGE, match=lambda x: x['state'] == 2)
     |  
     |  get_netns_info(self, list_proc=False)
     |      A prototype method to list available netns and associated
     |      interfaces. A bit weird to have it here and not under
     |      `pyroute2.netns`, but it uses RTNL to get all the info.
     |  
     |  get_netnsid(self, nsid=None, pid=None, fd=None, target_nsid=None)
     |      Return a dict containing the result of a RTM_GETNSID query.
     |      This loosely corresponds to the "ip netns list-id" command.
     |  
     |  get_ntables(self, family=<AddressFamily.AF_UNSPEC: 0>)
     |      Get neighbour tables
     |  
     |  get_qdiscs(self, index=None)
     |      Get all queue disciplines for all interfaces or for specified
     |      one.
     |  
     |  get_routes(self, family=255, match=None, **kwarg)
     |      Get all routes. You can specify the table. There
     |      are up to 4294967295 routing classes (tables), and the kernel
     |      returns all the routes on each request. So the
     |      routine filters routes from full output. Note the number of
     |      tables is increased from 255 in Linux 2.6+.
     |      
     |      Example::
     |      
     |          ip.get_routes()  # get all the routes for all families
     |          ip.get_routes(family=AF_INET6)  # get only IPv6 routes
     |          ip.get_routes(table=254)  # get routes from 254 table
     |      
     |      The default family=255 is a hack. Despite the specs,
     |      the kernel returns only IPv4 routes for AF_UNSPEC family.
     |      But it returns all the routes for all the families if one
     |      uses an invalid value here. Hack but true. And let's hope
     |      the kernel team will not fix this bug.
     |  
     |  get_rules(self, family=<AddressFamily.AF_UNSPEC: 0>, match=None, **kwarg)
     |      Get all rules. By default return all rules. To explicitly
     |      request the IPv4 rules use `family=AF_INET`.
     |      
     |      Example::
     |          ip.get_rules() # get all the rules for all families
     |          ip.get_rules(family=AF_INET6)  # get only IPv6 rules
     |  
     |  get_vlans(self, **kwarg)
     |      Dump available vlan info on bridge ports
     |  
     |  link(self, command, **kwarg)
     |      Link operations.
     |      
     |      Keywords to set up ifinfmsg fields:
     |          * index -- interface index
     |          * family -- AF_BRIDGE for bridge operations, otherwise 0
     |          * flags -- device flags
     |          * change -- change mask
     |      
     |      All other keywords will be translated to NLA names, e.g.
     |      `mtu -> IFLA_MTU`, `af_spec -> IFLA_AF_SPEC` etc. You can
     |      provide a complete NLA structure or let filters do it for
     |      you. E.g., these pairs show equal statements::
     |      
     |          # set device MTU
     |          ip.link("set", index=x, mtu=1000)
     |          ip.link("set", index=x, IFLA_MTU=1000)
     |      
     |          # add vlan device
     |          ip.link("add", ifname="test", kind="dummy")
     |          ip.link("add", ifname="test",
     |                  IFLA_LINKINFO={'attrs': [['IFLA_INFO_KIND', 'dummy']]})
     |      
     |      Filters are implemented in the `pyroute2.iproute.req` module.
     |      You can contribute your own if you miss shortcuts.
     |      
     |      Commands:
     |      
     |      **add**
     |      
     |      To create an interface, one should specify the interface kind::
     |      
     |          ip.link("add",
     |                  ifname="test",
     |                  kind="dummy")
     |      
     |      The kind can be any of those supported by kernel. It can be
     |      `dummy`, `bridge`, `bond` etc. On modern kernels one can specify
     |      even interface index::
     |      
     |          ip.link("add",
     |                  ifname="br-test",
     |                  kind="bridge",
     |                  index=2345)
     |      
     |      Specific type notes:
     |      
     |      ► geneve
     |      
     |      Create GENEVE tunnel::
     |      
     |          ip.link("add",
     |                  ifname="genx",
     |                  kind="geneve",
     |                  geneve_id=42,
     |                  geneve_remote="172.16.0.101")
     |      
     |      Support for GENEVE over IPv6 is also included; use `geneve_remote6`
     |      to configure a remote IPv6 address.
     |      
     |      ► gre
     |      
     |      Create GRE tunnel::
     |      
     |          ip.link("add",
     |                  ifname="grex",
     |                  kind="gre",
     |                  gre_local="172.16.0.1",
     |                  gre_remote="172.16.0.101",
     |                  gre_ttl=16)
     |      
     |      The keyed GRE requires explicit iflags/oflags specification::
     |      
     |          ip.link("add",
     |                  ifname="grex",
     |                  kind="gre",
     |                  gre_local="172.16.0.1",
     |                  gre_remote="172.16.0.101",
     |                  gre_ttl=16,
     |                  gre_ikey=10,
     |                  gre_okey=10,
     |                  gre_iflags=32,
     |                  gre_oflags=32)
     |      
     |      Support for GRE over IPv6 is also included; use `kind=ip6gre` and
     |      `ip6gre_` as the prefix for its values.
     |      
     |      ► ipip
     |      
     |      Create ipip tunnel::
     |      
     |          ip.link("add",
     |                  ifname="tun1",
     |                  kind="ipip",
     |                  ipip_local="172.16.0.1",
     |                  ipip_remote="172.16.0.101",
     |                  ipip_ttl=16)
     |      
     |      Support for sit and ip6tnl is also included; use `kind=sit` and `sit_`
     |      as prefix for sit tunnels, and `kind=ip6tnl` and `ip6tnl_` prefix for
     |      ip6tnl tunnels.
     |      
     |      ► macvlan
     |      
     |      Macvlan interfaces act like VLANs within OS. The macvlan driver
     |      provides an ability to add several MAC addresses on one interface,
     |      where every MAC address is reflected with a virtual interface in
     |      the system.
     |      
     |      In some setups macvlan interfaces can replace bridge interfaces,
     |      providing more simple and at the same time high-performance
     |      solution::
     |      
     |          ip.link("add",
     |                  ifname="mvlan0",
     |                  kind="macvlan",
     |                  link=ip.link_lookup(ifname="em1")[0],
     |                  macvlan_mode="private").commit()
     |      
     |      Several macvlan modes are available: "private", "vepa", "bridge",
     |      "passthru". Ususally the default is "vepa".
     |      
     |      ► macvtap
     |      
     |      Almost the same as macvlan, but creates also a character tap device::
     |      
     |          ip.link("add",
     |                  ifname="mvtap0",
     |                  kind="macvtap",
     |                  link=ip.link_lookup(ifname="em1")[0],
     |                  macvtap_mode="vepa").commit()
     |      
     |      Will create a device file `"/dev/tap%s" % index`
     |      
     |      ► tuntap
     |      
     |      Possible `tuntap` keywords:
     |      
     |      * `mode` — "tun" or "tap"
     |      * `uid` — integer
     |      * `gid` — integer
     |      * `ifr` — dict of tuntap flags (see ifinfmsg:... tuntap_data)
     |      
     |      Create a tap interface::
     |      
     |          ip.link("add",
     |                  ifname="tap0",
     |                  kind="tuntap",
     |                  mode="tap")
     |      
     |      Tun/tap interfaces are created using `ioctl()`, but the library
     |      provides a transparent way to manage them using netlink API.
     |      
     |      ► veth
     |      
     |      To properly create `veth` interface, one should specify
     |      `peer` also, since `veth` interfaces are created in pairs::
     |      
     |          # simple call
     |          ip.link("add", ifname="v1p0", kind="veth", peer="v1p1")
     |      
     |          # set up specific veth peer attributes
     |          ip.link("add",
     |                  ifname="v1p0",
     |                  kind="veth",
     |                  peer={"ifname": "v1p1",
     |                        "net_ns_fd": "test_netns"})
     |      
     |      ► vlan
     |      
     |      VLAN interfaces require additional parameters, `vlan_id` and
     |      `link`, where `link` is a master interface to create VLAN on::
     |      
     |          ip.link("add",
     |                  ifname="v100",
     |                  kind="vlan",
     |                  link=ip.link_lookup(ifname="eth0")[0],
     |                  vlan_id=100)
     |      
     |      There is a possibility to create also 802.1ad interfaces::
     |      
     |          # create external vlan 802.1ad, s-tag
     |          ip.link("add",
     |                  ifname="v100s",
     |                  kind="vlan",
     |                  link=ip.link_lookup(ifname="eth0")[0],
     |                  vlan_id=100,
     |                  vlan_protocol=0x88a8)
     |      
     |          # create internal vlan 802.1q, c-tag
     |          ip.link("add",
     |                  ifname="v200c",
     |                  kind="vlan",
     |                  link=ip.link_lookup(ifname="v100s")[0],
     |                  vlan_id=200,
     |                  vlan_protocol=0x8100)
     |      
     |      
     |      ► vrf
     |      
     |      VRF interfaces (see linux/Documentation/networking/vrf.txt)::
     |      
     |          ip.link("add",
     |                  ifname="vrf-foo",
     |                  kind="vrf",
     |                  vrf_table=42)
     |      
     |      ► vxlan
     |      
     |      VXLAN interfaces are like VLAN ones, but require a bit more
     |      parameters::
     |      
     |          ip.link("add",
     |                  ifname="vx101",
     |                  kind="vxlan",
     |                  vxlan_link=ip.link_lookup(ifname="eth0")[0],
     |                  vxlan_id=101,
     |                  vxlan_group='239.1.1.1',
     |                  vxlan_ttl=16)
     |      
     |      All possible vxlan parameters are listed in the module
     |      `pyroute2.netlink.rtnl.ifinfmsg:... vxlan_data`.
     |      
     |      ► ipoib
     |      
     |      IPoIB driver provides an ability to create several ip interfaces
     |      on one interface.
     |      IPoIB interfaces requires the following parameter:
     |      
     |      `link` : The master interface to create IPoIB on.
     |      
     |      The following parameters can also be provided:
     |      
     |      * `pkey`- Inifiniband partition key the ip interface is associated with
     |      * `mode`- Underlying infiniband transport mode. One
     |        of:  ['datagram' ,'connected']
     |      * `umcast`- If set(1), multicast group membership for this interface is
     |        handled by user space.
     |      
     |      Example::
     |      
     |          ip.link("add",
     |                  ifname="ipoib1",
     |                  kind="ipoib",
     |                  link=ip.link_lookup(ifname="ib0")[0],
     |                  pkey=10)
     |      
     |      **set**
     |      
     |      Set interface attributes::
     |      
     |          # get interface index
     |          x = ip.link_lookup(ifname="eth0")[0]
     |          # put link down
     |          ip.link("set", index=x, state="down")
     |          # rename and set MAC addr
     |          ip.link("set", index=x, address="00:11:22:33:44:55", name="bala")
     |          # set MTU and TX queue length
     |          ip.link("set", index=x, mtu=1000, txqlen=2000)
     |          # bring link up
     |          ip.link("set", index=x, state="up")
     |      
     |      Seting bridge or tunnel attributes require `kind` to be
     |      specified in order to properly encode `IFLA_LINKINFO`::
     |      
     |          ip.link("set",
     |                  index=x,
     |                  kind="bridge",
     |                  br_forward_delay=2000)
     |      
     |          ip.link("set",
     |                  index=x,
     |                  kind="gre",
     |                  gre_local="10.0.0.1",
     |                  gre_remote="10.1.0.103")
     |      
     |      Keyword "state" is reserved. State can be "up" or "down",
     |      it is a shortcut::
     |      
     |          state="up":   flags=1, mask=1
     |          state="down": flags=0, mask=0
     |      
     |      SR-IOV virtual function setup::
     |      
     |          # get PF index
     |          x = ip.link_lookup(ifname="eth0")[0]
     |          # setup macaddr
     |          ip.link("set",
     |                  index=x,                          # PF index
     |                  vf={"vf": 0,                      # VF index
     |                      "mac": "00:11:22:33:44:55"})  # address
     |          # setup vlan
     |          ip.link("set",
     |                  index=x,           # PF index
     |                  vf={"vf": 0,       # VF index
     |                      "vlan": 100})  # the simplest case
     |          # setup QinQ
     |          ip.link("set",
     |                  index=x,                           # PF index
     |                  vf={"vf": 0,                       # VF index
     |                      "vlan": [{"vlan": 100,         # vlan id
     |                                "proto": 0x88a8},    # 802.1ad
     |                               {"vlan": 200,         # vlan id
     |                                "proto": 0x8100}]})  # 802.1q
     |      
     |      **update**
     |      
     |      Almost the same as `set`, except it uses different flags
     |      and message type. Mostly does the same, but in some cases
     |      differs. If you're not sure what to use, use `set`.
     |      
     |      **del**
     |      
     |      Destroy the interface::
     |      
     |          ip.link("del", index=ip.link_lookup(ifname="dummy0")[0])
     |      
     |      **dump**
     |      
     |      Dump info for all interfaces
     |      
     |      **get**
     |      
     |      Get specific interface info::
     |      
     |          ip.link("get", index=ip.link_lookup(ifname="br0")[0])
     |      
     |      Get extended attributes like SR-IOV setup::
     |      
     |          ip.link("get", index=3, ext_mask=1)
     |  
     |  link_lookup(self, match=None, **kwarg)
     |      Lookup interface index (indeces) by first level NLA
     |      value.
     |      
     |      Example::
     |      
     |          ip.link_lookup(address="52:54:00:9d:4e:3d")
     |          ip.link_lookup(ifname="lo")
     |          ip.link_lookup(operstate="UP")
     |      
     |      Please note, that link_lookup() returns list, not one
     |      value.
     |  
     |  list_link_kind(self)
     |  
     |  neigh(self, command, **kwarg)
     |      Neighbours operations, same as `ip neigh` or `bridge fdb`
     |      
     |      **add**
     |      
     |      Add a neighbour record, e.g.::
     |      
     |          from pyroute2 import IPRoute
     |          from pyroute2.netlink.rtnl import ndmsg
     |      
     |          # add a permanent record on veth0
     |          idx = ip.link_lookup(ifname='veth0')[0]
     |          ip.neigh('add',
     |                   dst='172.16.45.1',
     |                   lladdr='00:11:22:33:44:55',
     |                   ifindex=idx,
     |                   state=ndmsg.states['permanent'])
     |      
     |      **set**
     |      
     |      Set an existing record or create a new one, if it doesn't exist.
     |      The same as above, but the command is "set"::
     |      
     |          ip.neigh('set',
     |                   dst='172.16.45.1',
     |                   lladdr='00:11:22:33:44:55',
     |                   ifindex=idx,
     |                   state=ndmsg.states['permanent'])
     |      
     |      
     |      **change**
     |      
     |      Change an existing record. If the record doesn't exist, fail.
     |      
     |      **del**
     |      
     |      Delete an existing record.
     |      
     |      **dump**
     |      
     |      Dump all the records in the NDB::
     |      
     |          ip.neigh('dump')
     |      
     |      **get**
     |      
     |      Get specific record (dst and ifindex are mandatory). Available
     |      only on recent kernel::
     |      
     |          ip.neigh('get',
     |                   dst='172.16.45.1',
     |                   ifindex=idx)
     |  
     |  poll(self, method, command, timeout=10, interval=0.2, **spec)
     |      Run `method` with a positional argument `command` and keyword
     |      arguments `**spec` every `interval` seconds, but not more than
     |      `timeout`, until it returns a result which doesn't evaluate to
     |      `False`.
     |      
     |      Example:
     |      
     |      .. code-block:: python
     |      
     |          # create a bridge interface and wait for it:
     |          #
     |          spec = {
     |              'ifname': 'br0',
     |              'kind': 'bridge',
     |              'state': 'up',
     |              'br_stp_state': 1,
     |          }
     |          ipr.link('add', **spec)
     |          ret = ipr.poll(ipr.link, 'dump', **spec)
     |      
     |          assert ret[0].get('ifname') == 'br0'
     |          assert ret[0].get('state') == 'up'
     |          assert ret[0].get(('linkinfo', 'data', 'br_stp_state')) == 1
     |  
     |  register_link_kind(self, path=None, pkg=None, module=None)
     |  
     |  route(self, command, **kwarg)
     |      Route operations.
     |      
     |      Keywords to set up rtmsg fields:
     |      
     |      * dst_len, src_len -- destination and source mask(see `dst` below)
     |      * tos -- type of service
     |      * table -- routing table
     |      * proto -- `redirect`, `boot`, `static` (see `rt_proto`)
     |      * scope -- routing realm
     |      * type -- `unicast`, `local`, etc. (see `rt_type`)
     |      
     |      `pyroute2/netlink/rtnl/rtmsg.py` rtmsg.nla_map:
     |      
     |      * table -- routing table to use (default: 254)
     |      * gateway -- via address
     |      * prefsrc -- preferred source IP address
     |      * dst -- the same as `prefix`
     |      * iif -- incoming traffic interface
     |      * oif -- outgoing traffic interface
     |      
     |      etc.
     |      
     |      One can specify mask not as `dst_len`, but as a part of `dst`,
     |      e.g.: `dst="10.0.0.0/24"`.
     |      
     |      Commands:
     |      
     |      **add**
     |      
     |      Example::
     |      
     |          ipr.route("add", dst="10.0.0.0/24", gateway="192.168.0.1")
     |      
     |      ...
     |      
     |      More `route()` examples. Blackhole route::
     |      
     |          ipr.route(
     |              "add",
     |              dst="10.0.0.0/24",
     |              type="blackhole",
     |          )
     |      
     |      Create a route with metrics::
     |      
     |          ipr.route(
     |              "add",
     |              dst="172.16.0.0/24",
     |              gateway="10.0.0.10",
     |              metrics={
     |                  "mtu": 1400,
     |                  "hoplimit": 16,
     |              },
     |          )
     |      
     |      Multipath route::
     |      
     |          ipr.route(
     |              "add",
     |              dst="10.0.0.0/24",
     |              multipath=[
     |                  {"gateway": "192.168.0.1", "hops": 2},
     |                  {"gateway": "192.168.0.2", "hops": 1},
     |                  {"gateway": "192.168.0.3"},
     |              ],
     |          )
     |      
     |      MPLS lwtunnel on eth0::
     |      
     |          ipr.route(
     |              "add",
     |              dst="10.0.0.0/24",
     |              oif=ip.link_lookup(ifname="eth0"),
     |              encap={
     |                  "type": "mpls",
     |                  "labels": "200/300",
     |              },
     |          )
     |      
     |      IPv6 next hop for IPv4 dst::
     |      
     |          ipr.route(
     |              "add",
     |              prefsrc="10.127.30.4",
     |              dst="172.16.0.0/24",
     |              via={"family": AF_INET6, "addr": "fe80::1337"},
     |              oif=ipr.link_lookup(ifname="eth0"),
     |              table=100,
     |          )
     |      
     |      Create MPLS route: push label::
     |      
     |          # $ sudo modprobe mpls_router
     |          # $ sudo sysctl net.mpls.platform_labels=1024
     |          ipr.route(
     |              "add",
     |              family=AF_MPLS,
     |              oif=ipr.link_lookup(ifname="eth0"),
     |              dst=0x200,
     |              newdst=[0x200, 0x300],
     |          )
     |      
     |      MPLS multipath::
     |      
     |          ipr.route(
     |              "add",
     |              dst="10.0.0.0/24",
     |              table=20,
     |              multipath=[
     |                  {
     |                      "gateway": "192.168.0.1",
     |                      "encap": {"type": "mpls", "labels": 200},
     |                  },
     |                  {
     |                      "ifindex": ipr.link_lookup(ifname="eth0"),
     |                      "encap": {"type": "mpls", "labels": 300},
     |                  },
     |              ],
     |          )
     |      
     |      MPLS target can be int, string, dict or list::
     |      
     |          "labels": 300    # simple label
     |          "labels": "300"  # the same
     |          "labels": (200, 300)  # stacked
     |          "labels": "200/300"   # the same
     |      
     |          # explicit label definition
     |          "labels": {
     |              "bos": 1,
     |              "label": 300,
     |              "tc": 0,
     |              "ttl": 16,
     |          }
     |      
     |      Create SEG6 tunnel encap mode (kernel >= 4.10)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6",
     |                  "mode": "encap",
     |                  "segs": "2000::5,2000::6",
     |              },
     |          )
     |      
     |      Create SEG6 tunnel inline mode (kernel >= 4.10)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6",
     |                  "mode": "inline",
     |                  "segs": ["2000::5", "2000::6"],
     |              },
     |          )
     |      
     |      Create SEG6 tunnel inline mode with hmac (kernel >= 4.10)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:22::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6",
     |                  "mode": "inline",
     |                  "segs": "2000::5,2000::6,2000::7,2000::8",
     |                  "hmac": 0xf,
     |              },
     |          )
     |      
     |      Create SEG6 tunnel with ip4ip6 encapsulation (kernel >= 4.14)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="172.16.0.0/24",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6",
     |                  "mode": "encap",
     |                  "segs": "2000::5,2000::6",
     |              },
     |          )
     |      
     |      Create SEG6LOCAL tunnel End.DX4 action (kernel >= 4.14)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6local",
     |                  "action": "End.DX4",
     |                  "nh4": "172.16.0.10",
     |              },
     |          )
     |      
     |      Create SEG6LOCAL tunnel End.DT6 action (kernel >= 4.14)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6local",
     |                  "action": "End.DT6",
     |                  "table": "10",
     |              },
     |          )
     |      
     |      Create SEG6LOCAL tunnel End.DT4 action (kernel >= 5.11)::
     |      
     |          # $ sudo modprobe vrf
     |          # $ sudo sysctl -w net.vrf.strict_mode=1
     |          ipr.link(
     |              "add",
     |              ifname="vrf-foo",
     |              kind="vrf",
     |              vrf_table=10,
     |          )
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6local",
     |                  "action": "End.DT4",
     |                  "vrf_table": 10,
     |              },
     |          )
     |      
     |      Create SEG6LOCAL tunnel End.B6 action (kernel >= 4.14)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6local",
     |                  "action": "End.B6",
     |                  "srh": {"segs": "2000::5,2000::6"},
     |              },
     |          )
     |      
     |      Create SEG6LOCAL tunnel End.B6 action with hmac (kernel >= 4.14)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6local",
     |                  "action": "End.B6",
     |                  "srh": {
     |                      "segs": "2000::5,2000::6",
     |                      "hmac": 0xf,
     |                  },
     |              },
     |          )
     |      
     |      **change**, **replace**, **append**
     |      
     |      Commands `change`, `replace` and `append` have the same meanings
     |      as in ip-route(8): `change` modifies only existing route, while
     |      `replace` creates a new one, if there is no such route yet.
     |      `append` allows to create an IPv6 multipath route.
     |      
     |      **del**
     |      
     |      Remove the route. The same syntax as for **add**.
     |      
     |      **get**
     |      
     |      Get route by spec.
     |      
     |      **dump**
     |      
     |      Dump all routes.
     |  
     |  rule(self, command, **kwarg)
     |      Rule operations
     |      
     |          - command — add, delete
     |          - table — 0 < table id < 253
     |          - priority — 0 < rule's priority < 32766
     |          - action — type of rule, default 'FR_ACT_NOP' (see fibmsg.py)
     |          - rtscope — routing scope, default RT_SCOPE_UNIVERSE
     |              `(RT_SCOPE_UNIVERSE|RT_SCOPE_SITE|                RT_SCOPE_LINK|RT_SCOPE_HOST|RT_SCOPE_NOWHERE)`
     |          - family — rule's family (socket.AF_INET (default) or
     |              socket.AF_INET6)
     |          - src — IP source for Source Based (Policy Based) routing's rule
     |          - dst — IP for Destination Based (Policy Based) routing's rule
     |          - src_len — Mask for Source Based (Policy Based) routing's rule
     |          - dst_len — Mask for Destination Based (Policy Based) routing's
     |              rule
     |          - iifname — Input interface for Interface Based (Policy Based)
     |              routing's rule
     |          - oifname — Output interface for Interface Based (Policy Based)
     |              routing's rule
     |          - uid_range — Range of user identifiers, a string like "1000:1234"
     |          - dport_range — Range of destination ports, a string like "80-120"
     |          - sport_range — Range of source ports, as a string like "80-120"
     |      
     |      All packets route via table 10::
     |      
     |          # 32000: from all lookup 10
     |          # ...
     |          ip.rule('add', table=10, priority=32000)
     |      
     |      Default action::
     |      
     |          # 32001: from all lookup 11 unreachable
     |          # ...
     |          iproute.rule('add',
     |                       table=11,
     |                       priority=32001,
     |                       action='FR_ACT_UNREACHABLE')
     |      
     |      Use source address to choose a routing table::
     |      
     |          # 32004: from 10.64.75.141 lookup 14
     |          # ...
     |          iproute.rule('add',
     |                       table=14,
     |                       priority=32004,
     |                       src='10.64.75.141')
     |      
     |      Use dst address to choose a routing table::
     |      
     |          # 32005: from 10.64.75.141/24 lookup 15
     |          # ...
     |          iproute.rule('add',
     |                       table=15,
     |                       priority=32005,
     |                       dst='10.64.75.141',
     |                       dst_len=24)
     |      
     |      Match fwmark::
     |      
     |          # 32006: from 10.64.75.141 fwmark 0xa lookup 15
     |          # ...
     |          iproute.rule('add',
     |                       table=15,
     |                       priority=32006,
     |                       dst='10.64.75.141',
     |                       fwmark=10)
     |  
     |  stats(self, command, **kwarg)
     |      Stats prototype.
     |  
     |  tc(self, command, kind=None, index=0, handle=0, **kwarg)
     |      "Swiss knife" for traffic control. With the method you can
     |      add, delete or modify qdiscs, classes and filters.
     |      
     |      * command -- add or delete qdisc, class, filter.
     |      * kind -- a string identifier -- "sfq", "htb", "u32" and so on.
     |      * handle -- integer or string
     |      
     |      Command can be one of ("add", "del", "add-class", "del-class",
     |      "add-filter", "del-filter") (see `commands` dict in the code).
     |      
     |      Handle notice: traditional iproute2 notation, like "1:0", actually
     |      represents two parts in one four-bytes integer::
     |      
     |          1:0    ->    0x10000
     |          1:1    ->    0x10001
     |          ff:0   ->   0xff0000
     |          ffff:1 -> 0xffff0001
     |      
     |      Target notice: if your target is a class/qdisc that applies an
     |      algorithm that can only apply to upstream traffic profile, but your
     |      keys variable explicitly references a match that is only relevant for
     |      upstream traffic, the kernel will reject the filter.  Unless you're
     |      dealing with devices like IMQs
     |      
     |      For pyroute2 tc() you can use both forms: integer like 0xffff0000
     |      or string like 'ffff:0000'. By default, handle is 0, so you can add
     |      simple classless queues w/o need to specify handle. Ingress queue
     |      causes handle to be 0xffff0000.
     |      
     |      So, to set up sfq queue on interface 1, the function call
     |      will be like that::
     |      
     |          ip = IPRoute()
     |          ip.tc("add", "sfq", 1)
     |      
     |      Instead of string commands ("add", "del"...), you can use also
     |      module constants, `RTM_NEWQDISC`, `RTM_DELQDISC` and so on::
     |      
     |          ip = IPRoute()
     |          flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_CREATE | NLM_F_EXCL
     |          ip.tc((RTM_NEWQDISC, flags), "sfq", 1)
     |      
     |      It should be noted that "change", "change-class" and
     |      "change-filter" work like "replace", "replace-class" and
     |      "replace-filter", except they will fail if the node doesn't
     |      exist (while it would have been created by "replace"). This is
     |      not the same behaviour as with "tc" where "change" can be used
     |      to modify the value of some options while leaving the others
     |      unchanged. However, as not all entities support this
     |      operation, we believe the "change" commands as implemented
     |      here are more useful.
     |      
     |      
     |      Also available "modules" (returns tc plugins dict) and "help"
     |      commands::
     |      
     |          help(ip.tc("modules")["htb"])
     |          print(ip.tc("help", "htb"))
     |  
     |  unregister_link_kind(self, kind)
     |  
     |  vlan_filter(self, command, **kwarg)
     |      Vlan filters is another approach to support vlans in Linux.
     |      Before vlan filters were introduced, there was only one way
     |      to bridge vlans: one had to create vlan interfaces and
     |      then add them as ports::
     |      
     |                  +------+      +----------+
     |          net --> | eth0 | <--> | eth0.500 | <---+
     |                  +------+      +----------+     |
     |                                                 v
     |                  +------+                    +-----+
     |          net --> | eth1 |                    | br0 |
     |                  +------+                    +-----+
     |                                                 ^
     |                  +------+      +----------+     |
     |          net --> | eth2 | <--> | eth2.500 | <---+
     |                  +------+      +----------+
     |      
     |      It means that one has to create as many bridges, as there were
     |      vlans. Vlan filters allow to bridge together underlying interfaces
     |      and create vlans already on the bridge::
     |      
     |          # v500 label shows which interfaces have vlan filter
     |      
     |                  +------+ v500
     |          net --> | eth0 | <-------+
     |                  +------+         |
     |                                   v
     |                  +------+      +-----+    +---------+
     |          net --> | eth1 | <--> | br0 |<-->| br0v500 |
     |                  +------+      +-----+    +---------+
     |                                   ^
     |                  +------+ v500    |
     |          net --> | eth2 | <-------+
     |                  +------+
     |      
     |      In this example vlan 500 will be allowed only on ports `eth0` and
     |      `eth2`, though all three eth nics are bridged.
     |      
     |      Some example code::
     |      
     |          # create bridge
     |          ip.link("add",
     |                  ifname="br0",
     |                  kind="bridge")
     |      
     |          # attach a port
     |          ip.link("set",
     |                  index=ip.link_lookup(ifname="eth0")[0],
     |                  master=ip.link_lookup(ifname="br0")[0])
     |      
     |          # set vlan filter
     |          ip.vlan_filter("add",
     |                         index=ip.link_lookup(ifname="eth0")[0],
     |                         vlan_info={"vid": 500})
     |      
     |          # create vlan interface on the bridge
     |          ip.link("add",
     |                  ifname="br0v500",
     |                  kind="vlan",
     |                  link=ip.link_lookup(ifname="br0")[0],
     |                  vlan_id=500)
     |      
     |          # set all UP
     |          ip.link("set",
     |                  index=ip.link_lookup(ifname="br0")[0],
     |                  state="up")
     |          ip.link("set",
     |                  index=ip.link_lookup(ifname="br0v500")[0],
     |                  state="up")
     |          ip.link("set",
     |                  index=ip.link_lookup(ifname="eth0")[0],
     |                  state="up")
     |      
     |          # set IP address
     |          ip.addr("add",
     |                  index=ip.link_lookup(ifname="br0v500")[0],
     |                  address="172.16.5.2",
     |                  mask=24)
     |      
     |          Now all the traffic to the network 172.16.5.2/24 will go
     |          to vlan 500 only via ports that have such vlan filter.
     |      
     |      
     |      Required arguments for `vlan_filter()` -- `index` and `vlan_info`.
     |      Vlan info struct::
     |      
     |          {"vid": uint16,
     |           "flags": uint16}
     |      
     |      More details:
     |          * kernel:Documentation/networking/switchdev.txt
     |          * pyroute2.netlink.rtnl.ifinfmsg:... vlan_info
     |      
     |      One can specify `flags` as int or as a list of flag names:
     |          * `master` == 0x1
     |          * `pvid` == 0x2
     |          * `untagged` == 0x4
     |          * `range_begin` == 0x8
     |          * `range_end` == 0x10
     |          * `brentry` == 0x20
     |      
     |      E.g.::
     |      
     |          {"vid": 20,
     |           "flags": ["pvid", "untagged"]}
     |      
     |          # is equal to
     |          {"vid": 20,
     |           "flags": 6}
     |      
     |      Commands:
     |      
     |      **add**
     |      
     |      Add vlan filter to a bridge port. Example::
     |      
     |          ip.vlan_filter("add", index=2, vlan_info={"vid": 200})
     |      
     |      **del**
     |      
     |      Remove vlan filter from a bridge port. Example::
     |      
     |          ip.vlan_filter("del", index=2, vlan_info={"vid": 200})
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pyroute2.iproute.linux.RTNL_API:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.remote.transport.RemoteSocket:
     |  
     |  bind(self, *argv, **kwarg)
     |  
     |  fileno(self)
     |  
     |  getsockopt(self, *argv, **kwarg)
     |  
     |  proxy(self, cmd, *argv, **kwarg)
     |  
     |  recv(self, bufsize, flags=0)
     |  
     |  send(self, *argv, **kwarg)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  setsockopt(self, *argv, **kwarg)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.remote.transport.RemoteSocket:
     |  
     |  remote_trnsp_in = None
     |  
     |  remote_trnsp_out = None
     |  
     |  trnsp_in = None
     |  
     |  trnsp_out = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  buffer_thread_routine(self)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request(self, msg, msg_type, msg_flags=769, terminate=None, callback=None, parser=None)
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  get(self, bufsize=65536, msg_seq=0, terminate=None, callback=None, noraise=False)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
    
    class NetlinkDecodeError(builtins.Exception)
     |  NetlinkDecodeError(exception)
     |  
     |  Base decoding error class.
     |  
     |  Incapsulates underlying error for the following analysis
     |  
     |  Method resolution order:
     |      NetlinkDecodeError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, exception)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class NetlinkDumpInterrupted(NetlinkError)
     |  NetlinkDumpInterrupted(code=-1, msg='dump interrupted')
     |  
     |  Raised when NLM_F_DUMP_INTR is set in the flags.
     |  
     |  Method resolution order:
     |      NetlinkDumpInterrupted
     |      NetlinkError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, code=-1, msg='dump interrupted')
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from NetlinkError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class NetlinkError(builtins.Exception)
     |  NetlinkError(code, msg=None)
     |  
     |  Base netlink error
     |  
     |  Method resolution order:
     |      NetlinkError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, code, msg=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class NoIPDB(builtins.object)
     |  NoIPDB(*argv, **kwarg)
     |  
     |  Methods defined here:
     |  
     |  __init__(self, *argv, **kwarg)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  create(self, *argv, **kwarg)
     |  
     |  release(self)
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  ipaddr
     |  
     |  nl
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  text_create = '\nIPDB has a shortcut method to create interfaces...s.c...
     |  
     |  text_nl = "\nUnlike IPDB, NDB can work with many netlink sou...alhost'...
    
    class PartialCommitException(builtins.Exception)
     |  Common base class for all non-exit exceptions.
     |  
     |  Method resolution order:
     |      PartialCommitException
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class RawIPRoute(RTNL_API, pyroute2.netlink.rtnl.riprsocket.RawIPRSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  RawIPRoute(*argv, **kwarg)
     |  
     |  The same as `IPRoute`, but does not use the netlink proxy.
     |  Thus it can not manage e.g. tun/tap interfaces.
     |  
     |  Method resolution order:
     |      RawIPRoute
     |      RTNL_API
     |      pyroute2.netlink.rtnl.riprsocket.RawIPRSocket
     |      pyroute2.netlink.rtnl.riprsocket.RawIPRSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Methods inherited from RTNL_API:
     |  
     |  __init__(self, *argv, **kwarg)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  addr(self, command, *argv, **kwarg)
     |      Address operations
     |      
     |      * command -- add, delete, replace, dump
     |      * index -- device index
     |      * address -- IPv4 or IPv6 address
     |      * mask -- address mask
     |      * family -- socket.AF_INET for IPv4 or socket.AF_INET6 for IPv6
     |      * scope -- the address scope, see /etc/iproute2/rt_scopes
     |      * kwarg -- dictionary, any ifaddrmsg field or NLA
     |      
     |      Later the method signature will be changed to::
     |      
     |          def addr(self, command, match=None, **kwarg):
     |              # the method body
     |      
     |      So only keyword arguments (except of the command) will be accepted.
     |      The reason for this change is an unification of API.
     |      
     |      Example::
     |      
     |          idx = 62
     |          ip.addr('add', index=idx, address='10.0.0.1', mask=24)
     |          ip.addr('add', index=idx, address='10.0.0.2', mask=24)
     |      
     |      With more NLAs::
     |      
     |          # explicitly set broadcast address
     |          ip.addr('add', index=idx,
     |                  address='10.0.0.3',
     |                  broadcast='10.0.0.255',
     |                  prefixlen=24)
     |      
     |          # make the secondary address visible to ifconfig: add label
     |          ip.addr('add', index=idx,
     |                  address='10.0.0.4',
     |                  broadcast='10.0.0.255',
     |                  prefixlen=24,
     |                  label='eth0:1')
     |      
     |      Configure p2p address on an interface::
     |      
     |          ip.addr('add', index=idx,
     |                  address='10.1.1.2',
     |                  mask=24,
     |                  local='10.1.1.1')
     |  
     |  brport(self, command, **kwarg)
     |      Set bridge port parameters. Example::
     |      
     |          idx = ip.link_lookup(ifname='eth0')
     |          ip.brport("set", index=idx, unicast_flood=0, cost=200)
     |          ip.brport("show", index=idx)
     |      
     |      Possible keywords are NLA names for the `protinfo_bridge` class,
     |      without the prefix and in lower letters.
     |  
     |  dump(self, groups=None)
     |      Dump network objects.
     |      
     |      On OpenBSD:
     |      
     |      * get_links()
     |      * get_addr()
     |      * get_neighbours()
     |      * get_routes()
     |      
     |      On Linux:
     |      
     |      * get_links()
     |      * get_addr()
     |      * get_neighbours()
     |      * get_vlans()
     |      * dump FDB
     |      * IPv4 and IPv6 rules
     |  
     |  fdb(self, command, **kwarg)
     |      Bridge forwarding database management.
     |      
     |      More details:
     |          * kernel:Documentation/networking/switchdev.txt
     |          * pyroute2.netlink.rtnl.ndmsg
     |      
     |      **add**
     |      
     |      Add a new FDB record. Works in the same way as ARP cache
     |      management, but some additional NLAs can be used::
     |      
     |          # simple FDB record
     |          #
     |          ip.fdb('add',
     |                 ifindex=ip.link_lookup(ifname='br0')[0],
     |                 lladdr='00:11:22:33:44:55',
     |                 dst='10.0.0.1')
     |      
     |          # specify vlan
     |          # NB: vlan should exist on the device, use
     |          # `vlan_filter()`
     |          #
     |          ip.fdb('add',
     |                 ifindex=ip.link_lookup(ifname='br0')[0],
     |                 lladdr='00:11:22:33:44:55',
     |                 dst='10.0.0.1',
     |                 vlan=200)
     |      
     |          # specify vxlan id and port
     |          # NB: works only for vxlan devices, use
     |          # `link("add", kind="vxlan", ...)`
     |          #
     |          # if port is not specified, the default one is used
     |          # by the kernel.
     |          #
     |          # if vni (vxlan id) is equal to the device vni,
     |          # the kernel doesn't report it back
     |          #
     |          ip.fdb('add',
     |                 ifindex=ip.link_lookup(ifname='vx500')[0]
     |                 lladdr='00:11:22:33:44:55',
     |                 dst='10.0.0.1',
     |                 port=5678,
     |                 vni=600)
     |      
     |      **append**
     |      
     |      Append a new FDB record. The same syntax as for **add**.
     |      
     |      **del**
     |      
     |      Remove an existing FDB record. The same syntax as for **add**.
     |      
     |      **dump**
     |      
     |      Dump all the FDB records. If any `**kwarg` is provided,
     |      results will be filtered::
     |      
     |          # dump all the records
     |          ip.fdb('dump')
     |      
     |          # show only specific lladdr, dst, vlan etc.
     |          ip.fdb('dump', lladdr='00:11:22:33:44:55')
     |          ip.fdb('dump', dst='10.0.0.1')
     |          ip.fdb('dump', vlan=200)
     |  
     |  filter_messages(self, dump_filter, msgs)
     |      Filter messages using `dump_filter`. The filter might be a
     |      callable, then it will be called for every message in the list.
     |      Or it might be a dict, where keys are used to get values
     |      from messages, and dict values are used to match the message.
     |      
     |      The method might be called directly. It is also used by calls
     |      like `ipr.link('dump', ....)`, where keyword arguments work as
     |      `dump_filter` for `ipr.filter_messages()`.
     |      
     |      A callable `dump_filter` must return True or False:
     |      
     |      .. code-block:: python
     |      
     |          # get all links with names starting with eth:
     |          #
     |          ipr.filter_messages(
     |              lambda x: x.get_attr('IFLA_IFNAME').startswith('eth'),
     |              ipr.link('dump')
     |          )
     |      
     |      A dict `dump_filter` can have callables as values:
     |      
     |      .. code-block:: python
     |      
     |          # get all links with names starting with eth, and
     |          # MAC address in a database:
     |          #
     |          ipr.filter_messages(
     |              {
     |                  'ifname': lambda x: x.startswith('eth'),
     |                  'address': lambda x: x in database,
     |              },
     |              ipr.link('dump')
     |          )
     |      
     |      ... or constants to compare with:
     |      
     |      .. code-block:: python
     |      
     |          # get all links in state up:
     |          #
     |          ipr.filter_message({'state': 'up'}, ipr.link('dump'))
     |  
     |  flush_addr(self, *argv, **kwarg)
     |      Flush IP addresses.
     |      
     |      Examples::
     |      
     |          # flush all addresses on the interface with index 2:
     |          ipr.flush_addr(index=2)
     |      
     |          # flush all addresses with IFA_LABEL='eth0':
     |          ipr.flush_addr(label='eth0')
     |  
     |  flush_routes(self, *argv, **kwarg)
     |      Flush routes -- purge route records from a table.
     |      Arguments are the same as for `get_routes()`
     |      routine. Actually, this routine implements a pipe from
     |      `get_routes()` to `nlm_request()`.
     |  
     |  flush_rules(self, *argv, **kwarg)
     |      Flush rules. Please keep in mind, that by default the function
     |      operates on **all** rules of **all** families. To work only on
     |      IPv4 rules, one should explicitly specify `family=AF_INET`.
     |      
     |      Examples::
     |      
     |          # flush all IPv4 rule with priorities above 5 and below 32000
     |          ipr.flush_rules(family=AF_INET, priority=lambda x: 5 < x < 32000)
     |      
     |          # flush all IPv6 rules that point to table 250:
     |          ipr.flush_rules(family=socket.AF_INET6, table=250)
     |  
     |  get_addr(self, family=<AddressFamily.AF_UNSPEC: 0>, match=None, **kwarg)
     |      Dump addresses.
     |      
     |      If family is not specified, both AF_INET and AF_INET6 addresses
     |      will be dumped::
     |      
     |          # get all addresses
     |          ip.get_addr()
     |      
     |      It is possible to apply filters on the results::
     |      
     |          # get addresses for the 2nd interface
     |          ip.get_addr(index=2)
     |      
     |          # get addresses with IFA_LABEL == 'eth0'
     |          ip.get_addr(label='eth0')
     |      
     |          # get all the subnet addresses on the interface, identified
     |          # by broadcast address (should be explicitly specified upon
     |          # creation)
     |          ip.get_addr(index=2, broadcast='192.168.1.255')
     |      
     |      A custom predicate can be used as a filter::
     |      
     |          ip.get_addr(match=lambda x: x['index'] == 1)
     |  
     |  get_classes(self, index=0)
     |      Get classes for specified interface.
     |  
     |  get_default_routes(self, family=<AddressFamily.AF_UNSPEC: 0>, table=254)
     |      Get default routes
     |  
     |  get_filters(self, index=0, handle=0, parent=0)
     |      Get filters for specified interface, handle and parent.
     |  
     |  get_links(self, *argv, **kwarg)
     |      Get network interfaces.
     |      
     |      By default returns all interfaces. Arguments vector
     |      can contain interface indices or a special keyword
     |      'all'::
     |      
     |          ip.get_links()
     |          ip.get_links('all')
     |          ip.get_links(1, 2, 3)
     |      
     |          interfaces = [1, 2, 3]
     |          ip.get_links(*interfaces)
     |  
     |  get_neighbours(self, family=<AddressFamily.AF_UNSPEC: 0>, match=None, **kwarg)
     |      Dump ARP cache records.
     |      
     |      The `family` keyword sets the family for the request:
     |      e.g. `AF_INET` or `AF_INET6` for arp cache, `AF_BRIDGE`
     |      for fdb.
     |      
     |      If other keyword arguments not empty, they are used as
     |      filter. Also, one can explicitly set filter as a function
     |      with the `match` parameter.
     |      
     |      Examples::
     |      
     |          # get neighbours on the 3rd link:
     |          ip.get_neighbours(ifindex=3)
     |      
     |          # get a particular record by dst:
     |          ip.get_neighbours(dst='172.16.0.1')
     |      
     |          # get fdb records:
     |          ip.get_neighbours(AF_BRIDGE)
     |      
     |          # and filter them by a function:
     |          ip.get_neighbours(AF_BRIDGE, match=lambda x: x['state'] == 2)
     |  
     |  get_netns_info(self, list_proc=False)
     |      A prototype method to list available netns and associated
     |      interfaces. A bit weird to have it here and not under
     |      `pyroute2.netns`, but it uses RTNL to get all the info.
     |  
     |  get_netnsid(self, nsid=None, pid=None, fd=None, target_nsid=None)
     |      Return a dict containing the result of a RTM_GETNSID query.
     |      This loosely corresponds to the "ip netns list-id" command.
     |  
     |  get_ntables(self, family=<AddressFamily.AF_UNSPEC: 0>)
     |      Get neighbour tables
     |  
     |  get_qdiscs(self, index=None)
     |      Get all queue disciplines for all interfaces or for specified
     |      one.
     |  
     |  get_routes(self, family=255, match=None, **kwarg)
     |      Get all routes. You can specify the table. There
     |      are up to 4294967295 routing classes (tables), and the kernel
     |      returns all the routes on each request. So the
     |      routine filters routes from full output. Note the number of
     |      tables is increased from 255 in Linux 2.6+.
     |      
     |      Example::
     |      
     |          ip.get_routes()  # get all the routes for all families
     |          ip.get_routes(family=AF_INET6)  # get only IPv6 routes
     |          ip.get_routes(table=254)  # get routes from 254 table
     |      
     |      The default family=255 is a hack. Despite the specs,
     |      the kernel returns only IPv4 routes for AF_UNSPEC family.
     |      But it returns all the routes for all the families if one
     |      uses an invalid value here. Hack but true. And let's hope
     |      the kernel team will not fix this bug.
     |  
     |  get_rules(self, family=<AddressFamily.AF_UNSPEC: 0>, match=None, **kwarg)
     |      Get all rules. By default return all rules. To explicitly
     |      request the IPv4 rules use `family=AF_INET`.
     |      
     |      Example::
     |          ip.get_rules() # get all the rules for all families
     |          ip.get_rules(family=AF_INET6)  # get only IPv6 rules
     |  
     |  get_vlans(self, **kwarg)
     |      Dump available vlan info on bridge ports
     |  
     |  link(self, command, **kwarg)
     |      Link operations.
     |      
     |      Keywords to set up ifinfmsg fields:
     |          * index -- interface index
     |          * family -- AF_BRIDGE for bridge operations, otherwise 0
     |          * flags -- device flags
     |          * change -- change mask
     |      
     |      All other keywords will be translated to NLA names, e.g.
     |      `mtu -> IFLA_MTU`, `af_spec -> IFLA_AF_SPEC` etc. You can
     |      provide a complete NLA structure or let filters do it for
     |      you. E.g., these pairs show equal statements::
     |      
     |          # set device MTU
     |          ip.link("set", index=x, mtu=1000)
     |          ip.link("set", index=x, IFLA_MTU=1000)
     |      
     |          # add vlan device
     |          ip.link("add", ifname="test", kind="dummy")
     |          ip.link("add", ifname="test",
     |                  IFLA_LINKINFO={'attrs': [['IFLA_INFO_KIND', 'dummy']]})
     |      
     |      Filters are implemented in the `pyroute2.iproute.req` module.
     |      You can contribute your own if you miss shortcuts.
     |      
     |      Commands:
     |      
     |      **add**
     |      
     |      To create an interface, one should specify the interface kind::
     |      
     |          ip.link("add",
     |                  ifname="test",
     |                  kind="dummy")
     |      
     |      The kind can be any of those supported by kernel. It can be
     |      `dummy`, `bridge`, `bond` etc. On modern kernels one can specify
     |      even interface index::
     |      
     |          ip.link("add",
     |                  ifname="br-test",
     |                  kind="bridge",
     |                  index=2345)
     |      
     |      Specific type notes:
     |      
     |      ► geneve
     |      
     |      Create GENEVE tunnel::
     |      
     |          ip.link("add",
     |                  ifname="genx",
     |                  kind="geneve",
     |                  geneve_id=42,
     |                  geneve_remote="172.16.0.101")
     |      
     |      Support for GENEVE over IPv6 is also included; use `geneve_remote6`
     |      to configure a remote IPv6 address.
     |      
     |      ► gre
     |      
     |      Create GRE tunnel::
     |      
     |          ip.link("add",
     |                  ifname="grex",
     |                  kind="gre",
     |                  gre_local="172.16.0.1",
     |                  gre_remote="172.16.0.101",
     |                  gre_ttl=16)
     |      
     |      The keyed GRE requires explicit iflags/oflags specification::
     |      
     |          ip.link("add",
     |                  ifname="grex",
     |                  kind="gre",
     |                  gre_local="172.16.0.1",
     |                  gre_remote="172.16.0.101",
     |                  gre_ttl=16,
     |                  gre_ikey=10,
     |                  gre_okey=10,
     |                  gre_iflags=32,
     |                  gre_oflags=32)
     |      
     |      Support for GRE over IPv6 is also included; use `kind=ip6gre` and
     |      `ip6gre_` as the prefix for its values.
     |      
     |      ► ipip
     |      
     |      Create ipip tunnel::
     |      
     |          ip.link("add",
     |                  ifname="tun1",
     |                  kind="ipip",
     |                  ipip_local="172.16.0.1",
     |                  ipip_remote="172.16.0.101",
     |                  ipip_ttl=16)
     |      
     |      Support for sit and ip6tnl is also included; use `kind=sit` and `sit_`
     |      as prefix for sit tunnels, and `kind=ip6tnl` and `ip6tnl_` prefix for
     |      ip6tnl tunnels.
     |      
     |      ► macvlan
     |      
     |      Macvlan interfaces act like VLANs within OS. The macvlan driver
     |      provides an ability to add several MAC addresses on one interface,
     |      where every MAC address is reflected with a virtual interface in
     |      the system.
     |      
     |      In some setups macvlan interfaces can replace bridge interfaces,
     |      providing more simple and at the same time high-performance
     |      solution::
     |      
     |          ip.link("add",
     |                  ifname="mvlan0",
     |                  kind="macvlan",
     |                  link=ip.link_lookup(ifname="em1")[0],
     |                  macvlan_mode="private").commit()
     |      
     |      Several macvlan modes are available: "private", "vepa", "bridge",
     |      "passthru". Ususally the default is "vepa".
     |      
     |      ► macvtap
     |      
     |      Almost the same as macvlan, but creates also a character tap device::
     |      
     |          ip.link("add",
     |                  ifname="mvtap0",
     |                  kind="macvtap",
     |                  link=ip.link_lookup(ifname="em1")[0],
     |                  macvtap_mode="vepa").commit()
     |      
     |      Will create a device file `"/dev/tap%s" % index`
     |      
     |      ► tuntap
     |      
     |      Possible `tuntap` keywords:
     |      
     |      * `mode` — "tun" or "tap"
     |      * `uid` — integer
     |      * `gid` — integer
     |      * `ifr` — dict of tuntap flags (see ifinfmsg:... tuntap_data)
     |      
     |      Create a tap interface::
     |      
     |          ip.link("add",
     |                  ifname="tap0",
     |                  kind="tuntap",
     |                  mode="tap")
     |      
     |      Tun/tap interfaces are created using `ioctl()`, but the library
     |      provides a transparent way to manage them using netlink API.
     |      
     |      ► veth
     |      
     |      To properly create `veth` interface, one should specify
     |      `peer` also, since `veth` interfaces are created in pairs::
     |      
     |          # simple call
     |          ip.link("add", ifname="v1p0", kind="veth", peer="v1p1")
     |      
     |          # set up specific veth peer attributes
     |          ip.link("add",
     |                  ifname="v1p0",
     |                  kind="veth",
     |                  peer={"ifname": "v1p1",
     |                        "net_ns_fd": "test_netns"})
     |      
     |      ► vlan
     |      
     |      VLAN interfaces require additional parameters, `vlan_id` and
     |      `link`, where `link` is a master interface to create VLAN on::
     |      
     |          ip.link("add",
     |                  ifname="v100",
     |                  kind="vlan",
     |                  link=ip.link_lookup(ifname="eth0")[0],
     |                  vlan_id=100)
     |      
     |      There is a possibility to create also 802.1ad interfaces::
     |      
     |          # create external vlan 802.1ad, s-tag
     |          ip.link("add",
     |                  ifname="v100s",
     |                  kind="vlan",
     |                  link=ip.link_lookup(ifname="eth0")[0],
     |                  vlan_id=100,
     |                  vlan_protocol=0x88a8)
     |      
     |          # create internal vlan 802.1q, c-tag
     |          ip.link("add",
     |                  ifname="v200c",
     |                  kind="vlan",
     |                  link=ip.link_lookup(ifname="v100s")[0],
     |                  vlan_id=200,
     |                  vlan_protocol=0x8100)
     |      
     |      
     |      ► vrf
     |      
     |      VRF interfaces (see linux/Documentation/networking/vrf.txt)::
     |      
     |          ip.link("add",
     |                  ifname="vrf-foo",
     |                  kind="vrf",
     |                  vrf_table=42)
     |      
     |      ► vxlan
     |      
     |      VXLAN interfaces are like VLAN ones, but require a bit more
     |      parameters::
     |      
     |          ip.link("add",
     |                  ifname="vx101",
     |                  kind="vxlan",
     |                  vxlan_link=ip.link_lookup(ifname="eth0")[0],
     |                  vxlan_id=101,
     |                  vxlan_group='239.1.1.1',
     |                  vxlan_ttl=16)
     |      
     |      All possible vxlan parameters are listed in the module
     |      `pyroute2.netlink.rtnl.ifinfmsg:... vxlan_data`.
     |      
     |      ► ipoib
     |      
     |      IPoIB driver provides an ability to create several ip interfaces
     |      on one interface.
     |      IPoIB interfaces requires the following parameter:
     |      
     |      `link` : The master interface to create IPoIB on.
     |      
     |      The following parameters can also be provided:
     |      
     |      * `pkey`- Inifiniband partition key the ip interface is associated with
     |      * `mode`- Underlying infiniband transport mode. One
     |        of:  ['datagram' ,'connected']
     |      * `umcast`- If set(1), multicast group membership for this interface is
     |        handled by user space.
     |      
     |      Example::
     |      
     |          ip.link("add",
     |                  ifname="ipoib1",
     |                  kind="ipoib",
     |                  link=ip.link_lookup(ifname="ib0")[0],
     |                  pkey=10)
     |      
     |      **set**
     |      
     |      Set interface attributes::
     |      
     |          # get interface index
     |          x = ip.link_lookup(ifname="eth0")[0]
     |          # put link down
     |          ip.link("set", index=x, state="down")
     |          # rename and set MAC addr
     |          ip.link("set", index=x, address="00:11:22:33:44:55", name="bala")
     |          # set MTU and TX queue length
     |          ip.link("set", index=x, mtu=1000, txqlen=2000)
     |          # bring link up
     |          ip.link("set", index=x, state="up")
     |      
     |      Seting bridge or tunnel attributes require `kind` to be
     |      specified in order to properly encode `IFLA_LINKINFO`::
     |      
     |          ip.link("set",
     |                  index=x,
     |                  kind="bridge",
     |                  br_forward_delay=2000)
     |      
     |          ip.link("set",
     |                  index=x,
     |                  kind="gre",
     |                  gre_local="10.0.0.1",
     |                  gre_remote="10.1.0.103")
     |      
     |      Keyword "state" is reserved. State can be "up" or "down",
     |      it is a shortcut::
     |      
     |          state="up":   flags=1, mask=1
     |          state="down": flags=0, mask=0
     |      
     |      SR-IOV virtual function setup::
     |      
     |          # get PF index
     |          x = ip.link_lookup(ifname="eth0")[0]
     |          # setup macaddr
     |          ip.link("set",
     |                  index=x,                          # PF index
     |                  vf={"vf": 0,                      # VF index
     |                      "mac": "00:11:22:33:44:55"})  # address
     |          # setup vlan
     |          ip.link("set",
     |                  index=x,           # PF index
     |                  vf={"vf": 0,       # VF index
     |                      "vlan": 100})  # the simplest case
     |          # setup QinQ
     |          ip.link("set",
     |                  index=x,                           # PF index
     |                  vf={"vf": 0,                       # VF index
     |                      "vlan": [{"vlan": 100,         # vlan id
     |                                "proto": 0x88a8},    # 802.1ad
     |                               {"vlan": 200,         # vlan id
     |                                "proto": 0x8100}]})  # 802.1q
     |      
     |      **update**
     |      
     |      Almost the same as `set`, except it uses different flags
     |      and message type. Mostly does the same, but in some cases
     |      differs. If you're not sure what to use, use `set`.
     |      
     |      **del**
     |      
     |      Destroy the interface::
     |      
     |          ip.link("del", index=ip.link_lookup(ifname="dummy0")[0])
     |      
     |      **dump**
     |      
     |      Dump info for all interfaces
     |      
     |      **get**
     |      
     |      Get specific interface info::
     |      
     |          ip.link("get", index=ip.link_lookup(ifname="br0")[0])
     |      
     |      Get extended attributes like SR-IOV setup::
     |      
     |          ip.link("get", index=3, ext_mask=1)
     |  
     |  link_lookup(self, match=None, **kwarg)
     |      Lookup interface index (indeces) by first level NLA
     |      value.
     |      
     |      Example::
     |      
     |          ip.link_lookup(address="52:54:00:9d:4e:3d")
     |          ip.link_lookup(ifname="lo")
     |          ip.link_lookup(operstate="UP")
     |      
     |      Please note, that link_lookup() returns list, not one
     |      value.
     |  
     |  list_link_kind(self)
     |  
     |  neigh(self, command, **kwarg)
     |      Neighbours operations, same as `ip neigh` or `bridge fdb`
     |      
     |      **add**
     |      
     |      Add a neighbour record, e.g.::
     |      
     |          from pyroute2 import IPRoute
     |          from pyroute2.netlink.rtnl import ndmsg
     |      
     |          # add a permanent record on veth0
     |          idx = ip.link_lookup(ifname='veth0')[0]
     |          ip.neigh('add',
     |                   dst='172.16.45.1',
     |                   lladdr='00:11:22:33:44:55',
     |                   ifindex=idx,
     |                   state=ndmsg.states['permanent'])
     |      
     |      **set**
     |      
     |      Set an existing record or create a new one, if it doesn't exist.
     |      The same as above, but the command is "set"::
     |      
     |          ip.neigh('set',
     |                   dst='172.16.45.1',
     |                   lladdr='00:11:22:33:44:55',
     |                   ifindex=idx,
     |                   state=ndmsg.states['permanent'])
     |      
     |      
     |      **change**
     |      
     |      Change an existing record. If the record doesn't exist, fail.
     |      
     |      **del**
     |      
     |      Delete an existing record.
     |      
     |      **dump**
     |      
     |      Dump all the records in the NDB::
     |      
     |          ip.neigh('dump')
     |      
     |      **get**
     |      
     |      Get specific record (dst and ifindex are mandatory). Available
     |      only on recent kernel::
     |      
     |          ip.neigh('get',
     |                   dst='172.16.45.1',
     |                   ifindex=idx)
     |  
     |  poll(self, method, command, timeout=10, interval=0.2, **spec)
     |      Run `method` with a positional argument `command` and keyword
     |      arguments `**spec` every `interval` seconds, but not more than
     |      `timeout`, until it returns a result which doesn't evaluate to
     |      `False`.
     |      
     |      Example:
     |      
     |      .. code-block:: python
     |      
     |          # create a bridge interface and wait for it:
     |          #
     |          spec = {
     |              'ifname': 'br0',
     |              'kind': 'bridge',
     |              'state': 'up',
     |              'br_stp_state': 1,
     |          }
     |          ipr.link('add', **spec)
     |          ret = ipr.poll(ipr.link, 'dump', **spec)
     |      
     |          assert ret[0].get('ifname') == 'br0'
     |          assert ret[0].get('state') == 'up'
     |          assert ret[0].get(('linkinfo', 'data', 'br_stp_state')) == 1
     |  
     |  register_link_kind(self, path=None, pkg=None, module=None)
     |  
     |  route(self, command, **kwarg)
     |      Route operations.
     |      
     |      Keywords to set up rtmsg fields:
     |      
     |      * dst_len, src_len -- destination and source mask(see `dst` below)
     |      * tos -- type of service
     |      * table -- routing table
     |      * proto -- `redirect`, `boot`, `static` (see `rt_proto`)
     |      * scope -- routing realm
     |      * type -- `unicast`, `local`, etc. (see `rt_type`)
     |      
     |      `pyroute2/netlink/rtnl/rtmsg.py` rtmsg.nla_map:
     |      
     |      * table -- routing table to use (default: 254)
     |      * gateway -- via address
     |      * prefsrc -- preferred source IP address
     |      * dst -- the same as `prefix`
     |      * iif -- incoming traffic interface
     |      * oif -- outgoing traffic interface
     |      
     |      etc.
     |      
     |      One can specify mask not as `dst_len`, but as a part of `dst`,
     |      e.g.: `dst="10.0.0.0/24"`.
     |      
     |      Commands:
     |      
     |      **add**
     |      
     |      Example::
     |      
     |          ipr.route("add", dst="10.0.0.0/24", gateway="192.168.0.1")
     |      
     |      ...
     |      
     |      More `route()` examples. Blackhole route::
     |      
     |          ipr.route(
     |              "add",
     |              dst="10.0.0.0/24",
     |              type="blackhole",
     |          )
     |      
     |      Create a route with metrics::
     |      
     |          ipr.route(
     |              "add",
     |              dst="172.16.0.0/24",
     |              gateway="10.0.0.10",
     |              metrics={
     |                  "mtu": 1400,
     |                  "hoplimit": 16,
     |              },
     |          )
     |      
     |      Multipath route::
     |      
     |          ipr.route(
     |              "add",
     |              dst="10.0.0.0/24",
     |              multipath=[
     |                  {"gateway": "192.168.0.1", "hops": 2},
     |                  {"gateway": "192.168.0.2", "hops": 1},
     |                  {"gateway": "192.168.0.3"},
     |              ],
     |          )
     |      
     |      MPLS lwtunnel on eth0::
     |      
     |          ipr.route(
     |              "add",
     |              dst="10.0.0.0/24",
     |              oif=ip.link_lookup(ifname="eth0"),
     |              encap={
     |                  "type": "mpls",
     |                  "labels": "200/300",
     |              },
     |          )
     |      
     |      IPv6 next hop for IPv4 dst::
     |      
     |          ipr.route(
     |              "add",
     |              prefsrc="10.127.30.4",
     |              dst="172.16.0.0/24",
     |              via={"family": AF_INET6, "addr": "fe80::1337"},
     |              oif=ipr.link_lookup(ifname="eth0"),
     |              table=100,
     |          )
     |      
     |      Create MPLS route: push label::
     |      
     |          # $ sudo modprobe mpls_router
     |          # $ sudo sysctl net.mpls.platform_labels=1024
     |          ipr.route(
     |              "add",
     |              family=AF_MPLS,
     |              oif=ipr.link_lookup(ifname="eth0"),
     |              dst=0x200,
     |              newdst=[0x200, 0x300],
     |          )
     |      
     |      MPLS multipath::
     |      
     |          ipr.route(
     |              "add",
     |              dst="10.0.0.0/24",
     |              table=20,
     |              multipath=[
     |                  {
     |                      "gateway": "192.168.0.1",
     |                      "encap": {"type": "mpls", "labels": 200},
     |                  },
     |                  {
     |                      "ifindex": ipr.link_lookup(ifname="eth0"),
     |                      "encap": {"type": "mpls", "labels": 300},
     |                  },
     |              ],
     |          )
     |      
     |      MPLS target can be int, string, dict or list::
     |      
     |          "labels": 300    # simple label
     |          "labels": "300"  # the same
     |          "labels": (200, 300)  # stacked
     |          "labels": "200/300"   # the same
     |      
     |          # explicit label definition
     |          "labels": {
     |              "bos": 1,
     |              "label": 300,
     |              "tc": 0,
     |              "ttl": 16,
     |          }
     |      
     |      Create SEG6 tunnel encap mode (kernel >= 4.10)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6",
     |                  "mode": "encap",
     |                  "segs": "2000::5,2000::6",
     |              },
     |          )
     |      
     |      Create SEG6 tunnel inline mode (kernel >= 4.10)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6",
     |                  "mode": "inline",
     |                  "segs": ["2000::5", "2000::6"],
     |              },
     |          )
     |      
     |      Create SEG6 tunnel inline mode with hmac (kernel >= 4.10)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:22::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6",
     |                  "mode": "inline",
     |                  "segs": "2000::5,2000::6,2000::7,2000::8",
     |                  "hmac": 0xf,
     |              },
     |          )
     |      
     |      Create SEG6 tunnel with ip4ip6 encapsulation (kernel >= 4.14)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="172.16.0.0/24",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6",
     |                  "mode": "encap",
     |                  "segs": "2000::5,2000::6",
     |              },
     |          )
     |      
     |      Create SEG6LOCAL tunnel End.DX4 action (kernel >= 4.14)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6local",
     |                  "action": "End.DX4",
     |                  "nh4": "172.16.0.10",
     |              },
     |          )
     |      
     |      Create SEG6LOCAL tunnel End.DT6 action (kernel >= 4.14)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6local",
     |                  "action": "End.DT6",
     |                  "table": "10",
     |              },
     |          )
     |      
     |      Create SEG6LOCAL tunnel End.DT4 action (kernel >= 5.11)::
     |      
     |          # $ sudo modprobe vrf
     |          # $ sudo sysctl -w net.vrf.strict_mode=1
     |          ipr.link(
     |              "add",
     |              ifname="vrf-foo",
     |              kind="vrf",
     |              vrf_table=10,
     |          )
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6local",
     |                  "action": "End.DT4",
     |                  "vrf_table": 10,
     |              },
     |          )
     |      
     |      Create SEG6LOCAL tunnel End.B6 action (kernel >= 4.14)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6local",
     |                  "action": "End.B6",
     |                  "srh": {"segs": "2000::5,2000::6"},
     |              },
     |          )
     |      
     |      Create SEG6LOCAL tunnel End.B6 action with hmac (kernel >= 4.14)::
     |      
     |          ipr.route(
     |              "add",
     |              dst="2001:0:0:10::2/128",
     |              oif=idx,
     |              encap={
     |                  "type": "seg6local",
     |                  "action": "End.B6",
     |                  "srh": {
     |                      "segs": "2000::5,2000::6",
     |                      "hmac": 0xf,
     |                  },
     |              },
     |          )
     |      
     |      **change**, **replace**, **append**
     |      
     |      Commands `change`, `replace` and `append` have the same meanings
     |      as in ip-route(8): `change` modifies only existing route, while
     |      `replace` creates a new one, if there is no such route yet.
     |      `append` allows to create an IPv6 multipath route.
     |      
     |      **del**
     |      
     |      Remove the route. The same syntax as for **add**.
     |      
     |      **get**
     |      
     |      Get route by spec.
     |      
     |      **dump**
     |      
     |      Dump all routes.
     |  
     |  rule(self, command, **kwarg)
     |      Rule operations
     |      
     |          - command — add, delete
     |          - table — 0 < table id < 253
     |          - priority — 0 < rule's priority < 32766
     |          - action — type of rule, default 'FR_ACT_NOP' (see fibmsg.py)
     |          - rtscope — routing scope, default RT_SCOPE_UNIVERSE
     |              `(RT_SCOPE_UNIVERSE|RT_SCOPE_SITE|                RT_SCOPE_LINK|RT_SCOPE_HOST|RT_SCOPE_NOWHERE)`
     |          - family — rule's family (socket.AF_INET (default) or
     |              socket.AF_INET6)
     |          - src — IP source for Source Based (Policy Based) routing's rule
     |          - dst — IP for Destination Based (Policy Based) routing's rule
     |          - src_len — Mask for Source Based (Policy Based) routing's rule
     |          - dst_len — Mask for Destination Based (Policy Based) routing's
     |              rule
     |          - iifname — Input interface for Interface Based (Policy Based)
     |              routing's rule
     |          - oifname — Output interface for Interface Based (Policy Based)
     |              routing's rule
     |          - uid_range — Range of user identifiers, a string like "1000:1234"
     |          - dport_range — Range of destination ports, a string like "80-120"
     |          - sport_range — Range of source ports, as a string like "80-120"
     |      
     |      All packets route via table 10::
     |      
     |          # 32000: from all lookup 10
     |          # ...
     |          ip.rule('add', table=10, priority=32000)
     |      
     |      Default action::
     |      
     |          # 32001: from all lookup 11 unreachable
     |          # ...
     |          iproute.rule('add',
     |                       table=11,
     |                       priority=32001,
     |                       action='FR_ACT_UNREACHABLE')
     |      
     |      Use source address to choose a routing table::
     |      
     |          # 32004: from 10.64.75.141 lookup 14
     |          # ...
     |          iproute.rule('add',
     |                       table=14,
     |                       priority=32004,
     |                       src='10.64.75.141')
     |      
     |      Use dst address to choose a routing table::
     |      
     |          # 32005: from 10.64.75.141/24 lookup 15
     |          # ...
     |          iproute.rule('add',
     |                       table=15,
     |                       priority=32005,
     |                       dst='10.64.75.141',
     |                       dst_len=24)
     |      
     |      Match fwmark::
     |      
     |          # 32006: from 10.64.75.141 fwmark 0xa lookup 15
     |          # ...
     |          iproute.rule('add',
     |                       table=15,
     |                       priority=32006,
     |                       dst='10.64.75.141',
     |                       fwmark=10)
     |  
     |  stats(self, command, **kwarg)
     |      Stats prototype.
     |  
     |  tc(self, command, kind=None, index=0, handle=0, **kwarg)
     |      "Swiss knife" for traffic control. With the method you can
     |      add, delete or modify qdiscs, classes and filters.
     |      
     |      * command -- add or delete qdisc, class, filter.
     |      * kind -- a string identifier -- "sfq", "htb", "u32" and so on.
     |      * handle -- integer or string
     |      
     |      Command can be one of ("add", "del", "add-class", "del-class",
     |      "add-filter", "del-filter") (see `commands` dict in the code).
     |      
     |      Handle notice: traditional iproute2 notation, like "1:0", actually
     |      represents two parts in one four-bytes integer::
     |      
     |          1:0    ->    0x10000
     |          1:1    ->    0x10001
     |          ff:0   ->   0xff0000
     |          ffff:1 -> 0xffff0001
     |      
     |      Target notice: if your target is a class/qdisc that applies an
     |      algorithm that can only apply to upstream traffic profile, but your
     |      keys variable explicitly references a match that is only relevant for
     |      upstream traffic, the kernel will reject the filter.  Unless you're
     |      dealing with devices like IMQs
     |      
     |      For pyroute2 tc() you can use both forms: integer like 0xffff0000
     |      or string like 'ffff:0000'. By default, handle is 0, so you can add
     |      simple classless queues w/o need to specify handle. Ingress queue
     |      causes handle to be 0xffff0000.
     |      
     |      So, to set up sfq queue on interface 1, the function call
     |      will be like that::
     |      
     |          ip = IPRoute()
     |          ip.tc("add", "sfq", 1)
     |      
     |      Instead of string commands ("add", "del"...), you can use also
     |      module constants, `RTM_NEWQDISC`, `RTM_DELQDISC` and so on::
     |      
     |          ip = IPRoute()
     |          flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_CREATE | NLM_F_EXCL
     |          ip.tc((RTM_NEWQDISC, flags), "sfq", 1)
     |      
     |      It should be noted that "change", "change-class" and
     |      "change-filter" work like "replace", "replace-class" and
     |      "replace-filter", except they will fail if the node doesn't
     |      exist (while it would have been created by "replace"). This is
     |      not the same behaviour as with "tc" where "change" can be used
     |      to modify the value of some options while leaving the others
     |      unchanged. However, as not all entities support this
     |      operation, we believe the "change" commands as implemented
     |      here are more useful.
     |      
     |      
     |      Also available "modules" (returns tc plugins dict) and "help"
     |      commands::
     |      
     |          help(ip.tc("modules")["htb"])
     |          print(ip.tc("help", "htb"))
     |  
     |  unregister_link_kind(self, kind)
     |  
     |  vlan_filter(self, command, **kwarg)
     |      Vlan filters is another approach to support vlans in Linux.
     |      Before vlan filters were introduced, there was only one way
     |      to bridge vlans: one had to create vlan interfaces and
     |      then add them as ports::
     |      
     |                  +------+      +----------+
     |          net --> | eth0 | <--> | eth0.500 | <---+
     |                  +------+      +----------+     |
     |                                                 v
     |                  +------+                    +-----+
     |          net --> | eth1 |                    | br0 |
     |                  +------+                    +-----+
     |                                                 ^
     |                  +------+      +----------+     |
     |          net --> | eth2 | <--> | eth2.500 | <---+
     |                  +------+      +----------+
     |      
     |      It means that one has to create as many bridges, as there were
     |      vlans. Vlan filters allow to bridge together underlying interfaces
     |      and create vlans already on the bridge::
     |      
     |          # v500 label shows which interfaces have vlan filter
     |      
     |                  +------+ v500
     |          net --> | eth0 | <-------+
     |                  +------+         |
     |                                   v
     |                  +------+      +-----+    +---------+
     |          net --> | eth1 | <--> | br0 |<-->| br0v500 |
     |                  +------+      +-----+    +---------+
     |                                   ^
     |                  +------+ v500    |
     |          net --> | eth2 | <-------+
     |                  +------+
     |      
     |      In this example vlan 500 will be allowed only on ports `eth0` and
     |      `eth2`, though all three eth nics are bridged.
     |      
     |      Some example code::
     |      
     |          # create bridge
     |          ip.link("add",
     |                  ifname="br0",
     |                  kind="bridge")
     |      
     |          # attach a port
     |          ip.link("set",
     |                  index=ip.link_lookup(ifname="eth0")[0],
     |                  master=ip.link_lookup(ifname="br0")[0])
     |      
     |          # set vlan filter
     |          ip.vlan_filter("add",
     |                         index=ip.link_lookup(ifname="eth0")[0],
     |                         vlan_info={"vid": 500})
     |      
     |          # create vlan interface on the bridge
     |          ip.link("add",
     |                  ifname="br0v500",
     |                  kind="vlan",
     |                  link=ip.link_lookup(ifname="br0")[0],
     |                  vlan_id=500)
     |      
     |          # set all UP
     |          ip.link("set",
     |                  index=ip.link_lookup(ifname="br0")[0],
     |                  state="up")
     |          ip.link("set",
     |                  index=ip.link_lookup(ifname="br0v500")[0],
     |                  state="up")
     |          ip.link("set",
     |                  index=ip.link_lookup(ifname="eth0")[0],
     |                  state="up")
     |      
     |          # set IP address
     |          ip.addr("add",
     |                  index=ip.link_lookup(ifname="br0v500")[0],
     |                  address="172.16.5.2",
     |                  mask=24)
     |      
     |          Now all the traffic to the network 172.16.5.2/24 will go
     |          to vlan 500 only via ports that have such vlan filter.
     |      
     |      
     |      Required arguments for `vlan_filter()` -- `index` and `vlan_info`.
     |      Vlan info struct::
     |      
     |          {"vid": uint16,
     |           "flags": uint16}
     |      
     |      More details:
     |          * kernel:Documentation/networking/switchdev.txt
     |          * pyroute2.netlink.rtnl.ifinfmsg:... vlan_info
     |      
     |      One can specify `flags` as int or as a list of flag names:
     |          * `master` == 0x1
     |          * `pvid` == 0x2
     |          * `untagged` == 0x4
     |          * `range_begin` == 0x8
     |          * `range_end` == 0x10
     |          * `brentry` == 0x20
     |      
     |      E.g.::
     |      
     |          {"vid": 20,
     |           "flags": ["pvid", "untagged"]}
     |      
     |          # is equal to
     |          {"vid": 20,
     |           "flags": 6}
     |      
     |      Commands:
     |      
     |      **add**
     |      
     |      Add vlan filter to a bridge port. Example::
     |      
     |          ip.vlan_filter("add", index=2, vlan_info={"vid": 200})
     |      
     |      **del**
     |      
     |      Remove vlan filter from a bridge port. Example::
     |      
     |          ip.vlan_filter("del", index=2, vlan_info={"vid": 200})
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from RTNL_API:
     |  
     |  close_file(fd)
     |      Close a file that was previously opened with open_file().
     |  
     |  get_pid()
     |      Return the PID of the current process.
     |  
     |  open_file(path)
     |      Open a file (read only) and return its (fd, inode).
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from RTNL_API:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.rtnl.riprsocket.RawIPRSocketBase:
     |  
     |  bind(self, groups=67372509, **kwarg)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocket:
     |  
     |  __getattr__(self, attr)
     |  
     |  add_membership(self, group)
     |  
     |  close(self, code=104)
     |      Correctly close the socket and free all resources.
     |  
     |  drop_membership(self, group)
     |  
     |  post_init(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  buffer_thread_routine(self)
     |  
     |  clone(self)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request(self, msg, msg_type, msg_flags=769, terminate=None, callback=None, parser=None)
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  recv(self, *argv, **kwarg)
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  get(self, bufsize=65536, msg_seq=0, terminate=None, callback=None, noraise=False)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
    
    RemoteIPRoute = class FailedClass(builtins.object)
     |  RemoteIPRoute(*argv, **kwarg)
     |  
     |  Methods defined here:
     |  
     |  __init__(self, *argv, **kwarg)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class RemoteSocket(pyroute2.netlink.nlsocket.NetlinkSocketBase, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  RemoteSocket(trnsp_in, trnsp_out, groups=0)
     |  
     |  Generic netlink socket.
     |  
     |  Method resolution order:
     |      RemoteSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, trnsp_in, trnsp_out, groups=0)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  bind(self, *argv, **kwarg)
     |  
     |  close(self, code=104)
     |  
     |  fileno(self)
     |  
     |  getsockopt(self, *argv, **kwarg)
     |  
     |  proxy(self, cmd, *argv, **kwarg)
     |  
     |  recv(self, bufsize, flags=0)
     |  
     |  send(self, *argv, **kwarg)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  setsockopt(self, *argv, **kwarg)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  remote_trnsp_in = None
     |  
     |  remote_trnsp_out = None
     |  
     |  trnsp_in = None
     |  
     |  trnsp_out = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  buffer_thread_routine(self)
     |  
     |  clone(self)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request(self, msg, msg_type, msg_flags=769, terminate=None, callback=None, parser=None)
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  post_init(self)
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  get(self, bufsize=65536, msg_seq=0, terminate=None, callback=None, noraise=False)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Server(http.server.HTTPServer)
     |  Server(address='localhost', port=8080, sources=None, ndb=None, log=None, auth_strict=False, auth_plugins=None)
     |  
     |  Base class for various socket-based server classes.
     |  
     |  Defaults to synchronous IP stream (i.e., TCP).
     |  
     |  Methods for the caller:
     |  
     |  - __init__(server_address, RequestHandlerClass, bind_and_activate=True)
     |  - serve_forever(poll_interval=0.5)
     |  - shutdown()
     |  - handle_request()  # if you don't use serve_forever()
     |  - fileno() -> int   # for selector
     |  
     |  Methods that may be overridden:
     |  
     |  - server_bind()
     |  - server_activate()
     |  - get_request() -> request, client_address
     |  - handle_timeout()
     |  - verify_request(request, client_address)
     |  - process_request(request, client_address)
     |  - shutdown_request(request)
     |  - close_request(request)
     |  - handle_error()
     |  
     |  Methods for derived classes:
     |  
     |  - finish_request(request, client_address)
     |  
     |  Class variables that may be overridden by derived classes or
     |  instances:
     |  
     |  - timeout
     |  - address_family
     |  - socket_type
     |  - request_queue_size (only for stream sockets)
     |  - allow_reuse_address
     |  
     |  Instance variables:
     |  
     |  - server_address
     |  - RequestHandlerClass
     |  - socket
     |  
     |  Method resolution order:
     |      Server
     |      http.server.HTTPServer
     |      socketserver.TCPServer
     |      socketserver.BaseServer
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, address='localhost', port=8080, sources=None, ndb=None, log=None, auth_strict=False, auth_plugins=None)
     |      Constructor.  May be extended, do not override.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from http.server.HTTPServer:
     |  
     |  server_bind(self)
     |      Override server_bind to store the server name.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from http.server.HTTPServer:
     |  
     |  allow_reuse_address = 1
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from socketserver.TCPServer:
     |  
     |  close_request(self, request)
     |      Called to clean up an individual request.
     |  
     |  fileno(self)
     |      Return socket file number.
     |      
     |      Interface required by selector.
     |  
     |  get_request(self)
     |      Get the request and client address from the socket.
     |      
     |      May be overridden.
     |  
     |  server_activate(self)
     |      Called by constructor to activate the server.
     |      
     |      May be overridden.
     |  
     |  server_close(self)
     |      Called to clean-up the server.
     |      
     |      May be overridden.
     |  
     |  shutdown_request(self, request)
     |      Called to shutdown and close an individual request.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from socketserver.TCPServer:
     |  
     |  address_family = <AddressFamily.AF_INET: 2>
     |  
     |  request_queue_size = 5
     |  
     |  socket_type = <SocketKind.SOCK_STREAM: 1>
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from socketserver.BaseServer:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, *args)
     |  
     |  finish_request(self, request, client_address)
     |      Finish one request by instantiating RequestHandlerClass.
     |  
     |  handle_error(self, request, client_address)
     |      Handle an error gracefully.  May be overridden.
     |      
     |      The default is to print a traceback and continue.
     |  
     |  handle_request(self)
     |      Handle one request, possibly blocking.
     |      
     |      Respects self.timeout.
     |  
     |  handle_timeout(self)
     |      Called if no new request arrives within self.timeout.
     |      
     |      Overridden by ForkingMixIn.
     |  
     |  process_request(self, request, client_address)
     |      Call finish_request.
     |      
     |      Overridden by ForkingMixIn and ThreadingMixIn.
     |  
     |  serve_forever(self, poll_interval=0.5)
     |      Handle one request at a time until shutdown.
     |      
     |      Polls for shutdown every poll_interval seconds. Ignores
     |      self.timeout. If you need to do periodic tasks, do them in
     |      another thread.
     |  
     |  service_actions(self)
     |      Called by the serve_forever() loop.
     |      
     |      May be overridden by a subclass / Mixin to implement any code that
     |      needs to be run during the loop.
     |  
     |  shutdown(self)
     |      Stops the serve_forever loop.
     |      
     |      Blocks until the loop has finished. This must be called while
     |      serve_forever() is running in another thread, or it will
     |      deadlock.
     |  
     |  verify_request(self, request, client_address)
     |      Verify the request.  May be overridden.
     |      
     |      Return True if we should proceed with this request.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from socketserver.BaseServer:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from socketserver.BaseServer:
     |  
     |  timeout = None
    
    class TaskStats(pyroute2.netlink.generic.GenericNetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  Low-level socket interface. Provides all the
     |  usual socket does, can be used in poll/select,
     |  doesn't create any implicit threads.
     |  
     |  Method resolution order:
     |      TaskStats
     |      pyroute2.netlink.generic.GenericNetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  bind(self)
     |      Bind the socket and performs generic netlink
     |      proto lookup. The `proto` parameter is a string,
     |      like "TASKSTATS", `msg_class` is a class to
     |      parse messages with.
     |  
     |  deregister_mask(self, mask)
     |      Stop the accounting.
     |  
     |  get_pid_stat(self, pid)
     |      Get taskstats for a process. Pid should be an integer.
     |  
     |  register_mask(self, mask)
     |      Start the accounting for a processors by a mask. Mask is
     |      a string, e.g.::
     |          0,1 -- first two CPUs
     |          0-4,6-10 -- CPUs from 0 to 4 and from 6 to 10
     |      
     |      Though the kernel has a procedure, that cleans up accounting,
     |      when it is not used, it is recommended to run deregister_mask()
     |      before process exit.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  add_membership(self, group)
     |  
     |  discovery(self, proto)
     |      Resolve generic netlink protocol -- takes a string
     |      as the only parameter, return protocol description
     |  
     |  drop_membership(self, group)
     |  
     |  get(self, *argv, **kwarg)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  nlm_request(self, *argv, **kwarg)
     |  
     |  policy(self, proto)
     |      Extract policy information for a generic netlink protocol -- takes
     |      a string as the only parameter, return protocol policy
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  prid
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  mcast_groups = {}
     |  
     |  module_err_level = 'error'
     |  
     |  module_err_message = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocket:
     |  
     |  __getattr__(self, attr)
     |  
     |  close(self, code=104)
     |      Correctly close the socket and free all resources.
     |  
     |  post_init(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  buffer_thread_routine(self)
     |  
     |  clone(self)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  recv(self, *argv, **kwarg)
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class UeventSocket(pyroute2.netlink.nlsocket.NetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  Generic netlink socket.
     |  
     |  Method resolution order:
     |      UeventSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  bind(self)
     |      Bind the socket to given multicast groups, using
     |      given pid.
     |      
     |          - If pid is None, use automatic port allocation
     |          - If pid == 0, use process' pid
     |          - If pid == <int>, use the value instead of pid
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocket:
     |  
     |  __getattr__(self, attr)
     |  
     |  add_membership(self, group)
     |  
     |  close(self, code=104)
     |      Correctly close the socket and free all resources.
     |  
     |  drop_membership(self, group)
     |  
     |  post_init(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  buffer_thread_routine(self)
     |  
     |  clone(self)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request(self, msg, msg_type, msg_flags=769, terminate=None, callback=None, parser=None)
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  recv(self, *argv, **kwarg)
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  get(self, bufsize=65536, msg_seq=0, terminate=None, callback=None, noraise=False)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class WiSet(builtins.object)
     |  WiSet(name=None, attr_type='hash:ip', family=<AddressFamily.AF_INET: 2>, sock=None, timeout=None, counters=False, comment=False, hashsize=None, revision=None, skbinfo=False)
     |  
     |  Main high level ipset manipulation class.
     |  
     |  Every high level ipset operation should be possible with this class,
     |  you probably don't need other helpers of this module, except tools
     |  to load data from kernel (:func:`load_all_ipsets` and :func:`load_ipset`)
     |  
     |  For example, you can create and an entry in a ipset just with:
     |  
     |  .. doctest::
     |      :skipif: True
     |  
     |      >>> with WiSet(name="mysuperipset") as myset:
     |      >>>    myset.create()             # add the ipset in the kernel
     |      >>>    myset.add("198.51.100.1")  # add one IP to the set
     |  
     |  Netlink sockets are opened by __enter__ and __exit__ function, so you don't
     |  have to manage it manually if you use the "with" keyword.
     |  
     |  If you want to manage it manually (for example for long operation in
     |  a daemon), you can do the following:
     |  
     |  .. doctest::
     |      :skipif: True
     |  
     |      >>> myset = WiSet(name="mysuperipset")
     |      >>> myset.open_netlink()
     |      >>> # do stuff
     |      >>> myset.close_netlink()
     |  
     |  You can also don't initiate at all any netlink socket, this code will work:
     |  
     |  .. doctest::
     |      :skipif: True
     |  
     |      >>> myset = WiSet(name="mysuperipset")
     |      >>> myset.create()
     |      >>> myset.destroy()
     |  
     |  But do it very carefully. In that case, a netlink socket will be opened
     |  in background for any operation. No socket will be leaked, but that
     |  can consume resources.
     |  
     |  You can also instantiate WiSet objects with :func:`load_all_ipsets` and
     |  :func:`load_ipset`:
     |  
     |  .. doctest::
     |      :skipif: True
     |  
     |      >>> all_sets_dict = load_all_ipsets()
     |      >>> one_set = load_ipset(name="myset")
     |  
     |  Have a look on content variable if you need list of entries in the Set.
     |  
     |  Methods defined here:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  __init__(self, name=None, attr_type='hash:ip', family=<AddressFamily.AF_INET: 2>, sock=None, timeout=None, counters=False, comment=False, hashsize=None, revision=None, skbinfo=False)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  add(self, entry, **kwargs)
     |      Add an entry in this ipset.
     |      
     |      If counters are enabled on the set, reset by default the value when
     |      we add the element. Without this reset, kernel sometimes store old
     |      values and can add very strange behavior on counters.
     |  
     |  close_netlink(self)
     |      Clone any opened netlink socket
     |  
     |  create(self, **kwargs)
     |      Insert this Set in the kernel
     |      
     |      Many options are set with python object attributes (like comments,
     |      counters, etc). For non-supported type, kwargs are provided. See
     |      :doc:`ipset` documentation for more information.
     |  
     |  delete(self, entry, **kwargs)
     |      Delete/remove an entry in this ipset
     |  
     |  destroy(self)
     |      Destroy this ipset in the kernel list.
     |      
     |      It does not delete this python object (any content or other stored
     |      values are keep in memory). This function will fail if the ipset is
     |      still referenced (by example in iptables rules), you have been warned.
     |  
     |  flush(self)
     |      Flush entries of the ipset
     |  
     |  insert_list(self, entries)
     |      Just a small helper to reduce the number of loops in main code.
     |  
     |  open_netlink(self)
     |      Open manually a netlink socket.
     |      
     |      You can use "with WiSet()" statement instead.
     |  
     |  replace_entries(self, new_list)
     |      Replace the content of an ipset with a new list of entries.
     |      
     |      This operation is like a flush() and adding all entries one by one. But
     |      this call is atomic: it creates a temporary ipset and swap the content.
     |      
     |      :param new_list: list of entries to add
     |      :type new_list: list or :py:class:`set` of basestring or of
     |          keyword arguments dict
     |  
     |  test(self, entry, **kwargs)
     |      Test if an entry is in this ipset
     |  
     |  test_list(self, entries, **kwargs)
     |      Test if a list of a set of entries is in this ipset
     |      
     |      Return a set of entries found in the IPSet
     |  
     |  update_content(self)
     |      Update the content dictionary with values from kernel
     |  
     |  update_dict_content(self, ndmsg)
     |      Update a dictionary statistics with values sent in netlink message
     |      
     |      :param ndmsg: the netlink message
     |      :type ndmsg: netlink message
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  from_netlink(ndmsg, content=False) from builtins.type
     |      Create a ipset objects based on a parsed netlink message
     |      
     |      :param ndmsg: the netlink message to parse
     |      :param content: should we fill (and parse) entries info (can be slow
     |                      on very large set)
     |      :type content: bool
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  content
     |      Dictionary of entries in the set.
     |      
     |      Keys are IP addresses (as string), values are IPStats tuples.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  attr_type
    
    class WireGuard(pyroute2.netlink.generic.GenericNetlinkSocket, pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe)
     |  Low-level socket interface. Provides all the
     |  usual socket does, can be used in poll/select,
     |  doesn't create any implicit threads.
     |  
     |  Method resolution order:
     |      WireGuard
     |      pyroute2.netlink.generic.GenericNetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocket
     |      pyroute2.netlink.nlsocket.NetlinkSocketBase
     |      pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  info(self, interface)
     |  
     |  set(self, interface, listen_port=None, fwmark=None, private_key=None, peer=None)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  add_membership(self, group)
     |  
     |  bind(self, proto, msg_class, groups=0, pid=None, **kwarg)
     |      Bind the socket and performs generic netlink
     |      proto lookup. The `proto` parameter is a string,
     |      like "TASKSTATS", `msg_class` is a class to
     |      parse messages with.
     |  
     |  discovery(self, proto)
     |      Resolve generic netlink protocol -- takes a string
     |      as the only parameter, return protocol description
     |  
     |  drop_membership(self, group)
     |  
     |  get(self, *argv, **kwarg)
     |      Get parsed messages list. If `msg_seq` is given, return
     |      only messages with that `msg['header']['sequence_number']`,
     |      saving all other messages into `self.backlog`.
     |      
     |      The routine is thread-safe.
     |      
     |      The `bufsize` parameter can be:
     |      
     |          - -1: bufsize will be calculated from the first 4 bytes of
     |              the network data
     |          - 0: bufsize will be calculated from SO_RCVBUF sockopt
     |          - int >= 0: just a bufsize
     |      
     |      If `noraise` is true, error messages will be treated as any
     |      other message.
     |  
     |  nlm_request(self, *argv, **kwarg)
     |  
     |  policy(self, proto)
     |      Extract policy information for a generic netlink protocol -- takes
     |      a string as the only parameter, return protocol policy
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  prid
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.generic.GenericNetlinkSocket:
     |  
     |  mcast_groups = {}
     |  
     |  module_err_level = 'error'
     |  
     |  module_err_message = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocket:
     |  
     |  __getattr__(self, attr)
     |  
     |  close(self, code=104)
     |      Correctly close the socket and free all resources.
     |  
     |  post_init(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, exc_type, exc_value, traceback)
     |  
     |  buffer_thread_routine(self)
     |  
     |  clone(self)
     |  
     |  compile(self)
     |  
     |  get_policy_map(self, policy=None)
     |      Return policy for a given message type or for all
     |      message types. Policy parameter can be either int,
     |      or a list of ints. Always return dictionary.
     |  
     |  nlm_request_batch(self, msgs, noraise=False)
     |      This function is for messages which are expected to have side effects.
     |      Do not blindly retry in case of errors as this might duplicate them.
     |  
     |  recv(self, *argv, **kwarg)
     |  
     |  recv_into(self, data, *argv, **kwarg)
     |  
     |  register_callback(self, callback, predicate=<function NetlinkSocketBase.<lambda> at 0x7f29f0a8eee0>, args=None)
     |      Register a callback to run on a message arrival.
     |      
     |      Callback is the function that will be called with the
     |      message as the first argument. Predicate is the optional
     |      callable object, that returns True or False. Upon True,
     |      the callback will be called. Upon False it will not.
     |      Args is a list or tuple of arguments.
     |      
     |      Simplest example, assume ipr is the IPRoute() instance::
     |      
     |          # create a simplest callback that will print messages
     |          def cb(msg):
     |              print(msg)
     |      
     |          # register callback for any message:
     |          ipr.register_callback(cb)
     |      
     |      More complex example, with filtering::
     |      
     |          # Set object's attribute after the message key
     |          def cb(msg, obj):
     |              obj.some_attr = msg["some key"]
     |      
     |          # Register the callback only for the loopback device, index 1:
     |          ipr.register_callback(cb,
     |                                lambda x: x.get('index', None) == 1,
     |                                (self, ))
     |      
     |      Please note: you do **not** need to register the default 0 queue
     |      to invoke callbacks on broadcast messages. Callbacks are
     |      iterated **before** messages get enqueued.
     |  
     |  register_policy(self, policy, msg_class=None)
     |      Register netlink encoding/decoding policy. Can
     |      be specified in two ways:
     |      `nlsocket.register_policy(MSG_ID, msg_class)`
     |      to register one particular rule, or
     |      `nlsocket.register_policy({MSG_ID1: msg_class})`
     |      to register several rules at once.
     |      E.g.::
     |      
     |          policy = {RTM_NEWLINK: ifinfmsg,
     |                    RTM_DELLINK: ifinfmsg,
     |                    RTM_NEWADDR: ifaddrmsg,
     |                    RTM_DELADDR: ifaddrmsg}
     |          nlsocket.register_policy(policy)
     |      
     |      One can call `register_policy()` as many times,
     |      as one want to -- it will just extend the current
     |      policy scheme, not replace it.
     |  
     |  release(self)
     |  
     |  sendto(self, *argv, **kwarg)
     |  
     |  sendto_gate(self, msg, addr)
     |  
     |  unregister_callback(self, callback)
     |      Remove the first reference to the function from the callback
     |      register
     |  
     |  unregister_policy(self, policy)
     |      Unregister policy. Policy can be:
     |      
     |          - int -- then it will just remove one policy
     |          - list or tuple of ints -- remove all given
     |          - dict -- remove policies by keys from dict
     |      
     |      In the last case the routine will ignore dict values,
     |      it is implemented so just to make it compatible with
     |      `get_policy_map()` return value.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pyroute2.netlink.nlsocket.NetlinkSocketBase:
     |  
     |  input_from_buffer_queue = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  put(self, msg, msg_type, msg_flags=1, addr=(0, 0), msg_seq=0, msg_pid=None)
     |      Construct a message from a dictionary and send it to
     |      the socket. Parameters:
     |      
     |          - msg -- the message in the dictionary format
     |          - msg_type -- the message type
     |          - msg_flags -- the message flags to use in the request
     |          - addr -- `sendto()` addr, default `(0, 0)`
     |          - msg_seq -- sequence number to use
     |          - msg_pid -- pid to use, if `None` -- use os.getpid()
     |      
     |      Example::
     |      
     |          s = IPRSocket()
     |          s.bind()
     |          s.put({'index': 1}, RTM_GETLINK)
     |          s.get()
     |          s.close()
     |      
     |      Please notice, that the return value of `s.get()` can be
     |      not the result of `s.put()`, but any broadcast message.
     |      To fix that, use `msg_seq` -- the response must contain the
     |      same `msg['header']['sequence_number']` value.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pyroute2.netlink.nlsocket.NetlinkSocketBaseSafe:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)

DATA
    __all__ = ['AcpiEventSocket', 'ChaoticException', 'ChaoticIPRoute', 'C...

VERSION
    0.7.3

FILE
    /usr/local/lib/python3.8/dist-packages/pyroute2/__init__.py

