<!DOCTYPE html 
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
  <title>Patches to Linux's traffic control engine to allow it to accurately calculate ATM traffic rates</title>

  <style type="text/css">
    .u			{ text-decoration: underline }
    .a			{ list-style-type: lower-alpha }
    dd          	{ padding-bottom: 1em }
    dl          	{ margin-left: 4em }
    h2			{ margin-left: 1em }
    h3			{ margin-left: 2em }
    ol			{ margin-left: 2em; }
    p           	{ margin-left: 2em }
    p.example		{ margin-left: +2em; font-family: monospace; white-space: pre }
    p.signature		{ margin-left: 0 }
    p.title     	{ margin-left: 0em; margin-top: 0; text-align: center; font-size: 200%; font-weight: bold; background-color: #8080FF }
    table       	{ margin-left: 4em }
    td          	{ vertical-align: top;  padding-right: 1em ; padding-bottom: 1em }
    table.compact 	{ margin-left: 4em; border: solid thin; border-collapse: collapse }
    table.compact td	{ padding: 0.2em; border: solid thin }
    ul			{ margin-left: 2em; }
    ul.expanded li	{ margin-left: 2em; margin-bottom: 1em }
    table.notes		{ margin-left: 2em; }
  </style>
</head>

<body>

<p class="title">
    Patches to Linux's traffic control engine<br/>
    to allow it to accurately calculate<br/>
    ATM traffic rates
</p>

  <p style="background-color: #fbf39d; margin-right: 2em">
    Time has moved on, and the Linux Traffic control engine
    now has ATM support, largely due to Jesper Brouer.  As a
    consequence this page is now only of historical interest.
  </p>

<h1>Contents</h1>

<ol>
  <li><a href="#overview">Overview</a></li>
  <li><a href="#downloads">Downloads</a></li>
  <li><a href="#usage">Using the patches</a></li>
  <li><a href="#details">Justification &amp; Technical Details</a></li>
  <li><a href="#history">History &amp; Acknowledgements</a></li>
  <li><a href="#notes">Notes</a></li>
  <li><a href="#contact">Contact</a></li>
</ol>

<h1><a name="overview">Overview</a></h1>

  <p>
    Currently the traffic control engine in Linux can't accurately
    calculate the time required to send data over an ATM link.
    For large packets (say &gt;1K bytes) the error generated by the
    current methods is less than 5%, but for small packets the error
    rises to over 40%.  The patches here allow Linux to calculate
    ATM traffic rates with no error.
  </p>

<h1><a name="downloads">Downloads</a></h1>

  <p>Current patches:</p>

  <table>
    <tr>
      <td><a href="iproute2-20060301-tcatm-1.0.patch">iproute2-20060301-tcatm-1.0.patch</a></td>
      <td>
        This patch for the iproute2 package (sometimes called iproute)
	adds an option to the "tc" program that configures the kernel to
	calculate ATM traffic rates.  It works best if combined with the
	kernel patch that follows.
      </td>
    </tr>
    <tr>
      <td><a href="linux-2.6.16-tcatm-1.0.patch">linux-2.6.16-tcatm-1.0.patch</a></td>
	<td>
        This patch for the Linux 2.6.16 kernel enables it to accurately
	calculate how long it will take to send a packet over an ATM link.
      </td>
    </tr>
    <tr>
      <td><a href="iproute2-20060301-htb-nohyst-1.0.patch">iproute2-20060301-htb-nohyst-1.0.patch</a></td>
      <td>
        This patch for the iproute2 package (sometimes called iproute)
	adds an option to the "tc" program that changes the HTB qdisc
	hysteresis option.  It assumes the tcatm patch has been applied.
	It will only work on kernels that have had the following patch
	applied.
      </td>
    </tr>
    <tr>
      <td><a href="linux-2.6.11-htb-nohyst-1.0.patch">linux-2.6.11-htb-nohyst-1.0.patch</a></td>
      <td>
        This patch for the Linux 2.6.11 kernels onwards allows the HTB
	hysteresis option to be changed dynamically per HTB class.
      </td>
    </tr>
  </table>

  <p>Patches for older kernels.</p>

  <table>
    <tr>
      <td><a href="linux-2.6.14-tcatm-1.0.patch">linux-2.6.14-tcatm-1.0.patch</a></td>
      <td>For 2.6.14 and 2.6.15 kernels.</td>
    </tr>
    <tr>
      <td><a href="linux-2.6.11-tcatm-1.0.patch">linux-2.6.11-tcatm-1.0.patch</a></td>
      <td>For 2.6.11, 2.6.12 and 2.6.13 kernels.</td>
    </tr>
    <tr>
      <td><a href="linux-2.6.8-tcatm-1.0.patch">linux-2.6.8-tcatm-1.0.patch</a></td>
      <td>For 2.6.8, 2.6.9 and 2.6.10 kernels.</td>
    </tr>
    <tr>
      <td><a href="linux-2.6.8-htb-nohyst-1.0.patch">linux-2.6.8-htb-nohyst-1.0.patch</a></td>
      <td>For 2.6.8, 2.6.9 and 2.6.10 kernels.</td>
    </tr>
  </table>

  <p>
    Debian users can find patches for Sarge in my 
    <a href="../../debian">Debian repository</a>.
    There you will find compiled kernels and the
    <a href="../../debian/sarge/iproute">iproute package</a>,
    both patched with tcatm, htb-nohyst, and the IMQ patch.
    If you want to apply tcatm to the patch to the kernel yourself,
    look at the
    <a href="../../debian/sarge/kernel-patch-tcatm">kernel-patch-tcatm package</a>.
    Ditto for the
    <a href="../../debian/sarge/kernel-patch-imq">kernel-patch-imq package</a>.
  </p>

<h1><a name="usage">Using the patches</a></h1>

<h2>New tc command line options</h2>

  <p>
    The tcatm patch adds or changes the following options in the tc
    program:
  </p>

  <dl>
    <dt><i>atm</i></dt>
    <dd>
      The <i>atm</i> option has been added to the tbf qdisc options,
      the cbq and htb classes, and the policing action.  It is a flag.
      If present it adds the overheads imposed by an ATM link to the
      rate table given to the kernel.  If the kernel has not been
      patched it will still get the wrong result about 14% of the
      time.  A patched kernel will always get 100% accurate results.
    </dd>
    <dt><i>overhead <span class="u">H</span></i></dt>
    <dd>
      This has been changed to accept negative overheads.  The
      overhead value, <span class="u">H</span>,  must be in the range -127..128.
    </dd>
  </dl>

  <p>
    The htb-nohyst patch adds one option to the tc program:
  </p>

  <dl>
    <dt><i>nohyst</i></dt>
    <dd>
      The <i>nohyst</i> option has been added to htb classes.
      Suppling it turns off hysteresis in the HTB class calculations.
      This replaces the equivalent compile time option,
      <code>HTB_HYSTERESIS</code>, in sch_htb.c.  The option will
      only work on kernels that have had the htb-nohyst patch
      applied.  It has no effect on unpatched kernels, and you
      don't get a warning telling you it hasn't worked.
    </dd>
  </dl>

<h2>About the htb-nohyst patch</h2>

  <p>
    Use the <i>nohyst</i> option to get more accurate packet
    scheduling (see Jesper's thesis <a href="#Note-1">[1]</a> for
    documentation).
  </p>

  <p>
    This increased accuracy comes at the expense of increased CPU
    usage. It is safe to use the <i>nohyst</i> option for slow links.
    Slow here means anything slower than a LAN, for example a
    broadband internet connection.  On these links the amount of
    CPU used by HTB isn't significant and you probably want as much
    control over the link as you can get.  As a general rule if you
    have spare CPU cycles (and any modern CPU doing server
    duty will), you should turn hysteresis off.
  </p>

<h2>About tcatm patch</h2>

  <p>
    There are three things to be aware of regarding the <i>atm</i>
    option.  The first is whether you need it or not.  If all
    you are doing is receiving large packets (ie you are just
    arbitrating between www, p2p and email) then you probably
    don't need it.  In that case if you use wget to estimate the
    underlying rate your link can handle, reduce that by 5%
    and pass it onto the qdisc, then it will probably work just
    fine.  On the other hand, if you are loading down your link
    with small packets then you really do need it.  There is only
    one application I know of that will saturate your link with
    small packets: VOIP.
  </p>

  <p>
    The second issue is knowing if your internet link is using
    ATM.  This is easy: if you are using ADSL then your link is
    using ATM.  Otherwise it isn't <a href="#Note-2">[2]</a>.
  </p>

  <p>
    The final thing to be aware of is the <i>atm</i> option will
    only work accurately if you specify the link speed and overheads
    correctly.  The link speed is not critical providing you err on
    the small side.  The speed your ISP gives you probably errs on
    the large side, so don't use it directly.  You can either just
    cut your ISP's figure by 10% , or you can measure it.  Measuring
    it isn't technically hard - just wget a large compressed file to
    and from a local (ie fast) site, then use <a href="#Note-3">[3]</a>
    the formula in last column in the table below to
    convert from wget's KiBytes/second figure to the raw Kbits/second
    figure your ADSL line runs at.  The tricky bit is finding someone
    willing to download a large compressed file from you.
  </p>

  <p>
    The <i>overhead</i> is the amount of extra data the various
    protocols add before sending your packets over the ATM link.
    Calculating the overhead values requires a working knowledge of
    the protocol stacks used, so I have summarised in the table below
    the values to use for the most common setups.  Also shown is the
    optimal MTU to use.  This is usually smaller than the largest
    possible MTU because of the padding ATM inserts into the last cell.
  </p>

  <p>
    The <i>mpu</i> is smallest number of bytes the protocol stack
    will send.  It includes the overheads.  If there isn't sufficient
    data to build a packet of this size padding will be added.
    protocols add before sending your packets over the ATM link.
    Calculating the overhead values requires a working knowledge of
    the protocol stacks used, so I have summarised in the table below
    the values to use for the most common setups.  Also shown is the
    optimal MTU to use.  This is usually smaller than the largest
    possible MTU because of the padding ATM inserts into the last cell.
  </p>

  <table class="compact">
    <tr>
      <td><b>Connection</b></td>
      <td colspan="2"><b>Overhead<br/><span class="u">H</span></b></td>
      <td><b>Optimal<br/>MTU</b></td><td><b>MPU</b></td>
      <td><b>wget speed formula</b></td></tr>
    <tr>
      <td>IPoA, VC/Mux</td>
      <td>8</td><td>-6</td><td>????</td><td>-</td>
      <td><code><i>wget_rate</i> / (<i>MTU</i>-52.) * math.floor((<i>MTU</i>+55)/48) * 434.176</code></td>
    </tr>
    <tr>
      <td>IPoA, LLC/SNAP</td>
      <td>16</td><td>2</td><td>????</td><td>-</td>
      <td><code><i>wget_rate</i> / (<i>MTU</i>-52.) * math.floor((<i>MTU</i>+63)/48) * 434.176</code></td>
    </tr>
    <tr>
      <td>Bridged, VC/Mux</td>
      <td>24</td><td>10</td><td>????</td><td>-</td>
      <td><code><i>wget_rate</i> / (<i>MTU</i>-52.) * math.floor((<i>MTU</i>+71)/48) * 434.176</code></td>
    </tr>
    <tr>
      <td>Bridged, VC/Mux+FCS</td>
      <td>28</td><td>14</td><td>????</td><td>82</td>
      <td><code><i>wget_rate</i> / (<i>MTU</i>-52.) * math.floor((<i>MTU</i>+75)/48) * 434.176</code></td>
    </tr>
    <tr>
      <td>Bridged, LLC/SNAP</td>
      <td>32</td><td>18</td><td>????</td><td>-</td>
      <td><code><i>wget_rate</i> / (<i>MTU</i>-52.) * math.floor((<i>MTU</i>+79)/48) * 434.176</code></td>
    </tr>
    <tr>
      <td>Bridged, LLC/SNAP+FCS</td>
      <td>36</td><td>22</td><td>????</td><td>70</td>
      <td><code><i>wget_rate</i> / (<i>MTU</i>-52.) * math.floor((<i>MTU</i>+83)/48) * 434.176</code></td>
    </tr>
    <tr>
      <td>PPPoA, VC/Mux</td>
      <td>10</td><td>-4</td><td>1478</td><td>-</td>
      <td><code><i>wget_rate</i> / (<i>MTU</i>-52.) * math.floor((<i>MTU</i>+57)/48) * 434.176</code></td>
    </tr>
    <tr>
      <td>PPPoA, LLC/SNAP</td>
      <td>14</td><td>0</td><td>????</td><td>-</td>
      <td><code><i>wget_rate</i> / (<i>MTU</i>-52.) * math.floor((<i>MTU</i>+61)/48) * 434.176</code></td>
    </tr>
    <tr>
      <td>PPPoE, VC/Mux</td>
      <td>32</td><td>18</td><td>????</td><td>-</td>
      <td><code><i>wget_rate</i> / (<i>MTU</i>-52.) * math.floor((<i>MTU</i>+79)/48) * 434.176</code></td>
    </tr>
    <tr>
      <td>PPPoE, VC/Mux+FCS</td>
      <td>36</td><td>22</td><td>????</td><td>82</td>
      <td><code><i>wget_rate</i> / (<i>MTU</i>-52.) * math.floor((<i>MTU</i>+85)/48) * 434.176</code></td>
    </tr>
    <tr>
      <td>PPPoE, LLC/SNAP</td>
      <td>40</td><td>26</td><td>????</td><td>-</td>
      <td><code><i>wget_rate</i> / (<i>MTU</i>-52.) * math.floor((<i>MTU</i>+87)/48) * 434.176</code></td>
    </tr>
    <tr>
      <td>PPPoE, LLC/SNAP+FCS</td>
      <td>44</td><td>30</td><td>????</td><td>90</td>
      <td><code><i>wget_rate</i> / (<i>MTU</i>-52.) * math.floor((<i>MTU</i>+91)/48) * 434.176</code></td>
    </tr>
  </table>

  <p>
    There are a lot of these, but don't let that faze you.
    Including the ethernet frame checksum in the protocol is very rare,
    so you can ignore the rows with +FCS in them.  
    As for the rest - look at how your ADSL modem is configured.
    This is typically done via a web browser.
    On one of the modems web pages the words in the first column will pop out.
    Beware that if your modem is in bridged mode and you are running a
    PPPoE client on your computer then you need to use a PPPoE row,
    not the bridged row.
  </p>

  <p>
    Only use the second Overhead column (ie the one with the smaller
    value) if all these things are true:
  </p>

  <ul>
    <li>This is for outgoing traffic.</li>
    <li>You are connected to your ADSL modem via Ethernet.</li>
    <li>You are running PPPoA or PPPoE on your modem, as opposed to your Linux server.</li>
  </ul>

<h1><a name="details">Justification &amp; Technical Details</a></h1>

  <h2>The tcatm patches</h2>

  <p>
    This patch is based on the adsl-optimizer patch, and should perform
    identically.  The adsl-optimizer patch was created by Jesper Brouer
    as part of his thesis.  A detailed explanation of the patch with
    an empirical analysis of how it performs can be found in the thesis,
    which is available
    <a href="http://www.adsl-optimizer.dk/thesis/">on-line</a>.
    A brief summary follows.
  </p>

  <h3>tcatm justification</h3>

  <p>
    Before this patch, the kernel + tc combined to calculate the time
    to send a packet as:
  </p>

  <p class="example">
    rate_table[packet_length] = (packet_length + overhead) / link_speed     <a href="#Note-4">[4]</a>
  </p>

  <p>
    That formula is 100% accurate for most technologies, but not
    for ATM.  ATM always sends data as cells.  Cells have a fixed
    length: 53 bytes, of which 5 bytes are overhead.  If a packet
    doesn't fit into an exact number of cells then the last cell
    has padding bytes added so it does.  This padding causes
    simple calculation above to be wrong in most cases.  The
    important question is "how wrong"?
  </p>

  <p>
    It is always possible to tweak <a href="#Note-5">[5]</a> the
    <code>overhead</code> and <code>link_speed</code> in the above
    parameters to get the kernel to correctly calculate the
    transmission time for any given packet size.  Let us assume we
    have done the said tweaking so that it works for packet length
    + overhead of <code>L</code>.  Let us also assume that when the
    packet length increases by 1 byte a new ATM cell is required
    <a href="#Note-6">[6]</a>.
    Ergo the percentage error for packet length plus overhead
    <code>L&nbsp;+&nbsp;1</code> is:
  </p>

  <p class="example">
    &nbsp;&nbsp;&nbsp;100 * (actual_transmission_time - kernel_calculated_transmission_time) / kernel_calculated_transmission_time
    =&nbsp;&nbsp;100 * ((L+53) / link_speed - (L+1) / link_speed)) / ((L+1) / link_speed)
    =&nbsp;&nbsp;100 * 52 / (L+1)
  </p>

  <p>
    From that formula we can compute a table showing the error
    when we optimise for any given packet length:
  </p>

  <table class="compact">
    <tr><td><b>Packet Length</b></td><td><b>Error</b></td><td><b>Packet Length</b></td><td><b>Error</b></td></tr>
    <tr><td align="right">48</td><td align="right">106%</td><td align="right">...</td><td align="right">...</td></tr>
    <tr><td align="right">96</td><td align="right">54%</td><td align="right">1392</td><td align="right">3.7%</td></tr>
    <tr><td align="right">144</td><td align="right">35%</td><td align="right">1440</td><td align="right">3.6%</td></tr>
    <tr><td align="right">192</td><td align="right">22%</td><td align="right">1488</td><td align="right">3.5%</td></tr>
  </table>

  <p>
    The errors are obviously very large when the packet sizes are small.
    This looks bad, but we have got by without this patch before, so
    what has changed?
  </p>

  <p>
    The existing formula works well for large packets.  The 3%..5%
    error is probably within other errors, and so isn't significant.
    Up until now network traffic has been dominated by large
    packets.  HTTP, FTP, POP3, SMTP, BitTorrent and other P2P traffic
    will use MTU size packets if they can.  When small packets
    are used, for example TCP acks, DNS queries, NTP, IRC and so on,
    they invariably take up a low proportion of the bandwidth because
    they are small.  So the approximation "the internet only carries
    large packets" has worked well enough for now.
  </p>

  <p>
    What has changed is how we use the network.  We now have a new use:
    real time streaming, and in particular VOIP.  VOIP uses small
    packets, typically in the 60..160 byte range.   As the table
    shows packets in this size range have very large errors, so large
    that you have to understate your available bandwidth by 50% to
    allow for them.  It only takes a few VOIP streams to use up most
    of an ADSL link, so unlike the small packets of old they can't be
    ignored.  What is worse, whereas if your don't give your web
    session priority it just becomes irritating, if you don't give
    VOIP the bandwidth it needs it becomes unusable.
  </p>

  <h3>Changes made by tcatm</h3>

  <p>The tcatm patch does three things:</p>

  <ul class="expanded">
    <li>
      The tc program now adjusts the rate table to include the ATM
      cell padding and overheads.
    </li>
    <li>
      The tc program now calculates and gives the kernel a rate
      table alignment offset, which the patched kernel adds to packet
      length before looking up the rate table.  This is done because
      each rate table entry is used for a range of packet lengths.
      Should the number of ATM cells used change somewhere
      within this range we will get the same large errors as before.
      The "align" offset effectively slides the rate table along so
      the boundaries of its elements match the ATM cell boundaries.
      This fix works for MTU's up to 4091 bytes.  With packet
      MTU's larger than that there is no way to make all rate
      table entries align with the ATM cell boundaries.
    </li>
    <li>
      The overhead figure is now allowed to be negative, which
      is it in one case (see the overhead calculation table).  
      This case arises when a ADSL router running PPPoA is used,
      and the ISP supplies a /30 address.  This is a not uncommon
      in business ADSL connections as it has the lowest overhead
      figure and thus makes best use of the links bandwidth.
    </li>
  </ul>

  <p>
    When the tc program is used on an unpatched kernel the kernel
    will ignore the rate table alignment offset.  This means that
    it will get errors in around 14% of all packet sizes, but the
    remaining 86% will be calculated accurately.  Under the
    old version of tc all packet sizes bar the one you optimise
    for will be calculated inaccurately.
  </p>

  <h2>The htb-nohyst patch</h2>

  <p>
    Hysteresis delays the movement a HTB class through the class
    tree in the hope that the change in traffic load is temporary
    and thus the move won't be needed in a short while.  As there
    is a significant amount of work involved in moving a class
    through the tree this reduces the amount of CPU time HTB uses.
  </p>

  <p>
    The tradeoff is that the HTB shaping of the class becomes
    inaccurate.  The effect is a higher delay variance or jitter.
    This effect is larger for slow links, because it is governed by
    the transmission delay (which is determined by the bandwidth).
    For documentation see Jesper's thesis <a href="#Note-1">[1]</a>.
  </p>
  
  <p>
    The amount of CPU HTB uses is insignificant on modern
    CPU's sending traffic over broadband connections
    <a href="#Note-7">[7]</a>, and conversely the need prioritise
    the limited amount of bandwidth accurately is paramount,
    particularly for VOIP.  The hysteresis optimisation isn't
    appropriate for such usage.  If posts to
    <a href="http://mailman.ds9a.nl/cgi-bin/mailman/listinfo/lartc">LARTC list</a>
    are anything to go by, most Linux traffic control users
    fall into this category.
    Changing hysteresis (which is on by default) from compile
    time option to run time option seems like a good thing to
    do under such circumstances.
  </p>

  <h2>Overhead and MTU Calculations</h2>

  <p>
    The overheads of the protocol stacks are calculated as follows:
  </p>

  <table class="compact">
    <tr>
      <td><b>Connection</b></td>
      <td><b>Protocol</b></td>
      <td align="right"><b>Overhead<br/>(bytes)</b></td>
    </tr>
    <tr><td rowspan="2">IPoA, VC/Mux<br>RFC-2684</td><td>ATM AAL5 SAR</td><td align="right">8</td></tr>
      <tr><td>&nbsp;&nbsp;<b>Total</b></td><td align="right"><b>8</b>&nbsp;&nbsp;</td></tr>
    <tr><td rowspan="4">IPoA, LLC/SNAP<br>RFC-2684</td><td>ATM LLC</td><td align="right">3</td></tr>
      <tr><td>ATM SNAP</td><td align="right">5</td></tr>
      <tr><td>ATM AAL5 SAR</td><td align="right">8</td></tr>
      <tr><td>&nbsp;&nbsp;<b>Total</b></td><td align="right"><b>16</b>&nbsp;&nbsp;</td></tr>
    <tr><td rowspan="4">Bridged, VC/Mux<br>RFC-1483/2684</td><td>Ethernet Header</td><td align="right">14</td></tr>
      <tr><td>ATM pad</td><td align="right">2</td></tr>
      <tr><td>ATM AAL5 SAR</td><td align="right">8</td></tr>
      <tr><td>&nbsp;&nbsp;<b>Total</b></td><td align="right"><b>24</b>&nbsp;&nbsp;</td></tr>
    <tr><td rowspan="6">Bridged, VC/Mux+FCS<br>RFC-1483/2684</td><td>Ethernet Header</td><td align="right">14</td></tr>
      <tr><td>Ethernet PAD <a href="#Note-8">[8]</a></td><td align="right">0</td></tr>
      <tr><td>Ethernet Checksum</td><td align="right">4</td></tr>
      <tr><td>ATM pad</td><td align="right">2</td></tr>
      <tr><td>ATM AAL5 SAR</td><td align="right">8</td></tr>
      <tr><td>&nbsp;&nbsp;<b>Total</b></td><td align="right"><b>28</b>&nbsp;&nbsp;</td></tr>
    <tr><td rowspan="6">Bridged, LLC/SNAP<br>RFC-1483/2684</td><td>Ethernet Header</td><td align="right">14</td></tr>
      <tr><td>ATM LLC</td><td align="right">3</td></tr>
      <tr><td>ATM SNAP</td><td align="right">5</td></tr>
      <tr><td>ATM pad</td><td align="right">2</td></tr>
      <tr><td>ATM AAL5 SAR</td><td align="right">8</td></tr>
      <tr><td>&nbsp;&nbsp;<b>Total</b></td><td align="right"><b>32</b>&nbsp;&nbsp;</td></tr>
    <tr><td rowspan="8">Bridged, LLC/SNAP+FCS<br>RFC-1483/2684</td><td>Ethernet Header</td><td align="right">14</td></tr>
      <tr><td>Ethernet PAD <a href="#Note-8">[8]</a></td><td align="right">0</td></tr>
      <tr><td>Ethernet Checksum</td><td align="right">4</td></tr>
      <tr><td>ATM LLC</td><td align="right">3</td></tr>
      <tr><td>ATM SNAP</td><td align="right">5</td></tr>
      <tr><td>ATM pad</td><td align="right">2</td></tr>
      <tr><td>ATM AAL5 SAR</td><td align="right">8</td></tr>
      <tr><td>&nbsp;&nbsp;<b>Total</b></td><td align="right"><b>36</b>&nbsp;&nbsp;</td></tr>
    <tr><td rowspan="3">PPPoA, VC/Mux<br>RFC-2364</td><td>PPP</td><td align="right">2</td></tr>
      <tr><td>ATM AAL5 SAR</td><td align="right">8</td></tr>
      <tr><td>&nbsp;&nbsp;<b>Total</b></td><td align="right"><b>10</b>&nbsp;&nbsp;</td></tr>
    <tr><td rowspan="5">PPPoA, LLC<br>RFC-2364</td><td>PPP</td><td align="right">2</td></tr>
      <tr><td>ATM LLC</td><td align="right">3</td></tr>
      <tr><td>ATM LLC-NLPID</td><td align="right">1</td></tr>
      <tr><td>ATM AAL5 SAR</td><td align="right">8</td></tr>
      <tr><td>&nbsp;&nbsp;<b>Total</b></td><td align="right"><b>14</b>&nbsp;&nbsp;</td></tr>
    <tr><td rowspan="6">PPPoE, VC/Mux<br>RFC-2684</td><td>PPP</td><td align="right">2</td></tr>
      <tr><td>PPPoE</td><td align="right">6</td></tr>
      <tr><td>Ethernet Header</td><td align="right">14</td></tr>
      <tr><td>ATM pad</td><td align="right">2</td></tr>
      <tr><td>ATM AAL5 SAR</td><td align="right">8</td></tr>
      <tr><td>&nbsp;&nbsp;<b>Total</b></td><td align="right"><b>32</b>&nbsp;&nbsp;</td></tr>
    <tr><td rowspan="8">PPPoE, VC/Mux+FCS<br>RFC-2684</td><td>PPP</td><td align="right">2</td></tr>
      <tr><td>PPPoE</td><td align="right">6</td></tr>
      <tr><td>Ethernet Header</td><td align="right">14</td></tr>
      <tr><td>Ethernet PAD <a href="#Note-8">[8]</a></td><td align="right">0</td></tr>
      <tr><td>Ethernet Checksum</td><td align="right">4</td></tr>
      <tr><td>ATM pad</td><td align="right">2</td></tr>
      <tr><td>ATM AAL5 SAR</td><td align="right">8</td></tr>
      <tr><td>&nbsp;&nbsp;<b>Total</b></td><td align="right"><b>36</b>&nbsp;&nbsp;</td></tr>
    <tr><td rowspan="8">PPPoE, LLC/SNAP<br>RFC-2684</td><td>PPP</td><td align="right">2</td></tr>
      <tr><td>PPPoE</td><td align="right">6</td></tr>
      <tr><td>Ethernet Header</td><td align="right">14</td></tr>
      <tr><td>ATM LLC</td><td align="right">3</td></tr>
      <tr><td>ATM SNAP</td><td align="right">5</td></tr>
      <tr><td>ATM pad</td><td align="right">2</td></tr>
      <tr><td>ATM AAL5 SAR</td><td align="right">8</td></tr>
      <tr><td>&nbsp;&nbsp;<b>Total</b></td><td align="right"><b>40</b>&nbsp;&nbsp;</td></tr>
    <tr><td rowspan="10">PPPoE, LLC/SNAP+FCS<br>RFC-2684</td><td>PPP</td><td align="right">2</td></tr>
      <tr><td>PPPoE</td><td align="right">6</td></tr>
      <tr><td>Ethernet Header</td><td align="right">14</td></tr>
      <tr><td>Ethernet PAD <a href="#Note-8">[8]</a></td><td align="right">0</td></tr>
      <tr><td>Ethernet Checksum</td><td align="right">4</td></tr>
      <tr><td>ATM LLC</td><td align="right">3</td></tr>
      <tr><td>ATM SNAP</td><td align="right">5</td></tr>
      <tr><td>ATM pad</td><td align="right">2</td></tr>
      <tr><td>ATM AAL5 SAR</td><td align="right">8</td></tr>
      <tr><td>&nbsp;&nbsp;<b>Total</b></td><td align="right"><b>44</b>&nbsp;&nbsp;</td></tr>
  </table>

  <p>
    If the next hop of the packet is over a Ethernet link
    (as opposed to a PPP link say), then the kernel will
    add an Ethernet header to the packet length before
    looking up the rate table.  In that case you must
    subtract the length of an Ethernet header (14 bytes)
    from the figure above.  This is how the negative overhead
    figure arises.
  </p>

  <p>
    There are also additional overheads on incoming packets.
    However, if you are using IMQ for ingress control you can
    ignore this as it removes them.
  </p>

  <p>
    The overheads above can then be used to calculate the optimal MTU.
    The optimal MTU is the one that generates the largest packet size
    that doesn't need to have its last ATM cell padded
    <a href="#Note-9">[9]</a>.  In other words, it is the largest packet
    size that is evenly divisible by 48.  This packet size includes
    all of the overheads listed above.
  </p>
  
  <p>
    The largest packet size in turn is determined by the underlying
    link layer you are using to transport your data to your modem.
    For Ethernet and most other transports, it is 1500 bytes.  To that
    you have to include the overheads added by ATM, which is everything
    bar the PPPoE and PPP headers.  For PPPoE VC/Mux say, this is
    the Ethernet and ATM headers, which total 26 bytes.  Hence the
    largest packet size that could conceivably seen by ATM when you
    are using PPPoE is 1526 bytes.  This occupies 31.7916' ATM cells.
    The last cell (the once carrying the .7916' bit) has padding,
    which we don't want so we discard it.  This means largest optimal
    packet size occupies 31 cells.  You can do this calculation for
    all the other protocols but it turns out all the optimal size for
    all is 31 ATM cells.
  </p>

  <p>
    31 ATM cells carry 1488 bytes of data.  But some of that data
    is overhead added after the kernel sends the packet.  As those
    overheads are not included in the MTU they must be removed.
    The overheads are just those listed in the table above - but
    there is a final twist.  The link layer carries its own overheads
    "for free" as it were, thus they must be removed from the
    overheads in the table.  Generally the link layer is Ethernet,
    so if the overheads in the table include the Ethernet Header
    and CRC you remove them, then subtract the resulting figure
    from 1488 to get the optimal MTU.
  </p>

  <p>
    For example for PPPoE VC/Mux there are 16 bytes of non Ethernet
    overheads, so the resultant optimal MTU is 1472 bytes.
  </p>

  <h2>ADSL Link Speed</h2>

  <p>
    In deriving the ADSL link speed from the figure printed by
    wget four assumptions are made:
  </p>

  <ol class="a">
    <li>Data is being carried in MTU sized chunks.</li>
    <li>The link is unused and traffic control is off.</li>
    <li>The data can't be compressed any further.</li>
    <li>The TCP ACK's coming back aren't hindered.</li>
  </ol>

  <p>
    The first step is to calculate the number of ATM cells an
    it would take to send an MTU sized packet.
    The number of data bytes seen by the ATM link is the MTU
    plus the overheads from the above table.  This then
    rounded up to the smallest number of whole ATM cells that
    will hold the data.  As each ATM cell holds 48 bytes of
    data, this becomes:
  </p>

  <p class="example">
    floor((MTU+overhead+48-1)/48)    {cells/packet}
  </p>

  <p>
    The next step is to calculate the number of packets being
    transmitted per second.  The amount of data being sent in
    each packet is the MTU less the TCP/IP overheads.  Assuming
    the TCP/IP overheads are:
  </p>

  <ul>
    <li>20 bytes of IP header.</li>
    <li>20 bytes of TCP header.</li>
    <li>12 bytes for the TCP RTT option.</li>
  </ul>

  <p>
    And since wget reports in units of Ki bytes/sec, we have:
  </p>

  <p class="example">
    packet_rate = wget_rate*1024 /(MTU-52)    {packets/second}
  </p>

  <p>
    Finally, we have to convert the transmission rate from cells
    per second to Kbits per second.  So we end up with:
  </p>

  <p class="example">
    link_speed
    &nbsp;&nbsp;= wget_rate*1024 /(MTU-52)        {packets/second}
    &nbsp;&nbsp;  * floor((MTU+overhead+48-1)/48) {cells/packet}
    &nbsp;&nbsp;  * 53                            {bytes/cell}
    &nbsp;&nbsp;  * 8                             {bits/byte}
    &nbsp;&nbsp;  / 1000                          {1/K}
    &nbsp;&nbsp;= wget_rate / (MTU - 52) * floor((MTU+overhead+47)/48) * 434.176 {Kbits/second}
  </p>

<h1><a name="history">History &amp; Acknowledgements</a></h1>

  <p>
    My own work in this arose because I was trying to implement
    a VOIP network.  I was getting weird results from the
    traffic control engine which I eventually tracked down
    to tc now allowing for ATM cell padding.  I wrote some
    patches to fix this, and since I don't like carrying patches
    I intended to post them upstream.
  </p>

  <p>
    Having written the code, I then discovered that someone
    had been there and done that: Jesper Brouer and his
    <a href="http://www.adsl-optimizer.dk">ADSL Optimizer</a>.
    Jesper had obviously spent a lot more time than I had
    at analysing the problem and his code was mature -
    unlike mine.  If I was going to post a patch upstream
    his patches were obviously the better starting point.
  </p>

  <p>
    Hence the tcatm patches are Jespers, but with a few changes:
  </p>

  <ul class="expanded">
    <li>
      Jesper's tc/iproute2 patches were not option based. If you
      applied it, the traffic control engine assumed everything
      was going over ATM. That obviously wouldn't work upstream.
      So now the ATM overheads are only included if you supply an
      option to tc.
    </li>
    <li>
      Jesper's patched version of tc assumed the kernel was
      patched and wouldn't work very well on unpatched kernels
      if the overheads were large.  This version works as well
      as it is possible to do so on an unpatched kernel.
    </li>
    <li>
      I allowed for negative overheads.
    </li>
  </ul>

  <p>
    Before posting these patches I invited to Jesper to comment
    on them.  He did and I have incorporated his suggestions,
    so this is now more of a joint effort.  However when agreeing
    to put his name on them he has relied on my assurances that
    the new code is semantically identical to his.  If it isn't
    the fault is entirely mine.
  </p>

  <p>
    The htb-nohyst patch is mine.  The best source
    of information on HTB is the authors
    <a href="http://luxik.cdi.cz/~devik/qos/htb/">web site</a>
    about it.
  </p>

  <p>
    You must do ingress traffic control for VOIP to work.  The
    only way I know to do that effectively under Linux is to use
    <a href="http://www.linuximq.net">Linux IMQ</a>.
  </p>

  <p>
    Finally, this would not of happened if my employer,
    <a href="http://www.lubemobile.com.au/">Lube Mobile</a>,
    wasn't prepared to let me work on this to get
    their VOIP system going.
  </p>

<h1><a name="notes">Notes</a></h1>

  <table class="notes">
    <tr>
      <td><a name="Note-1">[1]</a></td>
      <td>
	The effects of the hysteresis optimisation on flow control
	are worse than you might expect, particularly for applications
	that don't like jitter - such as VOIP.  See
	<a href="http://www.adsl-optimizer.dk/thesis/">Jesper's thesis</a>,
	chapter 7, section 7.3.1, pp 69-70 for details.
      </td>
    </tr>
    <tr>
      <td><a name="Note-2">[2]</a></td>
      <td>
        Well, it might still be an atm link.  But if it is your job
	is to run the Internet, and you don't need me to tell you if
	it is or isn't.
      </td>
    </tr>
    <tr>
      <td><a name="Note-3">[3]</a></td>
      <td>
        The formula is given as a python expression.  If you don't
	understand it you can just run this:<br/>
	&nbsp;&nbsp;&nbsp;<code>python -c 'import math; wget_rate=<span class="u">XXX</span>; MTU=<span class="u">YYY</span>; print <span class="u">formula</span>'</code><br/>
	to print the raw ADSL line speed in Kbits/second.  You have to replace the
	<code><span class="u">underlined_bits</span></code> with your actual figures and
	the formula from the table.
      </td>
    </tr>
    <tr>
      <td><a name="Note-4">[4]</a></td>
      <td>
        I have omitted packet length scaling here as it doesn't effect
	what follows.
      </td>
    </tr>
    <tr>
      <td><a name="Note-5">[5]</a></td>
      <td>
	"Tweak" here means lie to kernel about the overhead and/or
	link speed.  For large packets you can reduce the link speed
	by 5%.  For small packets, it is simpler to include the ATM
	padding in the overhead.
      </td>
    </tr>
    <tr>
      <td><a name="Note-6">[6]</a></td>
      <td>
	The intention is to approximate the worst case scenario.
      </td>
    </tr>
    <tr>
      <td><a name="Note-7">[7]</a></td>
      <td>
	Connections running at say less than 10Mbits/second.
      </td>
    </tr>
    <tr>
      <td><a name="Note-8">[8]</a></td>
      <td>
	When the Ethernet Frame Checksum (FCS) is added, the Ethernet frame
	padding is included as well.  The padding ensures the frame is
	at least 64 bytes long.  However, in a typical Linux packet we have
	within an Ethernet frame:<br>
	  &nbsp;&nbsp;-&nbsp;14 bytes of Ethernet Header,<br>
	  &nbsp;&nbsp;-&nbsp;6 bytes of PPPoE Header,<br>
	  &nbsp;&nbsp;-&nbsp;2 bytes of PPP Header,<br>
	  &nbsp;&nbsp;-&nbsp;20 bytes of IP Header,<br>
	  &nbsp;&nbsp;-&nbsp;20 bytes of TCP Header,<br>
	  &nbsp;&nbsp;-&nbsp;12 bytes of TCP RTT Options, and<br>
	  &nbsp;&nbsp;-&nbsp;4 bytes of Ethernet FCS.<br>
	Which is more than 64 bytes.  There is no data because a TCP ACK
	has no data.  UDP (and in particular VOIP) have less headers,
	but make up for it by always carrying data.
      </td>
    </tr>
    <tr>
      <td><a name="Note-9">[9]</a></td>
      <td>
	This is not strictly true.  Splitting a packet carries its
	own penalty.  When you add in the IP and TCP headers to all
	the other bits and pieces listed in the table an IP packet
	carries around 78 bytes of overheads.  If the MTU is 1488
	bytes, this is about 4.8%.  Two or one bytes of ATM cell
	padding actually incurs less overhead than this.  Mercifully
	that case doesn't arise for a 1500 byte link layer MTU.<br/>
	<br/>
	While you are thinking about this, consider the implications
	of those overheads on VOIP, whose packets typically carry
	around 40 bytes of voice data.  And that is not counting the
	ATM cell overheads which average an additional 34 bytes.
      </td>
    </tr>
  </table>

<h1><a name="contact">Contact Details</a></h1>

  <p>
    You can email me at "russell-tcatm [at] stuart [dot] id [dot] au".
    If you want immediate feedback you can contact me via a messenger
    client.  I am not into just chatting, but if you have questions
    or just need a sounding board I am happy to help.  Here are my
    messenger id's:
  </p>

  <ul>
    <li>Jabber: russell-jabber [at] stuart [dot] id [dot] au</li>
    <li>Yahoo: rstuart4133</li>
    <li>MSN: russell-msn [at] stuart [dot] id [dot] au</li>
    <li>ICQ: 159665522</li>
  </ul>

  <p>
    Time Zone: Australia/Queensland, which is 10 hours ahead of UTC.
  </p>

<p class="signature">
  Russell Stuart, 25/May/2006.
</p>

</body>
</html>
